{
  "config": {
    "configFile": "/home/runner/work/claudetest123/claudetest123/playwright.config.ts",
    "rootDir": "/home/runner/work/claudetest123/claudetest123/e2e",
    "forbidOnly": true,
    "fullyParallel": true,
    "globalSetup": null,
    "globalTeardown": null,
    "globalTimeout": 0,
    "grep": {},
    "grepInvert": null,
    "maxFailures": 0,
    "metadata": {
      "ci": {
        "commitHref": "https://github.com/bjuergens/claudetest123/commit/f2415d687687fb5b4c621b7afc5d3ede438ea15e",
        "commitHash": "f2415d687687fb5b4c621b7afc5d3ede438ea15e",
        "prHref": "https://github.com/bjuergens/claudetest123/pull/10",
        "prTitle": "Extract GridManager, PhysicsEngine, and UpgradeManager from HeatGame",
        "prBaseHash": "f29e01ec7cb04beabadc275fcf431907f165675e",
        "buildHref": "https://github.com/bjuergens/claudetest123/actions/runs/21544476564"
      },
      "gitCommit": {
        "shortHash": "f2415d6",
        "hash": "f2415d687687fb5b4c621b7afc5d3ede438ea15e",
        "subject": "Merge f1d0811b84cdb7430f690b6091fb1360bd7b3172 into f29e01ec7cb04beabadc275fcf431907f165675e",
        "body": "Merge f1d0811b84cdb7430f690b6091fb1360bd7b3172 into f29e01ec7cb04beabadc275fcf431907f165675e\n",
        "author": {
          "name": "Björn Jürgens",
          "email": "4362465+bjuergens@users.noreply.github.com",
          "time": 1769862464000
        },
        "committer": {
          "name": "GitHub",
          "email": "noreply@github.com",
          "time": 1769862464000
        },
        "branch": "HEAD"
      },
      "gitDiff": "diff --git a/src/game/GridManager.test.ts b/src/game/GridManager.test.ts\nnew file mode 100644\nindex 0000000..468ae34\n--- /dev/null\n+++ b/src/game/GridManager.test.ts\n@@ -0,0 +1,277 @@\n+/**\n+ * Unit tests for GridManager\n+ *\n+ * Tests grid creation, neighbor calculations, and cell operations in isolation.\n+ */\n+\n+import { describe, it, expect, beforeEach } from 'vitest';\n+import { GridManager } from './GridManager.js';\n+import { StructureType, Tier } from './BalanceConfig.js';\n+\n+describe('GridManager', () => {\n+  let gridManager: GridManager;\n+\n+  beforeEach(() => {\n+    gridManager = new GridManager(16);\n+  });\n+\n+  describe('initialization', () => {\n+    it('should create a grid of the specified size', () => {\n+      expect(gridManager.getSize()).toBe(16);\n+    });\n+\n+    it('should initialize all cells as empty', () => {\n+      const snapshot = gridManager.getSnapshot();\n+      for (let y = 0; y < 16; y++) {\n+        for (let x = 0; x < 16; x++) {\n+          expect(snapshot[y][x].structure).toBe(StructureType.Empty);\n+          expect(snapshot[y][x].heat).toBe(0);\n+          expect(snapshot[y][x].power).toBe(0);\n+        }\n+      }\n+    });\n+\n+    it('should set correct x,y coordinates for each cell', () => {\n+      const snapshot = gridManager.getSnapshot();\n+      for (let y = 0; y < 16; y++) {\n+        for (let x = 0; x < 16; x++) {\n+          expect(snapshot[y][x].x).toBe(x);\n+          expect(snapshot[y][x].y).toBe(y);\n+        }\n+      }\n+    });\n+  });\n+\n+  describe('getCell', () => {\n+    it('should return a copy of the cell at valid coordinates', () => {\n+      const cell = gridManager.getCell(5, 5);\n+      expect(cell).not.toBeNull();\n+      expect(cell!.x).toBe(5);\n+      expect(cell!.y).toBe(5);\n+    });\n+\n+    it('should return null for out-of-bounds coordinates', () => {\n+      expect(gridManager.getCell(-1, 0)).toBeNull();\n+      expect(gridManager.getCell(0, -1)).toBeNull();\n+      expect(gridManager.getCell(16, 0)).toBeNull();\n+      expect(gridManager.getCell(0, 16)).toBeNull();\n+    });\n+\n+    it('should return a copy, not a reference', () => {\n+      const cell = gridManager.getCell(5, 5);\n+      cell!.heat = 100;\n+      const cellAgain = gridManager.getCell(5, 5);\n+      expect(cellAgain!.heat).toBe(0);\n+    });\n+  });\n+\n+  describe('getCellRef', () => {\n+    it('should return a reference that can be mutated', () => {\n+      const cellRef = gridManager.getCellRef(5, 5);\n+      cellRef!.heat = 100;\n+      const cell = gridManager.getCell(5, 5);\n+      expect(cell!.heat).toBe(100);\n+    });\n+\n+    it('should return null for out-of-bounds coordinates', () => {\n+      expect(gridManager.getCellRef(-1, 0)).toBeNull();\n+      expect(gridManager.getCellRef(16, 0)).toBeNull();\n+    });\n+  });\n+\n+  describe('isValidPosition', () => {\n+    it('should return true for valid positions', () => {\n+      expect(gridManager.isValidPosition(0, 0)).toBe(true);\n+      expect(gridManager.isValidPosition(15, 15)).toBe(true);\n+      expect(gridManager.isValidPosition(8, 8)).toBe(true);\n+    });\n+\n+    it('should return false for invalid positions', () => {\n+      expect(gridManager.isValidPosition(-1, 0)).toBe(false);\n+      expect(gridManager.isValidPosition(0, -1)).toBe(false);\n+      expect(gridManager.isValidPosition(16, 0)).toBe(false);\n+      expect(gridManager.isValidPosition(0, 16)).toBe(false);\n+    });\n+  });\n+\n+  describe('getNeighbors', () => {\n+    it('should return 4 neighbors for center cells', () => {\n+      const neighbors = gridManager.getNeighbors(8, 8);\n+      expect(neighbors).toHaveLength(4);\n+    });\n+\n+    it('should return 3 neighbors for edge cells', () => {\n+      const neighbors = gridManager.getNeighbors(0, 8);\n+      expect(neighbors).toHaveLength(3);\n+    });\n+\n+    it('should return 2 neighbors for corner cells', () => {\n+      const neighbors = gridManager.getNeighbors(0, 0);\n+      expect(neighbors).toHaveLength(2);\n+    });\n+\n+    it('should return orthogonal neighbors only', () => {\n+      const neighbors = gridManager.getNeighbors(5, 5);\n+      const positions = neighbors.map(n => ({ x: n.x, y: n.y }));\n+\n+      expect(positions).toContainEqual({ x: 5, y: 4 }); // up\n+      expect(positions).toContainEqual({ x: 5, y: 6 }); // down\n+      expect(positions).toContainEqual({ x: 4, y: 5 }); // left\n+      expect(positions).toContainEqual({ x: 6, y: 5 }); // right\n+    });\n+  });\n+\n+  describe('countAdjacentFuelRods', () => {\n+    it('should return 0 when no fuel rods are adjacent', () => {\n+      expect(gridManager.countAdjacentFuelRods(5, 5)).toBe(0);\n+    });\n+\n+    it('should count active fuel rods only', () => {\n+      // Place active fuel rod\n+      const cell1 = gridManager.getCellRef(5, 4)!;\n+      cell1.structure = StructureType.FuelRod;\n+      cell1.lifetime = 100;\n+\n+      // Place depleted fuel rod\n+      const cell2 = gridManager.getCellRef(5, 6)!;\n+      cell2.structure = StructureType.FuelRod;\n+      cell2.lifetime = 0;\n+\n+      expect(gridManager.countAdjacentFuelRods(5, 5)).toBe(1);\n+    });\n+\n+    it('should count all adjacent active fuel rods', () => {\n+      const positions = [\n+        { x: 5, y: 4 },\n+        { x: 5, y: 6 },\n+        { x: 4, y: 5 },\n+        { x: 6, y: 5 },\n+      ];\n+\n+      for (const pos of positions) {\n+        const cell = gridManager.getCellRef(pos.x, pos.y)!;\n+        cell.structure = StructureType.FuelRod;\n+        cell.lifetime = 100;\n+      }\n+\n+      expect(gridManager.countAdjacentFuelRods(5, 5)).toBe(4);\n+    });\n+  });\n+\n+  describe('getFilledCellCount', () => {\n+    it('should return 0 for empty grid', () => {\n+      expect(gridManager.getFilledCellCount()).toBe(0);\n+    });\n+\n+    it('should count non-empty cells', () => {\n+      gridManager.getCellRef(0, 0)!.structure = StructureType.FuelRod;\n+      gridManager.getCellRef(1, 1)!.structure = StructureType.Turbine;\n+      gridManager.getCellRef(2, 2)!.structure = StructureType.Ventilator;\n+\n+      expect(gridManager.getFilledCellCount()).toBe(3);\n+    });\n+  });\n+\n+  describe('expandGrid', () => {\n+    it('should expand grid to new size', () => {\n+      gridManager.getCellRef(5, 5)!.structure = StructureType.FuelRod;\n+\n+      const result = gridManager.expandGrid(18, 20);\n+      expect(result).toBe(true);\n+      expect(gridManager.getSize()).toBe(18);\n+    });\n+\n+    it('should preserve existing cells after expansion', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.heat = 500;\n+\n+      gridManager.expandGrid(18, 20);\n+\n+      const preserved = gridManager.getCell(5, 5);\n+      expect(preserved!.structure).toBe(StructureType.FuelRod);\n+      expect(preserved!.heat).toBe(500);\n+    });\n+\n+    it('should not expand beyond max size', () => {\n+      const result = gridManager.expandGrid(25, 20);\n+      expect(result).toBe(false);\n+      expect(gridManager.getSize()).toBe(16);\n+    });\n+\n+    it('should not shrink the grid', () => {\n+      const result = gridManager.expandGrid(10, 20);\n+      expect(result).toBe(false);\n+      expect(gridManager.getSize()).toBe(16);\n+    });\n+  });\n+\n+  describe('resetCell', () => {\n+    it('should reset a cell to empty state', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.Turbine;\n+      cell.heat = 500;\n+      cell.power = 100;\n+\n+      gridManager.resetCell(5, 5);\n+\n+      const reset = gridManager.getCell(5, 5);\n+      expect(reset!.structure).toBe(StructureType.Empty);\n+      expect(reset!.heat).toBe(0);\n+      expect(reset!.power).toBe(0);\n+    });\n+\n+    it('should preserve coordinates after reset', () => {\n+      gridManager.resetCell(5, 5);\n+      const cell = gridManager.getCell(5, 5);\n+      expect(cell!.x).toBe(5);\n+      expect(cell!.y).toBe(5);\n+    });\n+  });\n+\n+  describe('clearAll', () => {\n+    it('should reset all cells to empty', () => {\n+      // Fill some cells\n+      for (let i = 0; i < 5; i++) {\n+        gridManager.getCellRef(i, i)!.structure = StructureType.FuelRod;\n+      }\n+\n+      gridManager.clearAll();\n+\n+      expect(gridManager.getFilledCellCount()).toBe(0);\n+    });\n+  });\n+\n+  describe('forEach', () => {\n+    it('should iterate over all cells', () => {\n+      let count = 0;\n+      gridManager.forEach(() => count++);\n+      expect(count).toBe(16 * 16);\n+    });\n+\n+    it('should provide correct cell references', () => {\n+      gridManager.forEach((cell, x, y) => {\n+        expect(cell.x).toBe(x);\n+        expect(cell.y).toBe(y);\n+      });\n+    });\n+  });\n+\n+  describe('restoreFromState', () => {\n+    it('should restore grid from serialized state', () => {\n+      // Create a state to restore\n+      const state = gridManager.getSnapshot();\n+      state[5][5].structure = StructureType.Turbine;\n+      state[5][5].heat = 250;\n+\n+      // Create new grid manager and restore\n+      const newGridManager = new GridManager(10);\n+      newGridManager.restoreFromState(state, 16);\n+\n+      expect(newGridManager.getSize()).toBe(16);\n+      const cell = newGridManager.getCell(5, 5);\n+      expect(cell!.structure).toBe(StructureType.Turbine);\n+      expect(cell!.heat).toBe(250);\n+    });\n+  });\n+});\ndiff --git a/src/game/GridManager.ts b/src/game/GridManager.ts\nnew file mode 100644\nindex 0000000..0e158a8\n--- /dev/null\n+++ b/src/game/GridManager.ts\n@@ -0,0 +1,221 @@\n+/**\n+ * GridManager - Handles grid creation, neighbor calculations, and cell operations\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ */\n+\n+import { StructureType, Tier } from './BalanceConfig.js';\n+\n+export interface Cell {\n+  x: number;\n+  y: number;\n+  structure: StructureType;\n+  tier: Tier;\n+  heat: number;\n+  power: number;\n+  /** Remaining lifetime in ticks (fuel rods only, 0 = infinite/depleted) */\n+  lifetime: number;\n+  /** Whether this is an exotic variant (fuel rods only) */\n+  isExotic: boolean;\n+}\n+\n+export class GridManager {\n+  private grid: Cell[][];\n+  private gridSize: number;\n+\n+  constructor(initialSize: number) {\n+    this.gridSize = initialSize;\n+    this.grid = this.createEmptyGrid(initialSize);\n+  }\n+\n+  /**\n+   * Create a new empty grid of the specified size\n+   */\n+  createEmptyGrid(size: number): Cell[][] {\n+    const grid: Cell[][] = [];\n+    for (let y = 0; y < size; y++) {\n+      const row: Cell[] = [];\n+      for (let x = 0; x < size; x++) {\n+        row.push(this.createEmptyCell(x, y));\n+      }\n+      grid.push(row);\n+    }\n+    return grid;\n+  }\n+\n+  /**\n+   * Create an empty cell at the specified coordinates\n+   */\n+  createEmptyCell(x: number, y: number): Cell {\n+    return {\n+      x,\n+      y,\n+      structure: StructureType.Empty,\n+      tier: Tier.T1,\n+      heat: 0,\n+      power: 0,\n+      lifetime: 0,\n+      isExotic: false,\n+    };\n+  }\n+\n+  /**\n+   * Get a copy of a cell at the specified coordinates\n+   * Returns null if coordinates are out of bounds\n+   */\n+  getCell(x: number, y: number): Cell | null {\n+    if (!this.isValidPosition(x, y)) {\n+      return null;\n+    }\n+    return { ...this.grid[y][x] };\n+  }\n+\n+  /**\n+   * Get a direct reference to a cell (for mutation)\n+   * Returns null if coordinates are out of bounds\n+   */\n+  getCellRef(x: number, y: number): Cell | null {\n+    if (!this.isValidPosition(x, y)) {\n+      return null;\n+    }\n+    return this.grid[y][x];\n+  }\n+\n+  /**\n+   * Check if coordinates are within grid bounds\n+   */\n+  isValidPosition(x: number, y: number): boolean {\n+    return x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize;\n+  }\n+\n+  /**\n+   * Get the current grid size\n+   */\n+  getSize(): number {\n+    return this.gridSize;\n+  }\n+\n+  /**\n+   * Get a snapshot (deep copy) of the entire grid\n+   */\n+  getSnapshot(): Cell[][] {\n+    return this.grid.map(row => row.map(cell => ({ ...cell })));\n+  }\n+\n+  /**\n+   * Get the internal grid reference (for physics engine)\n+   */\n+  getGridRef(): Cell[][] {\n+    return this.grid;\n+  }\n+\n+  /**\n+   * Get orthogonal neighbors (up, down, left, right) of a cell\n+   */\n+  getNeighbors(x: number, y: number): Cell[] {\n+    const neighbors: Cell[] = [];\n+    const directions = [\n+      { dx: 0, dy: -1 }, // up\n+      { dx: 0, dy: 1 },  // down\n+      { dx: -1, dy: 0 }, // left\n+      { dx: 1, dy: 0 },  // right\n+    ];\n+\n+    for (const { dx, dy } of directions) {\n+      const nx = x + dx;\n+      const ny = y + dy;\n+      if (this.isValidPosition(nx, ny)) {\n+        neighbors.push(this.grid[ny][nx]);\n+      }\n+    }\n+\n+    return neighbors;\n+  }\n+\n+  /**\n+   * Count active (non-depleted) fuel rods adjacent to a position\n+   */\n+  countAdjacentFuelRods(x: number, y: number): number {\n+    const neighbors = this.getNeighbors(x, y);\n+    return neighbors.filter(n => n.structure === StructureType.FuelRod && n.lifetime > 0).length;\n+  }\n+\n+  /**\n+   * Count filled (non-empty) cells in the grid\n+   */\n+  getFilledCellCount(): number {\n+    let count = 0;\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        if (this.grid[y][x].structure !== StructureType.Empty) {\n+          count++;\n+        }\n+      }\n+    }\n+    return count;\n+  }\n+\n+  /**\n+   * Expand the grid to a new size, preserving existing cells\n+   * Returns true if expansion was successful\n+   */\n+  expandGrid(newSize: number, maxSize: number): boolean {\n+    if (newSize <= this.gridSize) return false;\n+    if (newSize > maxSize) return false;\n+\n+    const oldGrid = this.grid;\n+    const oldSize = this.gridSize;\n+\n+    // Create new larger grid\n+    this.grid = this.createEmptyGrid(newSize);\n+    this.gridSize = newSize;\n+\n+    // Copy old grid data\n+    for (let y = 0; y < oldSize; y++) {\n+      for (let x = 0; x < oldSize; x++) {\n+        this.grid[y][x] = { ...oldGrid[y][x] };\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Reset a cell to empty state\n+   */\n+  resetCell(x: number, y: number): void {\n+    if (this.isValidPosition(x, y)) {\n+      this.grid[y][x] = this.createEmptyCell(x, y);\n+    }\n+  }\n+\n+  /**\n+   * Clear all cells in the grid (reset to empty)\n+   */\n+  clearAll(): void {\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        this.grid[y][x] = this.createEmptyCell(x, y);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Iterate over all cells, calling the callback for each\n+   */\n+  forEach(callback: (cell: Cell, x: number, y: number) => void): void {\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        callback(this.grid[y][x], x, y);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Restore grid state from serialized data\n+   */\n+  restoreFromState(grid: Cell[][], gridSize: number): void {\n+    this.gridSize = gridSize;\n+    this.grid = grid.map(row => row.map(cell => ({ ...cell })));\n+  }\n+}\ndiff --git a/src/game/HeatGame.ts b/src/game/HeatGame.ts\nindex 24971dc..eeca20d 100644\n--- a/src/game/HeatGame.ts\n+++ b/src/game/HeatGame.ts\n@@ -1,15 +1,10 @@\n /**\n  * Heat Management Game - Core Game Logic\n  *\n- * Refactored to support:\n- * - Tiered items (T1-T4)\n- * - Fuel rod lifetime and depletion\n- * - Adjacency heat bonus for fuel rods\n- * - Manual power generation (clicker)\n- * - Upgrade system (regular + secret)\n- * - Exotic fuel rods\n- * - Dynamic grid size (16x16 to 20x20)\n- * - Variable melt temperatures and conductivity\n+ * Refactored to use composed classes for better separation of concerns:\n+ * - GridManager: Grid creation and cell operations\n+ * - PhysicsEngine: Heat/power simulation\n+ * - UpgradeManager: Upgrade and secret management\n  */\n \n import {\n@@ -18,46 +13,28 @@ import {\n   Tier,\n   StructureType,\n   STRUCTURE_BASE_STATS,\n-  FUEL_ADJACENCY,\n-  ECONOMY,\n   UpgradeType,\n-  UPGRADE_DEFINITIONS,\n   SecretUpgradeType,\n   SECRET_UPGRADE_DEFINITIONS,\n-  EXOTIC_FUEL,\n   getStructureCost,\n   getFuelLifetime,\n-  getFuelHeatGeneration,\n-  getUpgradeCost,\n-  getSecretUnlockProgress,\n } from './BalanceConfig.js';\n \n+import { GridManager, Cell } from './GridManager.js';\n+import { PhysicsEngine, PhysicsEvent } from './PhysicsEngine.js';\n+import { UpgradeManager, UpgradeEvent } from './UpgradeManager.js';\n+\n // Re-export types for backward compatibility\n export { StructureType, Tier, UpgradeType, SecretUpgradeType };\n-\n-export interface Cell {\n-  x: number;\n-  y: number;\n-  structure: StructureType;\n-  tier: Tier;\n-  heat: number;\n-  power: number;\n-  /** Remaining lifetime in ticks (fuel rods only, 0 = infinite/depleted) */\n-  lifetime: number;\n-  /** Whether this is an exotic variant (fuel rods only) */\n-  isExotic: boolean;\n-}\n+export { Cell };\n \n export interface UpgradeState {\n   levels: Record<UpgradeType, number>;\n }\n \n export interface SecretState {\n-  /** Whether the unlock condition has been met */\n   unlocked: Record<SecretUpgradeType, boolean>;\n-  /** Whether the upgrade has been purchased */\n   purchased: Record<SecretUpgradeType, boolean>;\n-  /** Toggle state for toggleable secrets */\n   enabled: Record<SecretUpgradeType, boolean>;\n }\n \n@@ -107,87 +84,101 @@ export interface GameEvent {\n \n export type GameEventListener = (event: GameEvent) => void;\n \n-// Helper to create initial upgrade state\n-function createInitialUpgradeState(): UpgradeState {\n-  const levels: Record<UpgradeType, number> = {} as Record<UpgradeType, number>;\n-  for (const type of Object.values(UpgradeType)) {\n-    levels[type] = 0;\n-  }\n-  return { levels };\n-}\n-\n-// Helper to create initial secret state\n-function createInitialSecretState(): SecretState {\n-  const unlocked: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n-  const purchased: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n-  const enabled: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n-\n-  for (const type of Object.values(SecretUpgradeType)) {\n-    unlocked[type] = false;\n-    purchased[type] = false;\n-    enabled[type] = false;\n-  }\n-  return { unlocked, purchased, enabled };\n-}\n-\n+/**\n+ * HeatGame - Main game orchestrator\n+ *\n+ * Composes GridManager, PhysicsEngine, and UpgradeManager to coordinate\n+ * game logic while delegating specific responsibilities to each component.\n+ */\n export class HeatGame {\n-  private state: GameState;\n+  private gridManager: GridManager;\n+  private physicsEngine: PhysicsEngine;\n+  private upgradeManager: UpgradeManager;\n+\n+  private money: number;\n+  private stats: GameStats;\n   private eventListeners: GameEventListener[] = [];\n \n   constructor(initialMoney: number = CORE_SETTINGS.STARTING_MONEY) {\n-    this.state = this.createInitialState(initialMoney);\n-  }\n+    // Initialize composed components\n+    this.gridManager = new GridManager(CORE_SETTINGS.INITIAL_GRID_SIZE);\n+    this.upgradeManager = new UpgradeManager();\n+    this.physicsEngine = new PhysicsEngine(\n+      this.gridManager,\n+      (type: UpgradeType) => this.upgradeManager.getUpgradeLevel(type)\n+    );\n+\n+    this.money = initialMoney;\n+    this.stats = this.createInitialStats();\n \n-  private createInitialState(initialMoney: number): GameState {\n-    const gridSize = CORE_SETTINGS.INITIAL_GRID_SIZE;\n-    const grid = this.createEmptyGrid(gridSize);\n+    // Wire up event forwarding from sub-components\n+    this.setupEventForwarding();\n+  }\n \n+  private createInitialStats(): GameStats {\n     return {\n-      grid,\n-      gridSize,\n-      money: initialMoney,\n-      stats: {\n-        totalPowerGenerated: 0,\n-        totalMoneyEarned: 0,\n-        meltdownCount: 0,\n-        tickCount: 0,\n-        demolishCount: 0,\n-        ticksAtHighHeat: 0,\n-        manualClicks: 0,\n-        structuresBuilt: 0,\n-        fuelRodsDepleted: 0,\n-      },\n-      upgrades: createInitialUpgradeState(),\n-      secrets: createInitialSecretState(),\n+      totalPowerGenerated: 0,\n+      totalMoneyEarned: 0,\n+      meltdownCount: 0,\n+      tickCount: 0,\n+      demolishCount: 0,\n+      ticksAtHighHeat: 0,\n+      manualClicks: 0,\n+      structuresBuilt: 0,\n+      fuelRodsDepleted: 0,\n     };\n   }\n \n-  private createEmptyGrid(size: number): Cell[][] {\n-    const grid: Cell[][] = [];\n-    for (let y = 0; y < size; y++) {\n-      const row: Cell[] = [];\n-      for (let x = 0; x < size; x++) {\n-        row.push(this.createEmptyCell(x, y));\n+  private setupEventForwarding(): void {\n+    // Forward physics events\n+    // Note: Stats are tracked in PhysicsEngine, we only forward events here\n+    this.physicsEngine.addEventListener((event: PhysicsEvent) => {\n+      if (event.type === 'fuel_depleted') {\n+        // Don't increment here - PhysicsEngine already tracks this stat\n+        this.emitEvent({\n+          type: 'fuel_depleted',\n+          x: event.x,\n+          y: event.y,\n+          tier: event.tier,\n+        });\n+      } else if (event.type === 'power_sold') {\n+        this.emitEvent({\n+          type: 'power_sold',\n+          x: event.x,\n+          y: event.y,\n+          amount: event.amount,\n+        });\n+      } else if (event.type === 'structure_melted') {\n+        this.emitEvent({\n+          type: 'structure_melted',\n+          x: event.x,\n+          y: event.y,\n+          structure: event.structure,\n+          tier: event.tier,\n+        });\n+      } else if (event.type === 'meltdown') {\n+        this.stats.meltdownCount++;\n+        this.emitEvent({ type: 'meltdown' });\n+        this.checkSecretUnlocks();\n       }\n-      grid.push(row);\n-    }\n-    return grid;\n-  }\n+    });\n \n-  private createEmptyCell(x: number, y: number): Cell {\n-    return {\n-      x,\n-      y,\n-      structure: StructureType.Empty,\n-      tier: Tier.T1,\n-      heat: 0,\n-      power: 0,\n-      lifetime: 0,\n-      isExotic: false,\n-    };\n+    // Forward upgrade events\n+    this.upgradeManager.addEventListener((event: UpgradeEvent) => {\n+      if (event.type === 'upgrade_purchased') {\n+        this.emitEvent({ type: 'upgrade_purchased', upgradeType: event.upgradeType });\n+      } else if (event.type === 'secret_unlocked') {\n+        this.emitEvent({ type: 'secret_unlocked', secretType: event.secretType });\n+      } else if (event.type === 'secret_purchased') {\n+        this.emitEvent({ type: 'secret_purchased', secretType: event.secretType });\n+      }\n+    });\n   }\n \n-  // Event system\n+  // ==========================================================================\n+  // EVENT SYSTEM\n+  // ==========================================================================\n+\n   addEventListener(listener: GameEventListener): void {\n     this.eventListeners.push(listener);\n   }\n@@ -206,74 +197,63 @@ export class HeatGame {\n   }\n \n   // ==========================================================================\n-  // GETTERS\n+  // GETTERS (delegate to sub-components)\n   // ==========================================================================\n \n   getCell(x: number, y: number): Cell | null {\n-    if (x < 0 || x >= this.state.gridSize || y < 0 || y >= this.state.gridSize) {\n-      return null;\n-    }\n-    return { ...this.state.grid[y][x] };\n+    return this.gridManager.getCell(x, y);\n   }\n \n   getGridSize(): number {\n-    return this.state.gridSize;\n+    return this.gridManager.getSize();\n   }\n \n   getMoney(): number {\n-    return this.state.money;\n+    return this.money;\n   }\n \n   getTickCount(): number {\n-    return this.state.stats.tickCount;\n+    return this.stats.tickCount;\n   }\n \n   getMeltdownCount(): number {\n-    return this.state.stats.meltdownCount;\n+    return this.stats.meltdownCount;\n   }\n \n   getTotalPowerGenerated(): number {\n-    return this.state.stats.totalPowerGenerated;\n+    return this.stats.totalPowerGenerated;\n   }\n \n   getTotalMoneyEarned(): number {\n-    return this.state.stats.totalMoneyEarned;\n+    return this.stats.totalMoneyEarned;\n   }\n \n   getStats(): GameStats {\n-    return { ...this.state.stats };\n+    return { ...this.stats };\n   }\n \n   getUpgradeLevel(type: UpgradeType): number {\n-    return this.state.upgrades.levels[type];\n+    return this.upgradeManager.getUpgradeLevel(type);\n   }\n \n   isSecretUnlocked(type: SecretUpgradeType): boolean {\n-    return this.state.secrets.unlocked[type];\n+    return this.upgradeManager.isSecretUnlocked(type);\n   }\n \n   isSecretPurchased(type: SecretUpgradeType): boolean {\n-    return this.state.secrets.purchased[type];\n+    return this.upgradeManager.isSecretPurchased(type);\n   }\n \n   isSecretEnabled(type: SecretUpgradeType): boolean {\n-    return this.state.secrets.enabled[type];\n+    return this.upgradeManager.isSecretEnabled(type);\n   }\n \n   getGridSnapshot(): Cell[][] {\n-    return this.state.grid.map(row => row.map(cell => ({ ...cell })));\n+    return this.gridManager.getSnapshot();\n   }\n \n   getFilledCellCount(): number {\n-    let count = 0;\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        if (this.state.grid[y][x].structure !== StructureType.Empty) {\n-          count++;\n-        }\n-      }\n-    }\n-    return count;\n+    return this.gridManager.getFilledCellCount();\n   }\n \n   // ==========================================================================\n@@ -281,13 +261,13 @@ export class HeatGame {\n   // ==========================================================================\n \n   manualGenerate(): number {\n-    const upgradeLevel = this.state.upgrades.levels[UpgradeType.ManualClickPower];\n+    const upgradeLevel = this.upgradeManager.getUpgradeLevel(UpgradeType.ManualClickPower);\n     const moneyEarned = MANUAL_GENERATION.BASE_MONEY_PER_CLICK +\n       (upgradeLevel * MANUAL_GENERATION.MONEY_PER_LEVEL);\n \n-    this.state.money += moneyEarned;\n-    this.state.stats.totalMoneyEarned += moneyEarned;\n-    this.state.stats.manualClicks++;\n+    this.money += moneyEarned;\n+    this.stats.totalMoneyEarned += moneyEarned;\n+    this.stats.manualClicks++;\n \n     this.emitEvent({ type: 'manual_click', amount: moneyEarned });\n     return moneyEarned;\n@@ -302,20 +282,21 @@ export class HeatGame {\n   }\n \n   canBuild(x: number, y: number, structure: StructureType, tier: Tier = Tier.T1): boolean {\n-    const cell = this.getCell(x, y);\n+    const cell = this.gridManager.getCell(x, y);\n     if (!cell) return false;\n     if (cell.structure !== StructureType.Empty) return false;\n \n     // Check if structure is secret and not unlocked\n     const baseStats = STRUCTURE_BASE_STATS[structure];\n     if (baseStats.isSecret) {\n-      if (structure === StructureType.VoidCell && !this.state.secrets.purchased[SecretUpgradeType.VoidCellUnlock]) {\n+      if (structure === StructureType.VoidCell &&\n+          !this.upgradeManager.isSecretPurchased(SecretUpgradeType.VoidCellUnlock)) {\n         return false;\n       }\n     }\n \n     const cost = getStructureCost(structure, tier);\n-    return this.state.money >= cost;\n+    return this.money >= cost;\n   }\n \n   build(x: number, y: number, structure: StructureType, tier: Tier = Tier.T1, isExotic: boolean = false): boolean {\n@@ -323,16 +304,16 @@ export class HeatGame {\n \n     // Exotic fuel requires the secret to be purchased and enabled\n     if (isExotic && structure === StructureType.FuelRod) {\n-      if (!this.state.secrets.purchased[SecretUpgradeType.ExoticFuel] ||\n-          !this.state.secrets.enabled[SecretUpgradeType.ExoticFuel]) {\n+      if (!this.upgradeManager.isSecretPurchased(SecretUpgradeType.ExoticFuel) ||\n+          !this.upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)) {\n         isExotic = false;\n       }\n     }\n \n     const cost = getStructureCost(structure, tier);\n-    this.state.money -= cost;\n+    this.money -= cost;\n \n-    const cell = this.state.grid[y][x];\n+    const cell = this.gridManager.getCellRef(x, y)!;\n     cell.structure = structure;\n     cell.tier = tier;\n     cell.heat = 0;\n@@ -341,13 +322,13 @@ export class HeatGame {\n \n     // Set lifetime for fuel rods\n     if (structure === StructureType.FuelRod) {\n-      const upgradeLevel = this.state.upgrades.levels[UpgradeType.FuelLifetime];\n+      const upgradeLevel = this.upgradeManager.getUpgradeLevel(UpgradeType.FuelLifetime);\n       cell.lifetime = getFuelLifetime(tier, upgradeLevel);\n     } else {\n       cell.lifetime = 0;\n     }\n \n-    this.state.stats.structuresBuilt++;\n+    this.stats.structuresBuilt++;\n \n     this.emitEvent({\n       type: 'structure_built',\n@@ -357,28 +338,25 @@ export class HeatGame {\n       tier,\n     });\n \n-    // Check for secret unlocks\n     this.checkSecretUnlocks();\n-\n     return true;\n   }\n \n   demolish(x: number, y: number): boolean {\n-    const cell = this.getCell(x, y);\n+    const cell = this.gridManager.getCell(x, y);\n     if (!cell || cell.structure === StructureType.Empty) return false;\n \n-    const oldStructure = this.state.grid[y][x].structure;\n-    const oldTier = this.state.grid[y][x].tier;\n+    const oldStructure = cell.structure;\n+    const oldTier = cell.tier;\n \n     // Refund if salvage is unlocked\n-    if (this.state.secrets.purchased[SecretUpgradeType.Salvage]) {\n+    if (this.upgradeManager.isSecretPurchased(SecretUpgradeType.Salvage)) {\n       const refund = Math.floor(getStructureCost(oldStructure, oldTier) * 0.5);\n-      this.state.money += refund;\n+      this.money += refund;\n     }\n \n-    // Reset cell\n-    this.state.grid[y][x] = this.createEmptyCell(x, y);\n-    this.state.stats.demolishCount++;\n+    this.gridManager.resetCell(x, y);\n+    this.stats.demolishCount++;\n \n     this.emitEvent({\n       type: 'structure_destroyed',\n@@ -388,558 +366,157 @@ export class HeatGame {\n       tier: oldTier,\n     });\n \n-    // Check for salvage unlock\n     this.checkSecretUnlocks();\n-\n     return true;\n   }\n \n   // ==========================================================================\n-  // UPGRADES\n+  // UPGRADES (delegate to UpgradeManager)\n   // ==========================================================================\n \n   getUpgradeCost(type: UpgradeType): number {\n-    const currentLevel = this.state.upgrades.levels[type];\n-    return getUpgradeCost(type, currentLevel);\n+    return this.upgradeManager.getUpgradeCost(type);\n   }\n \n   canPurchaseUpgrade(type: UpgradeType): boolean {\n-    const definition = UPGRADE_DEFINITIONS[type];\n-    const currentLevel = this.state.upgrades.levels[type];\n-\n-    // Check max level\n-    if (definition.maxLevel > 0 && currentLevel >= definition.maxLevel) {\n-      return false;\n-    }\n-\n-    const cost = getUpgradeCost(type, currentLevel);\n-    return this.state.money >= cost;\n+    return this.upgradeManager.canPurchaseUpgrade(type, this.money);\n   }\n \n   purchaseUpgrade(type: UpgradeType): boolean {\n-    if (!this.canPurchaseUpgrade(type)) return false;\n-\n-    const cost = getUpgradeCost(type, this.state.upgrades.levels[type]);\n-    this.state.money -= cost;\n-    this.state.upgrades.levels[type]++;\n-\n-    this.emitEvent({ type: 'upgrade_purchased', upgradeType: type });\n-    return true;\n+    const cost = this.upgradeManager.purchaseUpgrade(type, this.money);\n+    if (cost > 0) {\n+      this.money -= cost;\n+      return true;\n+    }\n+    return false;\n   }\n \n   // ==========================================================================\n-  // SECRET UPGRADES\n+  // SECRET UPGRADES (delegate to UpgradeManager)\n   // ==========================================================================\n \n   getSecretCost(type: SecretUpgradeType): number {\n-    return SECRET_UPGRADE_DEFINITIONS[type].cost;\n+    return this.upgradeManager.getSecretCost(type);\n   }\n \n   canPurchaseSecret(type: SecretUpgradeType): boolean {\n-    if (!this.state.secrets.unlocked[type]) return false;\n-    if (this.state.secrets.purchased[type]) return false;\n-\n-    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n-    return this.state.money >= cost;\n+    return this.upgradeManager.canPurchaseSecret(type, this.money);\n   }\n \n   purchaseSecret(type: SecretUpgradeType): boolean {\n-    if (!this.canPurchaseSecret(type)) return false;\n-\n-    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n-    this.state.money -= cost;\n-    this.state.secrets.purchased[type] = true;\n-\n-    // Auto-enable toggleable secrets\n-    if (SECRET_UPGRADE_DEFINITIONS[type].isToggle) {\n-      this.state.secrets.enabled[type] = true;\n-    }\n+    const cost = this.upgradeManager.purchaseSecret(type, this.money);\n+    if (cost > 0) {\n+      this.money -= cost;\n+\n+      // Handle reactor expansion\n+      const expansionSize = this.upgradeManager.getExpansionSize(type);\n+      if (expansionSize !== null) {\n+        this.expandGrid(expansionSize);\n+      }\n \n-    // Handle reactor expansion\n-    if (type === SecretUpgradeType.ReactorExpansion1) {\n-      this.expandGrid(17);\n-    } else if (type === SecretUpgradeType.ReactorExpansion2) {\n-      this.expandGrid(18);\n-    } else if (type === SecretUpgradeType.ReactorExpansion3) {\n-      this.expandGrid(19);\n-    } else if (type === SecretUpgradeType.ReactorExpansion4) {\n-      this.expandGrid(20);\n+      return true;\n     }\n-\n-    this.emitEvent({ type: 'secret_purchased', secretType: type });\n-    return true;\n+    return false;\n   }\n \n   toggleSecret(type: SecretUpgradeType, enabled: boolean): void {\n-    if (!this.state.secrets.purchased[type]) return;\n-    if (!SECRET_UPGRADE_DEFINITIONS[type].isToggle) return;\n-\n-    this.state.secrets.enabled[type] = enabled;\n+    this.upgradeManager.toggleSecret(type, enabled);\n   }\n \n   private expandGrid(newSize: number): void {\n-    if (newSize <= this.state.gridSize) return;\n-    if (newSize > CORE_SETTINGS.MAX_GRID_SIZE) return;\n-\n-    const oldGrid = this.state.grid;\n-    const oldSize = this.state.gridSize;\n-\n-    // Create new larger grid\n-    this.state.grid = this.createEmptyGrid(newSize);\n-    this.state.gridSize = newSize;\n-\n-    // Copy old grid data\n-    for (let y = 0; y < oldSize; y++) {\n-      for (let x = 0; x < oldSize; x++) {\n-        this.state.grid[y][x] = { ...oldGrid[y][x] };\n-      }\n+    if (this.gridManager.expandGrid(newSize, CORE_SETTINGS.MAX_GRID_SIZE)) {\n+      this.emitEvent({ type: 'grid_expanded', newGridSize: newSize });\n     }\n-\n-    this.emitEvent({ type: 'grid_expanded', newGridSize: newSize });\n   }\n \n   private checkSecretUnlocks(): void {\n     const stats = {\n-      meltdownCount: this.state.stats.meltdownCount,\n-      filledCells: this.getFilledCellCount(),\n-      totalMoneyEarned: this.state.stats.totalMoneyEarned,\n-      demolishCount: this.state.stats.demolishCount,\n-      ticksAtHighHeat: this.state.stats.ticksAtHighHeat,\n+      meltdownCount: this.stats.meltdownCount,\n+      filledCells: this.gridManager.getFilledCellCount(),\n+      totalMoneyEarned: this.stats.totalMoneyEarned,\n+      demolishCount: this.stats.demolishCount,\n+      ticksAtHighHeat: this.stats.ticksAtHighHeat,\n     };\n \n-    for (const type of Object.values(SecretUpgradeType)) {\n-      if (this.state.secrets.unlocked[type]) continue;\n-\n-      const progress = getSecretUnlockProgress(type, stats);\n-      if (progress.unlocked) {\n-        this.state.secrets.unlocked[type] = true;\n-        this.emitEvent({ type: 'secret_unlocked', secretType: type });\n-      }\n-    }\n-  }\n-\n-  // ==========================================================================\n-  // NEIGHBORS\n-  // ==========================================================================\n-\n-  private getNeighbors(x: number, y: number): Cell[] {\n-    const neighbors: Cell[] = [];\n-    const directions = [\n-      { dx: 0, dy: -1 }, // up\n-      { dx: 0, dy: 1 },  // down\n-      { dx: -1, dy: 0 }, // left\n-      { dx: 1, dy: 0 },  // right\n-    ];\n-\n-    for (const { dx, dy } of directions) {\n-      const nx = x + dx;\n-      const ny = y + dy;\n-      if (nx >= 0 && nx < this.state.gridSize && ny >= 0 && ny < this.state.gridSize) {\n-        neighbors.push(this.state.grid[ny][nx]);\n-      }\n-    }\n-\n-    return neighbors;\n-  }\n-\n-  private countAdjacentFuelRods(x: number, y: number): number {\n-    const neighbors = this.getNeighbors(x, y);\n-    return neighbors.filter(n => n.structure === StructureType.FuelRod && n.lifetime > 0).length;\n-  }\n-\n-  // ==========================================================================\n-  // EFFECTIVE STATS (with upgrades)\n-  // ==========================================================================\n-\n-  private getEffectiveMeltTemp(structure: StructureType): number {\n-    const baseTemp = STRUCTURE_BASE_STATS[structure].meltTemp;\n-\n-    // Get the appropriate melt temp upgrade\n-    let upgradeType: UpgradeType | null = null;\n-    switch (structure) {\n-      case StructureType.FuelRod: upgradeType = UpgradeType.MeltTempFuelRod; break;\n-      case StructureType.Ventilator: upgradeType = UpgradeType.MeltTempVentilator; break;\n-      case StructureType.HeatExchanger: upgradeType = UpgradeType.MeltTempHeatExchanger; break;\n-      case StructureType.Insulator: upgradeType = UpgradeType.MeltTempInsulator; break;\n-      case StructureType.Turbine: upgradeType = UpgradeType.MeltTempTurbine; break;\n-      case StructureType.Substation: upgradeType = UpgradeType.MeltTempSubstation; break;\n-    }\n-\n-    if (upgradeType) {\n-      const level = this.state.upgrades.levels[upgradeType];\n-      const definition = UPGRADE_DEFINITIONS[upgradeType];\n-      return baseTemp + (level * definition.improvementPerLevel);\n-    }\n-\n-    return baseTemp;\n-  }\n-\n-  private getEffectiveConductivity(cell: Cell): number {\n-    const baseConductivity = STRUCTURE_BASE_STATS[cell.structure].conductivity;\n-\n-    if (cell.structure === StructureType.Turbine) {\n-      const level = this.state.upgrades.levels[UpgradeType.TurbineConductivity];\n-      const definition = UPGRADE_DEFINITIONS[UpgradeType.TurbineConductivity];\n-      return baseConductivity + (level * definition.improvementPerLevel);\n-    }\n-\n-    if (cell.structure === StructureType.Insulator) {\n-      const level = this.state.upgrades.levels[UpgradeType.InsulatorConductivity];\n-      if (level > 0) {\n-        // Multiplicative reduction\n-        return baseConductivity * Math.pow(0.5, level);\n-      }\n-    }\n-\n-    return baseConductivity;\n-  }\n-\n-  private getEffectiveHeatDissipation(cell: Cell): number {\n-    if (cell.structure !== StructureType.Ventilator && cell.structure !== StructureType.VoidCell) {\n-      return 0;\n-    }\n-\n-    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n-    let dissipation = baseStats.heatDissipation;\n-\n-    // Scale with tier for ventilators\n-    if (cell.structure === StructureType.Ventilator) {\n-      dissipation *= Math.pow(10, cell.tier - 1);\n-\n-      // Add upgrade bonus\n-      const level = this.state.upgrades.levels[UpgradeType.VentilatorDissipation];\n-      const definition = UPGRADE_DEFINITIONS[UpgradeType.VentilatorDissipation];\n-      dissipation += level * definition.improvementPerLevel;\n-    }\n-\n-    return dissipation;\n-  }\n-\n-  private getEffectivePowerSaleRate(cell: Cell): number {\n-    if (cell.structure !== StructureType.Substation) return 0;\n-\n-    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n-    let saleRate = baseStats.powerSaleRate;\n-\n-    // Scale with tier\n-    saleRate *= Math.pow(10, cell.tier - 1);\n-\n-    // Add upgrade bonus\n-    const level = this.state.upgrades.levels[UpgradeType.SubstationSaleRate];\n-    const definition = UPGRADE_DEFINITIONS[UpgradeType.SubstationSaleRate];\n-    saleRate += level * definition.improvementPerLevel;\n-\n-    return saleRate;\n+    this.upgradeManager.checkSecretUnlocks(stats);\n   }\n \n   // ==========================================================================\n-  // GAME TICK\n+  // GAME TICK (delegate to PhysicsEngine)\n   // ==========================================================================\n \n   tick(): void {\n-    this.state.stats.tickCount++;\n+    this.stats.tickCount++;\n \n-    // Phase 1: Heat generation (fuel rods with adjacency bonus)\n-    this.processHeatGeneration();\n+    // Run physics simulation\n+    const result = this.physicsEngine.tick();\n \n-    // Phase 2: Fuel depletion\n-    this.processFuelDepletion();\n+    // Sync stats from physics engine (single source of truth for physics-related stats)\n+    const physicsStats = this.physicsEngine.getStats();\n+    this.stats.totalPowerGenerated = physicsStats.totalPowerGenerated;\n+    this.stats.ticksAtHighHeat = physicsStats.ticksAtHighHeat;\n+    this.stats.fuelRodsDepleted = physicsStats.fuelRodsDepleted;\n \n-    // Phase 3: Heat transfer between cells\n-    this.processHeatTransfer();\n+    // Add money earned from power sales\n+    this.money += result.moneyEarned;\n+    this.stats.totalMoneyEarned += result.moneyEarned;\n \n-    // Phase 4: Heat dissipation (ventilators)\n-    this.processHeatDissipation();\n-\n-    // Phase 5: Power generation (turbines)\n-    this.processPowerGeneration();\n-\n-    // Phase 6: Power collection and sale (substations)\n-    this.processPowerSale();\n-\n-    // Phase 7: Check for overheating and meltdowns\n-    this.processOverheating();\n-\n-    // Phase 8: Track high heat survival\n-    this.trackHighHeatSurvival();\n-\n-    // Phase 9: Check secret unlocks\n+    // Check secret unlocks\n     this.checkSecretUnlocks();\n   }\n \n-  private processHeatGeneration(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-\n-        if (cell.structure !== StructureType.FuelRod) continue;\n-        if (cell.lifetime <= 0) continue; // Depleted fuel generates no heat\n-\n-        // Get base heat generation for this tier\n-        const upgradeLevel = this.state.upgrades.levels[UpgradeType.FuelHeatOutput];\n-        let heatGeneration = getFuelHeatGeneration(cell.tier, upgradeLevel);\n-\n-        // Adjacency bonus (4-way orthogonal)\n-        const adjacentFuelRods = this.countAdjacentFuelRods(x, y);\n-        const adjacencyMultiplier = 1 + (adjacentFuelRods * FUEL_ADJACENCY.BONUS_PER_ADJACENT);\n-        heatGeneration *= adjacencyMultiplier;\n-\n-        // Exotic fuel: heat scales with current temperature\n-        if (cell.isExotic) {\n-          const tempMultiplier = Math.min(\n-            EXOTIC_FUEL.MAX_MULTIPLIER,\n-            EXOTIC_FUEL.BASE_MULTIPLIER + (cell.heat / 1000) * EXOTIC_FUEL.HEAT_SCALING\n-          );\n-          heatGeneration *= tempMultiplier;\n-        }\n-\n-        cell.heat += heatGeneration;\n-      }\n-    }\n-  }\n-\n-  private processFuelDepletion(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-\n-        if (cell.structure !== StructureType.FuelRod) continue;\n-        if (cell.lifetime <= 0) continue;\n-\n-        cell.lifetime--;\n-\n-        if (cell.lifetime <= 0) {\n-          this.state.stats.fuelRodsDepleted++;\n-          this.emitEvent({\n-            type: 'fuel_depleted',\n-            x,\n-            y,\n-            tier: cell.tier,\n-          });\n-        }\n-      }\n-    }\n-  }\n-\n-  private processHeatTransfer(): void {\n-    const heatDeltas: number[][] = [];\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      heatDeltas.push(new Array(this.state.gridSize).fill(0));\n-    }\n-\n-    const transferRate = CORE_SETTINGS.BASE_HEAT_TRANSFER_RATE;\n-\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        const cellConductivity = this.getEffectiveConductivity(cell);\n-        const neighbors = this.getNeighbors(x, y);\n-\n-        for (const neighbor of neighbors) {\n-          const neighborConductivity = this.getEffectiveConductivity(neighbor);\n-          const heatDiff = cell.heat - neighbor.heat;\n-\n-          // Heat flows from hot to cold\n-          if (heatDiff > 0) {\n-            const conductivity = Math.min(cellConductivity, neighborConductivity);\n-            const transfer = heatDiff * transferRate * conductivity;\n-            heatDeltas[y][x] -= transfer;\n-            heatDeltas[neighbor.y][neighbor.x] += transfer;\n-          }\n-        }\n-\n-        // Edge cells lose heat to environment\n-        const edgeCount = 4 - neighbors.length;\n-        if (edgeCount > 0 && cell.heat > CORE_SETTINGS.AMBIENT_TEMPERATURE) {\n-          const heatAboveAmbient = cell.heat - CORE_SETTINGS.AMBIENT_TEMPERATURE;\n-          const envTransfer = heatAboveAmbient * CORE_SETTINGS.ENVIRONMENT_HEAT_TRANSFER_RATE * edgeCount;\n-          heatDeltas[y][x] -= envTransfer;\n-        }\n-      }\n-    }\n-\n-    // Apply deltas\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        this.state.grid[y][x].heat = Math.max(0, this.state.grid[y][x].heat + heatDeltas[y][x]);\n-      }\n-    }\n-  }\n-\n-  private processHeatDissipation(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        const dissipation = this.getEffectiveHeatDissipation(cell);\n-        cell.heat = Math.max(0, cell.heat - dissipation);\n-      }\n-    }\n-  }\n-\n-  private processPowerGeneration(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        if (cell.structure !== StructureType.Turbine) continue;\n-        if (cell.heat <= 0) continue;\n-\n-        const baseStats = STRUCTURE_BASE_STATS[StructureType.Turbine];\n-        const maxHeatConsumption = baseStats.maxHeatConsumption * Math.pow(10, cell.tier - 1);\n-        const powerGeneration = baseStats.powerGeneration;\n-\n-        const heatConsumed = Math.min(cell.heat, maxHeatConsumption);\n-        const powerGenerated = heatConsumed * powerGeneration;\n-\n-        cell.heat -= heatConsumed;\n-        cell.power += powerGenerated;\n-        this.state.stats.totalPowerGenerated += powerGenerated;\n-      }\n-    }\n-  }\n-\n-  private processPowerSale(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-\n-        // Turbines transfer power to nearby substations\n-        if (cell.structure === StructureType.Turbine && cell.power > 0) {\n-          const neighbors = this.getNeighbors(x, y);\n-          for (const neighbor of neighbors) {\n-            if (neighbor.structure === StructureType.Substation) {\n-              this.state.grid[neighbor.y][neighbor.x].power += cell.power;\n-              cell.power = 0;\n-              break;\n-            }\n-          }\n-        }\n-\n-        // Substations sell power\n-        if (cell.structure === StructureType.Substation && cell.power > 0) {\n-          const saleRate = this.getEffectivePowerSaleRate(cell);\n-          const powerToSell = Math.min(cell.power, saleRate);\n-          const earnings = powerToSell * ECONOMY.MONEY_PER_POWER;\n-\n-          this.state.money += earnings;\n-          this.state.stats.totalMoneyEarned += earnings;\n-          cell.power -= powerToSell;\n-\n-          if (earnings > 0) {\n-            this.emitEvent({\n-              type: 'power_sold',\n-              x,\n-              y,\n-              amount: earnings,\n-            });\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  private processOverheating(): void {\n-    let meltdown = false;\n-    const meltedCells: { x: number; y: number; structure: StructureType; tier: Tier }[] = [];\n-\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        if (cell.structure === StructureType.Empty) continue;\n-\n-        const meltTemp = this.getEffectiveMeltTemp(cell.structure);\n-        if (cell.heat > meltTemp) {\n-          if (cell.structure === StructureType.FuelRod) {\n-            // Fuel rod meltdown - catastrophic failure\n-            meltdown = true;\n-          } else {\n-            // Regular structure melts\n-            meltedCells.push({ x, y, structure: cell.structure, tier: cell.tier });\n-          }\n-        }\n-      }\n-    }\n-\n-    // Melt non-fuel structures\n-    for (const { x, y, structure, tier } of meltedCells) {\n-      this.state.grid[y][x] = this.createEmptyCell(x, y);\n-      this.emitEvent({\n-        type: 'structure_melted',\n-        x,\n-        y,\n-        structure,\n-        tier,\n-      });\n-    }\n-\n-    if (meltdown) {\n-      this.triggerMeltdown();\n-    }\n-  }\n-\n-  private triggerMeltdown(): void {\n-    this.state.stats.meltdownCount++;\n-\n-    // Destroy all structures but keep money\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        this.state.grid[y][x] = this.createEmptyCell(x, y);\n-      }\n-    }\n-\n-    this.emitEvent({ type: 'meltdown' });\n-\n-    // Check for exotic fuel unlock\n-    this.checkSecretUnlocks();\n-  }\n-\n-  private trackHighHeatSurvival(): void {\n-    // Check if any fuel rod is at >90% of its melt temp\n-    let hasHighHeatFuelRod = false;\n-\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        if (cell.structure !== StructureType.FuelRod) continue;\n-\n-        const meltTemp = this.getEffectiveMeltTemp(StructureType.FuelRod);\n-        if (cell.heat >= meltTemp * 0.9) {\n-          hasHighHeatFuelRod = true;\n-          break;\n-        }\n-      }\n-      if (hasHighHeatFuelRod) break;\n-    }\n-\n-    if (hasHighHeatFuelRod) {\n-      this.state.stats.ticksAtHighHeat++;\n-    }\n-  }\n-\n   // ==========================================================================\n   // SERIALIZATION\n   // ==========================================================================\n \n   serialize(): string {\n-    return JSON.stringify(this.state);\n+    const state: GameState = {\n+      grid: this.gridManager.getSnapshot(),\n+      gridSize: this.gridManager.getSize(),\n+      money: this.money,\n+      stats: { ...this.stats },\n+      upgrades: this.upgradeManager.getUpgradeState(),\n+      secrets: this.upgradeManager.getSecretState(),\n+    };\n+    return JSON.stringify(state);\n   }\n \n   static deserialize(data: string): HeatGame {\n     const state = JSON.parse(data) as GameState;\n     const game = new HeatGame(0);\n-    game.state = state;\n+\n+    // Restore grid\n+    game.gridManager.restoreFromState(state.grid, state.gridSize);\n+\n+    // Restore money and stats\n+    game.money = state.money;\n+    game.stats = { ...state.stats };\n+\n+    // Restore upgrades\n+    game.upgradeManager.restoreUpgradeState(state.upgrades);\n+    game.upgradeManager.restoreSecretState(state.secrets);\n+\n+    // Sync physics engine stats\n+    game.physicsEngine.setStats({\n+      totalPowerGenerated: state.stats.totalPowerGenerated,\n+      totalMoneyEarned: state.stats.totalMoneyEarned,\n+      fuelRodsDepleted: state.stats.fuelRodsDepleted,\n+      ticksAtHighHeat: state.stats.ticksAtHighHeat,\n+    });\n+\n     return game;\n   }\n \n   // ==========================================================================\n-  // BACKWARD COMPATIBILITY (for tests)\n+  // BACKWARD COMPATIBILITY\n   // ==========================================================================\n \n   /** @deprecated Use getGridSize() instead */\n   get GRID_SIZE(): number {\n-    return this.state.gridSize;\n+    return this.gridManager.getSize();\n   }\n }\n \n-// Re-export GRID_SIZE for backward compatibility\n+// Re-export for backward compatibility\n export { CORE_SETTINGS };\n export const GRID_SIZE = CORE_SETTINGS.INITIAL_GRID_SIZE;\ndiff --git a/src/game/PhysicsEngine.test.ts b/src/game/PhysicsEngine.test.ts\nnew file mode 100644\nindex 0000000..f49b67b\n--- /dev/null\n+++ b/src/game/PhysicsEngine.test.ts\n@@ -0,0 +1,460 @@\n+/**\n+ * Unit tests for PhysicsEngine\n+ *\n+ * Tests heat generation, transfer, dissipation, and power generation in isolation.\n+ */\n+\n+import { describe, it, expect, beforeEach, vi } from 'vitest';\n+import { GridManager } from './GridManager.js';\n+import { PhysicsEngine, PhysicsEvent } from './PhysicsEngine.js';\n+import { StructureType, Tier, UpgradeType, STRUCTURE_BASE_STATS, getFuelLifetime } from './BalanceConfig.js';\n+\n+describe('PhysicsEngine', () => {\n+  let gridManager: GridManager;\n+  let physicsEngine: PhysicsEngine;\n+  let upgradeLevels: Map<UpgradeType, number>;\n+\n+  const getUpgradeLevel = (type: UpgradeType) => upgradeLevels.get(type) ?? 0;\n+\n+  beforeEach(() => {\n+    gridManager = new GridManager(16);\n+    upgradeLevels = new Map();\n+    physicsEngine = new PhysicsEngine(gridManager, getUpgradeLevel);\n+  });\n+\n+  describe('heat generation', () => {\n+    it('should generate heat from active fuel rods', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.tier = Tier.T1;\n+      cell.lifetime = 100;\n+\n+      physicsEngine.processHeatGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeGreaterThan(0);\n+    });\n+\n+    it('should not generate heat from depleted fuel rods', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.tier = Tier.T1;\n+      cell.lifetime = 0; // depleted\n+\n+      physicsEngine.processHeatGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBe(0);\n+    });\n+\n+    it('should apply adjacency bonus for neighboring fuel rods', () => {\n+      // Place center fuel rod\n+      const center = gridManager.getCellRef(5, 5)!;\n+      center.structure = StructureType.FuelRod;\n+      center.tier = Tier.T1;\n+      center.lifetime = 100;\n+\n+      // Get baseline heat generation\n+      physicsEngine.processHeatGeneration();\n+      const baseHeat = gridManager.getCell(5, 5)!.heat;\n+\n+      // Reset and add adjacent fuel rod\n+      gridManager.getCellRef(5, 5)!.heat = 0;\n+      const adjacent = gridManager.getCellRef(5, 4)!;\n+      adjacent.structure = StructureType.FuelRod;\n+      adjacent.tier = Tier.T1;\n+      adjacent.lifetime = 100;\n+\n+      physicsEngine.processHeatGeneration();\n+      const boostedHeat = gridManager.getCell(5, 5)!.heat;\n+\n+      expect(boostedHeat).toBeGreaterThan(baseHeat);\n+    });\n+\n+    it('should generate more heat for higher tiers', () => {\n+      const cell1 = gridManager.getCellRef(3, 3)!;\n+      cell1.structure = StructureType.FuelRod;\n+      cell1.tier = Tier.T1;\n+      cell1.lifetime = 100;\n+\n+      const cell2 = gridManager.getCellRef(8, 8)!;\n+      cell2.structure = StructureType.FuelRod;\n+      cell2.tier = Tier.T2;\n+      cell2.lifetime = 100;\n+\n+      physicsEngine.processHeatGeneration();\n+\n+      expect(gridManager.getCell(8, 8)!.heat).toBeGreaterThan(gridManager.getCell(3, 3)!.heat);\n+    });\n+  });\n+\n+  describe('fuel depletion', () => {\n+    it('should decrease fuel lifetime each tick', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 100;\n+\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(gridManager.getCell(5, 5)!.lifetime).toBe(99);\n+    });\n+\n+    it('should emit event when fuel is depleted', () => {\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(events).toHaveLength(1);\n+      expect(events[0].type).toBe('fuel_depleted');\n+      expect(events[0].x).toBe(5);\n+      expect(events[0].y).toBe(5);\n+    });\n+\n+    it('should track depleted fuel rods in stats', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(physicsEngine.getStats().fuelRodsDepleted).toBe(1);\n+    });\n+  });\n+\n+  describe('heat transfer', () => {\n+    it('should transfer heat from hot to cold cells', () => {\n+      const hotCell = gridManager.getCellRef(5, 5)!;\n+      hotCell.heat = 1000;\n+\n+      const coldCell = gridManager.getCellRef(5, 6)!;\n+      coldCell.heat = 0;\n+\n+      physicsEngine.processHeatTransfer();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeLessThan(1000);\n+      expect(gridManager.getCell(5, 6)!.heat).toBeGreaterThan(0);\n+    });\n+\n+    it('should respect conductivity differences', () => {\n+      // Place insulator (low conductivity) and regular cell\n+      const insulator = gridManager.getCellRef(5, 5)!;\n+      insulator.structure = StructureType.Insulator;\n+      insulator.heat = 1000;\n+\n+      physicsEngine.processHeatTransfer();\n+      const insulatorHeatAfter = gridManager.getCell(5, 5)!.heat;\n+\n+      // Compare with empty cell\n+      gridManager.getCellRef(5, 5)!.structure = StructureType.Empty;\n+      gridManager.getCellRef(5, 5)!.heat = 1000;\n+\n+      physicsEngine.processHeatTransfer();\n+      const emptyHeatAfter = gridManager.getCell(5, 5)!.heat;\n+\n+      // Insulator should retain more heat due to low conductivity\n+      expect(insulatorHeatAfter).toBeGreaterThan(emptyHeatAfter);\n+    });\n+\n+    it('should lose heat to environment at edges', () => {\n+      // Place heat at corner (2 edges exposed)\n+      const corner = gridManager.getCellRef(0, 0)!;\n+      corner.heat = 1000;\n+\n+      physicsEngine.processHeatTransfer();\n+\n+      expect(gridManager.getCell(0, 0)!.heat).toBeLessThan(1000);\n+    });\n+  });\n+\n+  describe('heat dissipation', () => {\n+    it('should dissipate heat from ventilators', () => {\n+      const vent = gridManager.getCellRef(5, 5)!;\n+      vent.structure = StructureType.Ventilator;\n+      vent.tier = Tier.T1;\n+      vent.heat = 100;\n+\n+      physicsEngine.processHeatDissipation();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeLessThan(100);\n+    });\n+\n+    it('should not go below zero heat', () => {\n+      const vent = gridManager.getCellRef(5, 5)!;\n+      vent.structure = StructureType.Ventilator;\n+      vent.tier = Tier.T1;\n+      vent.heat = 1; // Very low heat\n+\n+      physicsEngine.processHeatDissipation();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeGreaterThanOrEqual(0);\n+    });\n+\n+    it('should dissipate more heat for higher tier ventilators', () => {\n+      const vent1 = gridManager.getCellRef(3, 3)!;\n+      vent1.structure = StructureType.Ventilator;\n+      vent1.tier = Tier.T1;\n+      vent1.heat = 500;\n+\n+      const vent2 = gridManager.getCellRef(8, 8)!;\n+      vent2.structure = StructureType.Ventilator;\n+      vent2.tier = Tier.T2;\n+      vent2.heat = 500;\n+\n+      physicsEngine.processHeatDissipation();\n+\n+      // T2 should dissipate more, leaving less heat\n+      expect(gridManager.getCell(8, 8)!.heat).toBeLessThan(gridManager.getCell(3, 3)!.heat);\n+    });\n+  });\n+\n+  describe('power generation', () => {\n+    it('should generate power from turbines with heat', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = 100;\n+\n+      physicsEngine.processPowerGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.power).toBeGreaterThan(0);\n+      expect(gridManager.getCell(5, 5)!.heat).toBeLessThan(100);\n+    });\n+\n+    it('should not generate power without heat', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = 0;\n+\n+      physicsEngine.processPowerGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.power).toBe(0);\n+    });\n+\n+    it('should track total power generated in stats', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = 100;\n+\n+      physicsEngine.processPowerGeneration();\n+\n+      expect(physicsEngine.getStats().totalPowerGenerated).toBeGreaterThan(0);\n+    });\n+  });\n+\n+  describe('power sale', () => {\n+    it('should transfer power from turbine to adjacent substation', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.power = 100;\n+\n+      const substation = gridManager.getCellRef(5, 6)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+\n+      physicsEngine.processPowerSale();\n+\n+      // Turbine should have transferred power\n+      expect(gridManager.getCell(5, 5)!.power).toBe(0);\n+      // Substation receives power but also sells some (saleRate applies)\n+      // Just verify it received the power (it may sell some immediately)\n+      expect(physicsEngine.getStats().totalMoneyEarned).toBeGreaterThan(0);\n+    });\n+\n+    it('should sell power from substations and return earnings', () => {\n+      const substation = gridManager.getCellRef(5, 5)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+      substation.power = 100;\n+\n+      const earnings = physicsEngine.processPowerSale();\n+\n+      expect(earnings).toBeGreaterThan(0);\n+      expect(gridManager.getCell(5, 5)!.power).toBeLessThan(100);\n+    });\n+\n+    it('should emit power_sold event', () => {\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      const substation = gridManager.getCellRef(5, 5)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+      substation.power = 100;\n+\n+      physicsEngine.processPowerSale();\n+\n+      expect(events.some(e => e.type === 'power_sold')).toBe(true);\n+    });\n+  });\n+\n+  describe('overheating', () => {\n+    it('should melt structures that exceed melt temperature', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = STRUCTURE_BASE_STATS[StructureType.Turbine].meltTemp + 100;\n+\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      physicsEngine.processOverheating();\n+\n+      expect(gridManager.getCell(5, 5)!.structure).toBe(StructureType.Empty);\n+      expect(events.some(e => e.type === 'structure_melted')).toBe(true);\n+    });\n+\n+    it('should trigger meltdown when fuel rod overheats', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp + 100;\n+\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      const meltdown = physicsEngine.processOverheating();\n+\n+      expect(meltdown).toBe(true);\n+      expect(events.some(e => e.type === 'meltdown')).toBe(true);\n+    });\n+\n+    it('should clear entire grid on meltdown', () => {\n+      // Place some structures\n+      gridManager.getCellRef(3, 3)!.structure = StructureType.Turbine;\n+      gridManager.getCellRef(8, 8)!.structure = StructureType.Ventilator;\n+\n+      // Trigger meltdown\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp + 100;\n+\n+      physicsEngine.processOverheating();\n+\n+      expect(gridManager.getFilledCellCount()).toBe(0);\n+    });\n+  });\n+\n+  describe('high heat tracking', () => {\n+    it('should track ticks at high heat', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      // Set heat to 90% of melt temp\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp * 0.91;\n+\n+      physicsEngine.trackHighHeatSurvival();\n+\n+      expect(physicsEngine.getStats().ticksAtHighHeat).toBe(1);\n+    });\n+\n+    it('should not track when below 90% melt temp', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp * 0.5;\n+\n+      physicsEngine.trackHighHeatSurvival();\n+\n+      expect(physicsEngine.getStats().ticksAtHighHeat).toBe(0);\n+    });\n+  });\n+\n+  describe('effective stats with upgrades', () => {\n+    it('should increase melt temp with upgrades', () => {\n+      const baseMeltTemp = physicsEngine.getEffectiveMeltTemp(StructureType.FuelRod);\n+\n+      upgradeLevels.set(UpgradeType.MeltTempFuelRod, 3);\n+      const upgradedMeltTemp = physicsEngine.getEffectiveMeltTemp(StructureType.FuelRod);\n+\n+      expect(upgradedMeltTemp).toBeGreaterThan(baseMeltTemp);\n+    });\n+\n+    it('should increase turbine conductivity with upgrades', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+\n+      const baseConductivity = physicsEngine.getEffectiveConductivity(turbine);\n+\n+      upgradeLevels.set(UpgradeType.TurbineConductivity, 2);\n+      const upgradedConductivity = physicsEngine.getEffectiveConductivity(turbine);\n+\n+      expect(upgradedConductivity).toBeGreaterThan(baseConductivity);\n+    });\n+\n+    it('should decrease insulator conductivity with upgrades', () => {\n+      const insulator = gridManager.getCellRef(5, 5)!;\n+      insulator.structure = StructureType.Insulator;\n+\n+      const baseConductivity = physicsEngine.getEffectiveConductivity(insulator);\n+\n+      upgradeLevels.set(UpgradeType.InsulatorConductivity, 2);\n+      const upgradedConductivity = physicsEngine.getEffectiveConductivity(insulator);\n+\n+      expect(upgradedConductivity).toBeLessThan(baseConductivity);\n+    });\n+  });\n+\n+  describe('tick', () => {\n+    it('should run all physics phases', () => {\n+      // Set up a simple reactor\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      fuelRod.lifetime = 100;\n+\n+      const turbine = gridManager.getCellRef(5, 6)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+\n+      const substation = gridManager.getCellRef(5, 7)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+\n+      const result = physicsEngine.tick();\n+\n+      expect(result.moneyEarned).toBeGreaterThanOrEqual(0);\n+      expect(result.meltdown).toBe(false);\n+    });\n+\n+    it('should report meltdown in tick result', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.lifetime = 100; // Active fuel rod\n+      // Set very high heat to ensure it still exceeds meltTemp after heat transfer/dissipation\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp * 2;\n+\n+      const result = physicsEngine.tick();\n+\n+      expect(result.meltdown).toBe(true);\n+    });\n+  });\n+\n+  describe('event listeners', () => {\n+    it('should allow adding and removing listeners', () => {\n+      const events: PhysicsEvent[] = [];\n+      const listener = (e: PhysicsEvent) => events.push(e);\n+\n+      physicsEngine.addEventListener(listener);\n+\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+\n+      physicsEngine.processFuelDepletion();\n+      expect(events).toHaveLength(1);\n+\n+      physicsEngine.removeEventListener(listener);\n+\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(events).toHaveLength(1); // No new events\n+    });\n+  });\n+});\ndiff --git a/src/game/PhysicsEngine.ts b/src/game/PhysicsEngine.ts\nnew file mode 100644\nindex 0000000..ef4c504\n--- /dev/null\n+++ b/src/game/PhysicsEngine.ts\n@@ -0,0 +1,483 @@\n+/**\n+ * PhysicsEngine - Handles heat generation, transfer, dissipation, and power generation\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ * This class is responsible for all physics simulation logic.\n+ */\n+\n+import {\n+  CORE_SETTINGS,\n+  StructureType,\n+  Tier,\n+  STRUCTURE_BASE_STATS,\n+  FUEL_ADJACENCY,\n+  ECONOMY,\n+  UpgradeType,\n+  UPGRADE_DEFINITIONS,\n+  EXOTIC_FUEL,\n+  getFuelHeatGeneration,\n+} from './BalanceConfig.js';\n+import { Cell, GridManager } from './GridManager.js';\n+\n+export interface PhysicsEvent {\n+  type: 'fuel_depleted' | 'power_sold' | 'structure_melted' | 'meltdown';\n+  x?: number;\n+  y?: number;\n+  tier?: Tier;\n+  structure?: StructureType;\n+  amount?: number;\n+}\n+\n+export type PhysicsEventListener = (event: PhysicsEvent) => void;\n+\n+export interface UpgradeLevels {\n+  [key: string]: number;\n+}\n+\n+export interface PhysicsStats {\n+  totalPowerGenerated: number;\n+  totalMoneyEarned: number;\n+  fuelRodsDepleted: number;\n+  ticksAtHighHeat: number;\n+}\n+\n+/**\n+ * PhysicsEngine handles all physics simulation for the heat game.\n+ * It operates on a GridManager and uses upgrade levels for calculations.\n+ */\n+export class PhysicsEngine {\n+  private eventListeners: PhysicsEventListener[] = [];\n+  private stats: PhysicsStats = {\n+    totalPowerGenerated: 0,\n+    totalMoneyEarned: 0,\n+    fuelRodsDepleted: 0,\n+    ticksAtHighHeat: 0,\n+  };\n+\n+  constructor(\n+    private gridManager: GridManager,\n+    private getUpgradeLevel: (type: UpgradeType) => number\n+  ) {}\n+\n+  /**\n+   * Add an event listener for physics events\n+   */\n+  addEventListener(listener: PhysicsEventListener): void {\n+    this.eventListeners.push(listener);\n+  }\n+\n+  /**\n+   * Remove an event listener\n+   */\n+  removeEventListener(listener: PhysicsEventListener): void {\n+    const index = this.eventListeners.indexOf(listener);\n+    if (index !== -1) {\n+      this.eventListeners.splice(index, 1);\n+    }\n+  }\n+\n+  private emitEvent(event: PhysicsEvent): void {\n+    for (const listener of this.eventListeners) {\n+      listener(event);\n+    }\n+  }\n+\n+  /**\n+   * Get the current physics stats\n+   */\n+  getStats(): PhysicsStats {\n+    return { ...this.stats };\n+  }\n+\n+  /**\n+   * Reset stats (used after deserialization)\n+   */\n+  setStats(stats: PhysicsStats): void {\n+    this.stats = { ...stats };\n+  }\n+\n+  /**\n+   * Get effective melt temperature for a structure type (with upgrades)\n+   */\n+  getEffectiveMeltTemp(structure: StructureType): number {\n+    const baseTemp = STRUCTURE_BASE_STATS[structure].meltTemp;\n+\n+    let upgradeType: UpgradeType | null = null;\n+    switch (structure) {\n+      case StructureType.FuelRod: upgradeType = UpgradeType.MeltTempFuelRod; break;\n+      case StructureType.Ventilator: upgradeType = UpgradeType.MeltTempVentilator; break;\n+      case StructureType.HeatExchanger: upgradeType = UpgradeType.MeltTempHeatExchanger; break;\n+      case StructureType.Insulator: upgradeType = UpgradeType.MeltTempInsulator; break;\n+      case StructureType.Turbine: upgradeType = UpgradeType.MeltTempTurbine; break;\n+      case StructureType.Substation: upgradeType = UpgradeType.MeltTempSubstation; break;\n+    }\n+\n+    if (upgradeType) {\n+      const level = this.getUpgradeLevel(upgradeType);\n+      const definition = UPGRADE_DEFINITIONS[upgradeType];\n+      return baseTemp + (level * definition.improvementPerLevel);\n+    }\n+\n+    return baseTemp;\n+  }\n+\n+  /**\n+   * Get effective conductivity for a cell (with upgrades)\n+   */\n+  getEffectiveConductivity(cell: Cell): number {\n+    const baseConductivity = STRUCTURE_BASE_STATS[cell.structure].conductivity;\n+\n+    if (cell.structure === StructureType.Turbine) {\n+      const level = this.getUpgradeLevel(UpgradeType.TurbineConductivity);\n+      const definition = UPGRADE_DEFINITIONS[UpgradeType.TurbineConductivity];\n+      return baseConductivity + (level * definition.improvementPerLevel);\n+    }\n+\n+    if (cell.structure === StructureType.Insulator) {\n+      const level = this.getUpgradeLevel(UpgradeType.InsulatorConductivity);\n+      if (level > 0) {\n+        return baseConductivity * Math.pow(0.5, level);\n+      }\n+    }\n+\n+    return baseConductivity;\n+  }\n+\n+  /**\n+   * Get effective heat dissipation for a cell (with upgrades)\n+   */\n+  getEffectiveHeatDissipation(cell: Cell): number {\n+    if (cell.structure !== StructureType.Ventilator && cell.structure !== StructureType.VoidCell) {\n+      return 0;\n+    }\n+\n+    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n+    let dissipation = baseStats.heatDissipation;\n+\n+    if (cell.structure === StructureType.Ventilator) {\n+      dissipation *= Math.pow(10, cell.tier - 1);\n+\n+      const level = this.getUpgradeLevel(UpgradeType.VentilatorDissipation);\n+      const definition = UPGRADE_DEFINITIONS[UpgradeType.VentilatorDissipation];\n+      dissipation += level * definition.improvementPerLevel;\n+    }\n+\n+    return dissipation;\n+  }\n+\n+  /**\n+   * Get effective power sale rate for a cell (with upgrades)\n+   */\n+  getEffectivePowerSaleRate(cell: Cell): number {\n+    if (cell.structure !== StructureType.Substation) return 0;\n+\n+    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n+    let saleRate = baseStats.powerSaleRate;\n+\n+    saleRate *= Math.pow(10, cell.tier - 1);\n+\n+    const level = this.getUpgradeLevel(UpgradeType.SubstationSaleRate);\n+    const definition = UPGRADE_DEFINITIONS[UpgradeType.SubstationSaleRate];\n+    saleRate += level * definition.improvementPerLevel;\n+\n+    return saleRate;\n+  }\n+\n+  /**\n+   * Process heat generation from fuel rods\n+   */\n+  processHeatGeneration(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+        if (cell.lifetime <= 0) continue;\n+\n+        const upgradeLevel = this.getUpgradeLevel(UpgradeType.FuelHeatOutput);\n+        let heatGeneration = getFuelHeatGeneration(cell.tier, upgradeLevel);\n+\n+        // Adjacency bonus\n+        const adjacentFuelRods = this.gridManager.countAdjacentFuelRods(x, y);\n+        const adjacencyMultiplier = 1 + (adjacentFuelRods * FUEL_ADJACENCY.BONUS_PER_ADJACENT);\n+        heatGeneration *= adjacencyMultiplier;\n+\n+        // Exotic fuel scaling\n+        if (cell.isExotic) {\n+          const tempMultiplier = Math.min(\n+            EXOTIC_FUEL.MAX_MULTIPLIER,\n+            EXOTIC_FUEL.BASE_MULTIPLIER + (cell.heat / 1000) * EXOTIC_FUEL.HEAT_SCALING\n+          );\n+          heatGeneration *= tempMultiplier;\n+        }\n+\n+        cell.heat += heatGeneration;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process fuel depletion\n+   */\n+  processFuelDepletion(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+        if (cell.lifetime <= 0) continue;\n+\n+        cell.lifetime--;\n+\n+        if (cell.lifetime <= 0) {\n+          this.stats.fuelRodsDepleted++;\n+          this.emitEvent({\n+            type: 'fuel_depleted',\n+            x,\n+            y,\n+            tier: cell.tier,\n+          });\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process heat transfer between cells\n+   */\n+  processHeatTransfer(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    const heatDeltas: number[][] = [];\n+    for (let y = 0; y < gridSize; y++) {\n+      heatDeltas.push(new Array(gridSize).fill(0));\n+    }\n+\n+    const transferRate = CORE_SETTINGS.BASE_HEAT_TRANSFER_RATE;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        const cellConductivity = this.getEffectiveConductivity(cell);\n+        const neighbors = this.gridManager.getNeighbors(x, y);\n+\n+        for (const neighbor of neighbors) {\n+          const neighborConductivity = this.getEffectiveConductivity(neighbor);\n+          const heatDiff = cell.heat - neighbor.heat;\n+\n+          if (heatDiff > 0) {\n+            const conductivity = Math.min(cellConductivity, neighborConductivity);\n+            const transfer = heatDiff * transferRate * conductivity;\n+            heatDeltas[y][x] -= transfer;\n+            heatDeltas[neighbor.y][neighbor.x] += transfer;\n+          }\n+        }\n+\n+        // Edge cells lose heat to environment\n+        const edgeCount = 4 - neighbors.length;\n+        if (edgeCount > 0 && cell.heat > CORE_SETTINGS.AMBIENT_TEMPERATURE) {\n+          const heatAboveAmbient = cell.heat - CORE_SETTINGS.AMBIENT_TEMPERATURE;\n+          const envTransfer = heatAboveAmbient * CORE_SETTINGS.ENVIRONMENT_HEAT_TRANSFER_RATE * edgeCount;\n+          heatDeltas[y][x] -= envTransfer;\n+        }\n+      }\n+    }\n+\n+    // Apply deltas\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        grid[y][x].heat = Math.max(0, grid[y][x].heat + heatDeltas[y][x]);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process heat dissipation (ventilators and void cells)\n+   */\n+  processHeatDissipation(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        const dissipation = this.getEffectiveHeatDissipation(cell);\n+        cell.heat = Math.max(0, cell.heat - dissipation);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process power generation (turbines)\n+   */\n+  processPowerGeneration(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure !== StructureType.Turbine) continue;\n+        if (cell.heat <= 0) continue;\n+\n+        const baseStats = STRUCTURE_BASE_STATS[StructureType.Turbine];\n+        const maxHeatConsumption = baseStats.maxHeatConsumption * Math.pow(10, cell.tier - 1);\n+        const powerGeneration = baseStats.powerGeneration;\n+\n+        const heatConsumed = Math.min(cell.heat, maxHeatConsumption);\n+        const powerGenerated = heatConsumed * powerGeneration;\n+\n+        cell.heat -= heatConsumed;\n+        cell.power += powerGenerated;\n+        this.stats.totalPowerGenerated += powerGenerated;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process power sale (substations)\n+   * Returns the amount of money earned\n+   */\n+  processPowerSale(): number {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let totalEarnings = 0;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        // Turbines transfer power to nearby substations\n+        if (cell.structure === StructureType.Turbine && cell.power > 0) {\n+          const neighbors = this.gridManager.getNeighbors(x, y);\n+          for (const neighbor of neighbors) {\n+            if (neighbor.structure === StructureType.Substation) {\n+              grid[neighbor.y][neighbor.x].power += cell.power;\n+              cell.power = 0;\n+              break;\n+            }\n+          }\n+        }\n+\n+        // Substations sell power\n+        if (cell.structure === StructureType.Substation && cell.power > 0) {\n+          const saleRate = this.getEffectivePowerSaleRate(cell);\n+          const powerToSell = Math.min(cell.power, saleRate);\n+          const earnings = powerToSell * ECONOMY.MONEY_PER_POWER;\n+\n+          totalEarnings += earnings;\n+          this.stats.totalMoneyEarned += earnings;\n+          cell.power -= powerToSell;\n+\n+          if (earnings > 0) {\n+            this.emitEvent({\n+              type: 'power_sold',\n+              x,\n+              y,\n+              amount: earnings,\n+            });\n+          }\n+        }\n+      }\n+    }\n+\n+    return totalEarnings;\n+  }\n+\n+  /**\n+   * Process overheating and meltdowns\n+   * Returns true if a meltdown occurred\n+   */\n+  processOverheating(): boolean {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let meltdown = false;\n+    const meltedCells: { x: number; y: number; structure: StructureType; tier: Tier }[] = [];\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure === StructureType.Empty) continue;\n+\n+        const meltTemp = this.getEffectiveMeltTemp(cell.structure);\n+        if (cell.heat > meltTemp) {\n+          if (cell.structure === StructureType.FuelRod) {\n+            meltdown = true;\n+          } else {\n+            meltedCells.push({ x, y, structure: cell.structure, tier: cell.tier });\n+          }\n+        }\n+      }\n+    }\n+\n+    // Melt non-fuel structures\n+    for (const { x, y, structure, tier } of meltedCells) {\n+      this.gridManager.resetCell(x, y);\n+      this.emitEvent({\n+        type: 'structure_melted',\n+        x,\n+        y,\n+        structure,\n+        tier,\n+      });\n+    }\n+\n+    if (meltdown) {\n+      this.gridManager.clearAll();\n+      this.emitEvent({ type: 'meltdown' });\n+    }\n+\n+    return meltdown;\n+  }\n+\n+  /**\n+   * Track high heat survival (for secret unlock)\n+   */\n+  trackHighHeatSurvival(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let hasHighHeatFuelRod = false;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+\n+        const meltTemp = this.getEffectiveMeltTemp(StructureType.FuelRod);\n+        if (cell.heat >= meltTemp * 0.9) {\n+          hasHighHeatFuelRod = true;\n+          break;\n+        }\n+      }\n+      if (hasHighHeatFuelRod) break;\n+    }\n+\n+    if (hasHighHeatFuelRod) {\n+      this.stats.ticksAtHighHeat++;\n+    }\n+  }\n+\n+  /**\n+   * Run a complete physics tick\n+   * Returns the money earned from power sales\n+   */\n+  tick(): { moneyEarned: number; meltdown: boolean } {\n+    this.processHeatGeneration();\n+    this.processFuelDepletion();\n+    this.processHeatTransfer();\n+    this.processHeatDissipation();\n+    this.processPowerGeneration();\n+    const moneyEarned = this.processPowerSale();\n+    const meltdown = this.processOverheating();\n+    this.trackHighHeatSurvival();\n+\n+    return { moneyEarned, meltdown };\n+  }\n+}\ndiff --git a/src/game/UpgradeManager.test.ts b/src/game/UpgradeManager.test.ts\nnew file mode 100644\nindex 0000000..a6d3f1a\n--- /dev/null\n+++ b/src/game/UpgradeManager.test.ts\n@@ -0,0 +1,318 @@\n+/**\n+ * Unit tests for UpgradeManager\n+ *\n+ * Tests upgrade purchasing, secret unlocking, and toggle states in isolation.\n+ */\n+\n+import { describe, it, expect, beforeEach } from 'vitest';\n+import { UpgradeManager, UpgradeEvent } from './UpgradeManager.js';\n+import { UpgradeType, SecretUpgradeType, UPGRADE_DEFINITIONS, SECRET_UPGRADE_DEFINITIONS } from './BalanceConfig.js';\n+\n+describe('UpgradeManager', () => {\n+  let upgradeManager: UpgradeManager;\n+\n+  beforeEach(() => {\n+    upgradeManager = new UpgradeManager();\n+  });\n+\n+  describe('initialization', () => {\n+    it('should start with all upgrades at level 0', () => {\n+      for (const type of Object.values(UpgradeType)) {\n+        expect(upgradeManager.getUpgradeLevel(type)).toBe(0);\n+      }\n+    });\n+\n+    it('should start with all secrets locked', () => {\n+      for (const type of Object.values(SecretUpgradeType)) {\n+        expect(upgradeManager.isSecretUnlocked(type)).toBe(false);\n+        expect(upgradeManager.isSecretPurchased(type)).toBe(false);\n+        expect(upgradeManager.isSecretEnabled(type)).toBe(false);\n+      }\n+    });\n+  });\n+\n+  describe('regular upgrades', () => {\n+    it('should return correct upgrade cost', () => {\n+      const cost = upgradeManager.getUpgradeCost(UpgradeType.FuelHeatOutput);\n+      expect(cost).toBeGreaterThan(0);\n+    });\n+\n+    it('should allow purchasing upgrades with enough money', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+      const cost = upgradeManager.getUpgradeCost(type);\n+\n+      expect(upgradeManager.canPurchaseUpgrade(type, cost)).toBe(true);\n+      expect(upgradeManager.canPurchaseUpgrade(type, cost - 1)).toBe(false);\n+    });\n+\n+    it('should increase level on purchase', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+      const cost = upgradeManager.getUpgradeCost(type);\n+\n+      const spent = upgradeManager.purchaseUpgrade(type, cost);\n+\n+      expect(spent).toBe(cost);\n+      expect(upgradeManager.getUpgradeLevel(type)).toBe(1);\n+    });\n+\n+    it('should return 0 if purchase fails', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+\n+      const spent = upgradeManager.purchaseUpgrade(type, 0);\n+\n+      expect(spent).toBe(0);\n+      expect(upgradeManager.getUpgradeLevel(type)).toBe(0);\n+    });\n+\n+    it('should increase cost after each purchase', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+      const initialCost = upgradeManager.getUpgradeCost(type);\n+\n+      upgradeManager.purchaseUpgrade(type, 1000000);\n+\n+      const newCost = upgradeManager.getUpgradeCost(type);\n+      expect(newCost).toBeGreaterThan(initialCost);\n+    });\n+\n+    it('should respect max level', () => {\n+      // TurbineConductivity has maxLevel: 10\n+      const type = UpgradeType.TurbineConductivity;\n+      const maxLevel = UPGRADE_DEFINITIONS[type].maxLevel;\n+\n+      // Purchase up to max level\n+      for (let i = 0; i < maxLevel; i++) {\n+        upgradeManager.purchaseUpgrade(type, 1000000000);\n+      }\n+\n+      expect(upgradeManager.getUpgradeLevel(type)).toBe(maxLevel);\n+      expect(upgradeManager.canPurchaseUpgrade(type, 1000000000)).toBe(false);\n+    });\n+\n+    it('should emit event on purchase', () => {\n+      const events: UpgradeEvent[] = [];\n+      upgradeManager.addEventListener(e => events.push(e));\n+\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+\n+      expect(events).toHaveLength(1);\n+      expect(events[0].type).toBe('upgrade_purchased');\n+      expect(events[0].upgradeType).toBe(UpgradeType.FuelHeatOutput);\n+    });\n+  });\n+\n+  describe('secret upgrades', () => {\n+    it('should return correct secret cost', () => {\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.Salvage);\n+      expect(cost).toBe(SECRET_UPGRADE_DEFINITIONS[SecretUpgradeType.Salvage].cost);\n+    });\n+\n+    it('should not allow purchasing locked secrets', () => {\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.Salvage, 1000000)).toBe(false);\n+    });\n+\n+    it('should not allow purchasing already purchased secrets', () => {\n+      // ExoticFuel requires 1 meltdown to unlock\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.ExoticFuel);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, cost);\n+\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.ExoticFuel, 1000000)).toBe(false);\n+    });\n+\n+    it('should unlock secrets based on stats', () => {\n+      // ExoticFuel requires 1 meltdown\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+\n+      const unlocked = upgradeManager.checkSecretUnlocks(stats);\n+\n+      expect(unlocked).toContain(SecretUpgradeType.ExoticFuel);\n+      expect(upgradeManager.isSecretUnlocked(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should emit event on secret unlock', () => {\n+      const events: UpgradeEvent[] = [];\n+      upgradeManager.addEventListener(e => events.push(e));\n+\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      expect(events.some(e => e.type === 'secret_unlocked')).toBe(true);\n+    });\n+\n+    it('should allow purchasing unlocked secrets with enough money', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.ExoticFuel);\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.ExoticFuel, cost)).toBe(true);\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.ExoticFuel, cost - 1)).toBe(false);\n+    });\n+\n+    it('should mark secret as purchased after buying', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.ExoticFuel);\n+      const spent = upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, cost);\n+\n+      expect(spent).toBe(cost);\n+      expect(upgradeManager.isSecretPurchased(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should emit event on secret purchase', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const events: UpgradeEvent[] = [];\n+      upgradeManager.addEventListener(e => events.push(e));\n+\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      expect(events.some(e => e.type === 'secret_purchased')).toBe(true);\n+    });\n+  });\n+\n+  describe('toggleable secrets', () => {\n+    it('should auto-enable toggleable secrets on purchase', () => {\n+      // Exotic fuel is toggleable, requires 1 meltdown\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should allow toggling purchased toggleable secrets', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.ExoticFuel, false);\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(false);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.ExoticFuel, true);\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should not toggle unpurchased secrets', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.ExoticFuel, true);\n+\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(false);\n+    });\n+\n+    it('should not toggle non-toggleable secrets', () => {\n+      // Salvage requires 100 demolishes and is not toggleable\n+      const stats = { meltdownCount: 0, filledCells: 0, totalMoneyEarned: 0, demolishCount: 100, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.Salvage, 1000000);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.Salvage, true);\n+\n+      // Salvage is not toggleable, so enabled should remain false\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.Salvage)).toBe(false);\n+    });\n+  });\n+\n+  describe('reactor expansion', () => {\n+    it('should return correct expansion size for reactor expansions', () => {\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion1)).toBe(17);\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion2)).toBe(18);\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion3)).toBe(19);\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion4)).toBe(20);\n+    });\n+\n+    it('should return null for non-expansion secrets', () => {\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.Salvage)).toBeNull();\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ExoticFuel)).toBeNull();\n+    });\n+  });\n+\n+  describe('serialization', () => {\n+    it('should get upgrade state for serialization', () => {\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+\n+      const state = upgradeManager.getUpgradeState();\n+\n+      expect(state.levels[UpgradeType.FuelHeatOutput]).toBe(2);\n+    });\n+\n+    it('should get secret state for serialization', () => {\n+      // ExoticFuel requires 1 meltdown\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      const state = upgradeManager.getSecretState();\n+\n+      expect(state.unlocked[SecretUpgradeType.ExoticFuel]).toBe(true);\n+      expect(state.purchased[SecretUpgradeType.ExoticFuel]).toBe(true);\n+    });\n+\n+    it('should restore upgrade state from serialization', () => {\n+      const state = upgradeManager.getUpgradeState();\n+      state.levels[UpgradeType.FuelHeatOutput] = 5;\n+\n+      const newManager = new UpgradeManager();\n+      newManager.restoreUpgradeState(state);\n+\n+      expect(newManager.getUpgradeLevel(UpgradeType.FuelHeatOutput)).toBe(5);\n+    });\n+\n+    it('should restore secret state from serialization', () => {\n+      const state = upgradeManager.getSecretState();\n+      state.unlocked[SecretUpgradeType.Salvage] = true;\n+      state.purchased[SecretUpgradeType.Salvage] = true;\n+\n+      const newManager = new UpgradeManager();\n+      newManager.restoreSecretState(state);\n+\n+      expect(newManager.isSecretUnlocked(SecretUpgradeType.Salvage)).toBe(true);\n+      expect(newManager.isSecretPurchased(SecretUpgradeType.Salvage)).toBe(true);\n+    });\n+  });\n+\n+  describe('event listeners', () => {\n+    it('should allow adding and removing listeners', () => {\n+      const events: UpgradeEvent[] = [];\n+      const listener = (e: UpgradeEvent) => events.push(e);\n+\n+      upgradeManager.addEventListener(listener);\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+      expect(events).toHaveLength(1);\n+\n+      upgradeManager.removeEventListener(listener);\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+      expect(events).toHaveLength(1); // No new events\n+    });\n+  });\n+\n+  describe('multiple unlock conditions', () => {\n+    it('should unlock multiple secrets when conditions are met', () => {\n+      // Stats that should unlock both Salvage (100 demolishes) and ExoticFuel (1 meltdown) and Overclock (10000 money)\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 10000, demolishCount: 100, ticksAtHighHeat: 0 };\n+\n+      const unlocked = upgradeManager.checkSecretUnlocks(stats);\n+\n+      expect(unlocked).toContain(SecretUpgradeType.ExoticFuel);\n+      expect(unlocked).toContain(SecretUpgradeType.Salvage);\n+      expect(unlocked).toContain(SecretUpgradeType.Overclock);\n+    });\n+\n+    it('should not re-unlock already unlocked secrets', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+\n+      const firstUnlock = upgradeManager.checkSecretUnlocks(stats);\n+      expect(firstUnlock).toContain(SecretUpgradeType.ExoticFuel);\n+\n+      const secondUnlock = upgradeManager.checkSecretUnlocks(stats);\n+      expect(secondUnlock).not.toContain(SecretUpgradeType.ExoticFuel);\n+    });\n+  });\n+});\ndiff --git a/src/game/UpgradeManager.ts b/src/game/UpgradeManager.ts\nnew file mode 100644\nindex 0000000..34d4ec4\n--- /dev/null\n+++ b/src/game/UpgradeManager.ts\n@@ -0,0 +1,299 @@\n+/**\n+ * UpgradeManager - Handles regular upgrades and secret upgrades\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ * This class manages upgrade purchasing, secret unlock conditions, and toggle states.\n+ */\n+\n+import {\n+  UpgradeType,\n+  UPGRADE_DEFINITIONS,\n+  SecretUpgradeType,\n+  SECRET_UPGRADE_DEFINITIONS,\n+  getUpgradeCost,\n+  getSecretUnlockProgress,\n+} from './BalanceConfig.js';\n+\n+export interface UpgradeState {\n+  levels: Record<UpgradeType, number>;\n+}\n+\n+export interface SecretState {\n+  unlocked: Record<SecretUpgradeType, boolean>;\n+  purchased: Record<SecretUpgradeType, boolean>;\n+  enabled: Record<SecretUpgradeType, boolean>;\n+}\n+\n+export interface UpgradeEvent {\n+  type: 'upgrade_purchased' | 'secret_unlocked' | 'secret_purchased';\n+  upgradeType?: UpgradeType;\n+  secretType?: SecretUpgradeType;\n+}\n+\n+export type UpgradeEventListener = (event: UpgradeEvent) => void;\n+\n+export interface UnlockStats {\n+  meltdownCount: number;\n+  filledCells: number;\n+  totalMoneyEarned: number;\n+  demolishCount: number;\n+  ticksAtHighHeat: number;\n+}\n+\n+/**\n+ * UpgradeManager handles all upgrade-related logic including:\n+ * - Regular upgrade purchasing and level tracking\n+ * - Secret upgrade unlocking, purchasing, and toggling\n+ */\n+export class UpgradeManager {\n+  private upgrades: UpgradeState;\n+  private secrets: SecretState;\n+  private eventListeners: UpgradeEventListener[] = [];\n+\n+  constructor() {\n+    this.upgrades = this.createInitialUpgradeState();\n+    this.secrets = this.createInitialSecretState();\n+  }\n+\n+  private createInitialUpgradeState(): UpgradeState {\n+    const levels: Record<UpgradeType, number> = {} as Record<UpgradeType, number>;\n+    for (const type of Object.values(UpgradeType)) {\n+      levels[type] = 0;\n+    }\n+    return { levels };\n+  }\n+\n+  private createInitialSecretState(): SecretState {\n+    const unlocked: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+    const purchased: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+    const enabled: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+\n+    for (const type of Object.values(SecretUpgradeType)) {\n+      unlocked[type] = false;\n+      purchased[type] = false;\n+      enabled[type] = false;\n+    }\n+    return { unlocked, purchased, enabled };\n+  }\n+\n+  /**\n+   * Add an event listener for upgrade events\n+   */\n+  addEventListener(listener: UpgradeEventListener): void {\n+    this.eventListeners.push(listener);\n+  }\n+\n+  /**\n+   * Remove an event listener\n+   */\n+  removeEventListener(listener: UpgradeEventListener): void {\n+    const index = this.eventListeners.indexOf(listener);\n+    if (index !== -1) {\n+      this.eventListeners.splice(index, 1);\n+    }\n+  }\n+\n+  private emitEvent(event: UpgradeEvent): void {\n+    for (const listener of this.eventListeners) {\n+      listener(event);\n+    }\n+  }\n+\n+  // ==========================================================================\n+  // REGULAR UPGRADES\n+  // ==========================================================================\n+\n+  /**\n+   * Get the current level of an upgrade\n+   */\n+  getUpgradeLevel(type: UpgradeType): number {\n+    return this.upgrades.levels[type];\n+  }\n+\n+  /**\n+   * Get the cost for the next level of an upgrade\n+   */\n+  getUpgradeCost(type: UpgradeType): number {\n+    const currentLevel = this.upgrades.levels[type];\n+    return getUpgradeCost(type, currentLevel);\n+  }\n+\n+  /**\n+   * Check if an upgrade can be purchased\n+   */\n+  canPurchaseUpgrade(type: UpgradeType, currentMoney: number): boolean {\n+    const definition = UPGRADE_DEFINITIONS[type];\n",
      "actualWorkers": 1
    },
    "preserveOutput": "always",
    "projects": [
      {
        "outputDir": "/home/runner/work/claudetest123/claudetest123/test-results",
        "repeatEach": 1,
        "retries": 2,
        "metadata": {
          "ci": {
            "commitHref": "https://github.com/bjuergens/claudetest123/commit/f2415d687687fb5b4c621b7afc5d3ede438ea15e",
            "commitHash": "f2415d687687fb5b4c621b7afc5d3ede438ea15e",
            "prHref": "https://github.com/bjuergens/claudetest123/pull/10",
            "prTitle": "Extract GridManager, PhysicsEngine, and UpgradeManager from HeatGame",
            "prBaseHash": "f29e01ec7cb04beabadc275fcf431907f165675e",
            "buildHref": "https://github.com/bjuergens/claudetest123/actions/runs/21544476564"
          },
          "gitCommit": {
            "shortHash": "f2415d6",
            "hash": "f2415d687687fb5b4c621b7afc5d3ede438ea15e",
            "subject": "Merge f1d0811b84cdb7430f690b6091fb1360bd7b3172 into f29e01ec7cb04beabadc275fcf431907f165675e",
            "body": "Merge f1d0811b84cdb7430f690b6091fb1360bd7b3172 into f29e01ec7cb04beabadc275fcf431907f165675e\n",
            "author": {
              "name": "Björn Jürgens",
              "email": "4362465+bjuergens@users.noreply.github.com",
              "time": 1769862464000
            },
            "committer": {
              "name": "GitHub",
              "email": "noreply@github.com",
              "time": 1769862464000
            },
            "branch": "HEAD"
          },
          "gitDiff": "diff --git a/src/game/GridManager.test.ts b/src/game/GridManager.test.ts\nnew file mode 100644\nindex 0000000..468ae34\n--- /dev/null\n+++ b/src/game/GridManager.test.ts\n@@ -0,0 +1,277 @@\n+/**\n+ * Unit tests for GridManager\n+ *\n+ * Tests grid creation, neighbor calculations, and cell operations in isolation.\n+ */\n+\n+import { describe, it, expect, beforeEach } from 'vitest';\n+import { GridManager } from './GridManager.js';\n+import { StructureType, Tier } from './BalanceConfig.js';\n+\n+describe('GridManager', () => {\n+  let gridManager: GridManager;\n+\n+  beforeEach(() => {\n+    gridManager = new GridManager(16);\n+  });\n+\n+  describe('initialization', () => {\n+    it('should create a grid of the specified size', () => {\n+      expect(gridManager.getSize()).toBe(16);\n+    });\n+\n+    it('should initialize all cells as empty', () => {\n+      const snapshot = gridManager.getSnapshot();\n+      for (let y = 0; y < 16; y++) {\n+        for (let x = 0; x < 16; x++) {\n+          expect(snapshot[y][x].structure).toBe(StructureType.Empty);\n+          expect(snapshot[y][x].heat).toBe(0);\n+          expect(snapshot[y][x].power).toBe(0);\n+        }\n+      }\n+    });\n+\n+    it('should set correct x,y coordinates for each cell', () => {\n+      const snapshot = gridManager.getSnapshot();\n+      for (let y = 0; y < 16; y++) {\n+        for (let x = 0; x < 16; x++) {\n+          expect(snapshot[y][x].x).toBe(x);\n+          expect(snapshot[y][x].y).toBe(y);\n+        }\n+      }\n+    });\n+  });\n+\n+  describe('getCell', () => {\n+    it('should return a copy of the cell at valid coordinates', () => {\n+      const cell = gridManager.getCell(5, 5);\n+      expect(cell).not.toBeNull();\n+      expect(cell!.x).toBe(5);\n+      expect(cell!.y).toBe(5);\n+    });\n+\n+    it('should return null for out-of-bounds coordinates', () => {\n+      expect(gridManager.getCell(-1, 0)).toBeNull();\n+      expect(gridManager.getCell(0, -1)).toBeNull();\n+      expect(gridManager.getCell(16, 0)).toBeNull();\n+      expect(gridManager.getCell(0, 16)).toBeNull();\n+    });\n+\n+    it('should return a copy, not a reference', () => {\n+      const cell = gridManager.getCell(5, 5);\n+      cell!.heat = 100;\n+      const cellAgain = gridManager.getCell(5, 5);\n+      expect(cellAgain!.heat).toBe(0);\n+    });\n+  });\n+\n+  describe('getCellRef', () => {\n+    it('should return a reference that can be mutated', () => {\n+      const cellRef = gridManager.getCellRef(5, 5);\n+      cellRef!.heat = 100;\n+      const cell = gridManager.getCell(5, 5);\n+      expect(cell!.heat).toBe(100);\n+    });\n+\n+    it('should return null for out-of-bounds coordinates', () => {\n+      expect(gridManager.getCellRef(-1, 0)).toBeNull();\n+      expect(gridManager.getCellRef(16, 0)).toBeNull();\n+    });\n+  });\n+\n+  describe('isValidPosition', () => {\n+    it('should return true for valid positions', () => {\n+      expect(gridManager.isValidPosition(0, 0)).toBe(true);\n+      expect(gridManager.isValidPosition(15, 15)).toBe(true);\n+      expect(gridManager.isValidPosition(8, 8)).toBe(true);\n+    });\n+\n+    it('should return false for invalid positions', () => {\n+      expect(gridManager.isValidPosition(-1, 0)).toBe(false);\n+      expect(gridManager.isValidPosition(0, -1)).toBe(false);\n+      expect(gridManager.isValidPosition(16, 0)).toBe(false);\n+      expect(gridManager.isValidPosition(0, 16)).toBe(false);\n+    });\n+  });\n+\n+  describe('getNeighbors', () => {\n+    it('should return 4 neighbors for center cells', () => {\n+      const neighbors = gridManager.getNeighbors(8, 8);\n+      expect(neighbors).toHaveLength(4);\n+    });\n+\n+    it('should return 3 neighbors for edge cells', () => {\n+      const neighbors = gridManager.getNeighbors(0, 8);\n+      expect(neighbors).toHaveLength(3);\n+    });\n+\n+    it('should return 2 neighbors for corner cells', () => {\n+      const neighbors = gridManager.getNeighbors(0, 0);\n+      expect(neighbors).toHaveLength(2);\n+    });\n+\n+    it('should return orthogonal neighbors only', () => {\n+      const neighbors = gridManager.getNeighbors(5, 5);\n+      const positions = neighbors.map(n => ({ x: n.x, y: n.y }));\n+\n+      expect(positions).toContainEqual({ x: 5, y: 4 }); // up\n+      expect(positions).toContainEqual({ x: 5, y: 6 }); // down\n+      expect(positions).toContainEqual({ x: 4, y: 5 }); // left\n+      expect(positions).toContainEqual({ x: 6, y: 5 }); // right\n+    });\n+  });\n+\n+  describe('countAdjacentFuelRods', () => {\n+    it('should return 0 when no fuel rods are adjacent', () => {\n+      expect(gridManager.countAdjacentFuelRods(5, 5)).toBe(0);\n+    });\n+\n+    it('should count active fuel rods only', () => {\n+      // Place active fuel rod\n+      const cell1 = gridManager.getCellRef(5, 4)!;\n+      cell1.structure = StructureType.FuelRod;\n+      cell1.lifetime = 100;\n+\n+      // Place depleted fuel rod\n+      const cell2 = gridManager.getCellRef(5, 6)!;\n+      cell2.structure = StructureType.FuelRod;\n+      cell2.lifetime = 0;\n+\n+      expect(gridManager.countAdjacentFuelRods(5, 5)).toBe(1);\n+    });\n+\n+    it('should count all adjacent active fuel rods', () => {\n+      const positions = [\n+        { x: 5, y: 4 },\n+        { x: 5, y: 6 },\n+        { x: 4, y: 5 },\n+        { x: 6, y: 5 },\n+      ];\n+\n+      for (const pos of positions) {\n+        const cell = gridManager.getCellRef(pos.x, pos.y)!;\n+        cell.structure = StructureType.FuelRod;\n+        cell.lifetime = 100;\n+      }\n+\n+      expect(gridManager.countAdjacentFuelRods(5, 5)).toBe(4);\n+    });\n+  });\n+\n+  describe('getFilledCellCount', () => {\n+    it('should return 0 for empty grid', () => {\n+      expect(gridManager.getFilledCellCount()).toBe(0);\n+    });\n+\n+    it('should count non-empty cells', () => {\n+      gridManager.getCellRef(0, 0)!.structure = StructureType.FuelRod;\n+      gridManager.getCellRef(1, 1)!.structure = StructureType.Turbine;\n+      gridManager.getCellRef(2, 2)!.structure = StructureType.Ventilator;\n+\n+      expect(gridManager.getFilledCellCount()).toBe(3);\n+    });\n+  });\n+\n+  describe('expandGrid', () => {\n+    it('should expand grid to new size', () => {\n+      gridManager.getCellRef(5, 5)!.structure = StructureType.FuelRod;\n+\n+      const result = gridManager.expandGrid(18, 20);\n+      expect(result).toBe(true);\n+      expect(gridManager.getSize()).toBe(18);\n+    });\n+\n+    it('should preserve existing cells after expansion', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.heat = 500;\n+\n+      gridManager.expandGrid(18, 20);\n+\n+      const preserved = gridManager.getCell(5, 5);\n+      expect(preserved!.structure).toBe(StructureType.FuelRod);\n+      expect(preserved!.heat).toBe(500);\n+    });\n+\n+    it('should not expand beyond max size', () => {\n+      const result = gridManager.expandGrid(25, 20);\n+      expect(result).toBe(false);\n+      expect(gridManager.getSize()).toBe(16);\n+    });\n+\n+    it('should not shrink the grid', () => {\n+      const result = gridManager.expandGrid(10, 20);\n+      expect(result).toBe(false);\n+      expect(gridManager.getSize()).toBe(16);\n+    });\n+  });\n+\n+  describe('resetCell', () => {\n+    it('should reset a cell to empty state', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.Turbine;\n+      cell.heat = 500;\n+      cell.power = 100;\n+\n+      gridManager.resetCell(5, 5);\n+\n+      const reset = gridManager.getCell(5, 5);\n+      expect(reset!.structure).toBe(StructureType.Empty);\n+      expect(reset!.heat).toBe(0);\n+      expect(reset!.power).toBe(0);\n+    });\n+\n+    it('should preserve coordinates after reset', () => {\n+      gridManager.resetCell(5, 5);\n+      const cell = gridManager.getCell(5, 5);\n+      expect(cell!.x).toBe(5);\n+      expect(cell!.y).toBe(5);\n+    });\n+  });\n+\n+  describe('clearAll', () => {\n+    it('should reset all cells to empty', () => {\n+      // Fill some cells\n+      for (let i = 0; i < 5; i++) {\n+        gridManager.getCellRef(i, i)!.structure = StructureType.FuelRod;\n+      }\n+\n+      gridManager.clearAll();\n+\n+      expect(gridManager.getFilledCellCount()).toBe(0);\n+    });\n+  });\n+\n+  describe('forEach', () => {\n+    it('should iterate over all cells', () => {\n+      let count = 0;\n+      gridManager.forEach(() => count++);\n+      expect(count).toBe(16 * 16);\n+    });\n+\n+    it('should provide correct cell references', () => {\n+      gridManager.forEach((cell, x, y) => {\n+        expect(cell.x).toBe(x);\n+        expect(cell.y).toBe(y);\n+      });\n+    });\n+  });\n+\n+  describe('restoreFromState', () => {\n+    it('should restore grid from serialized state', () => {\n+      // Create a state to restore\n+      const state = gridManager.getSnapshot();\n+      state[5][5].structure = StructureType.Turbine;\n+      state[5][5].heat = 250;\n+\n+      // Create new grid manager and restore\n+      const newGridManager = new GridManager(10);\n+      newGridManager.restoreFromState(state, 16);\n+\n+      expect(newGridManager.getSize()).toBe(16);\n+      const cell = newGridManager.getCell(5, 5);\n+      expect(cell!.structure).toBe(StructureType.Turbine);\n+      expect(cell!.heat).toBe(250);\n+    });\n+  });\n+});\ndiff --git a/src/game/GridManager.ts b/src/game/GridManager.ts\nnew file mode 100644\nindex 0000000..0e158a8\n--- /dev/null\n+++ b/src/game/GridManager.ts\n@@ -0,0 +1,221 @@\n+/**\n+ * GridManager - Handles grid creation, neighbor calculations, and cell operations\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ */\n+\n+import { StructureType, Tier } from './BalanceConfig.js';\n+\n+export interface Cell {\n+  x: number;\n+  y: number;\n+  structure: StructureType;\n+  tier: Tier;\n+  heat: number;\n+  power: number;\n+  /** Remaining lifetime in ticks (fuel rods only, 0 = infinite/depleted) */\n+  lifetime: number;\n+  /** Whether this is an exotic variant (fuel rods only) */\n+  isExotic: boolean;\n+}\n+\n+export class GridManager {\n+  private grid: Cell[][];\n+  private gridSize: number;\n+\n+  constructor(initialSize: number) {\n+    this.gridSize = initialSize;\n+    this.grid = this.createEmptyGrid(initialSize);\n+  }\n+\n+  /**\n+   * Create a new empty grid of the specified size\n+   */\n+  createEmptyGrid(size: number): Cell[][] {\n+    const grid: Cell[][] = [];\n+    for (let y = 0; y < size; y++) {\n+      const row: Cell[] = [];\n+      for (let x = 0; x < size; x++) {\n+        row.push(this.createEmptyCell(x, y));\n+      }\n+      grid.push(row);\n+    }\n+    return grid;\n+  }\n+\n+  /**\n+   * Create an empty cell at the specified coordinates\n+   */\n+  createEmptyCell(x: number, y: number): Cell {\n+    return {\n+      x,\n+      y,\n+      structure: StructureType.Empty,\n+      tier: Tier.T1,\n+      heat: 0,\n+      power: 0,\n+      lifetime: 0,\n+      isExotic: false,\n+    };\n+  }\n+\n+  /**\n+   * Get a copy of a cell at the specified coordinates\n+   * Returns null if coordinates are out of bounds\n+   */\n+  getCell(x: number, y: number): Cell | null {\n+    if (!this.isValidPosition(x, y)) {\n+      return null;\n+    }\n+    return { ...this.grid[y][x] };\n+  }\n+\n+  /**\n+   * Get a direct reference to a cell (for mutation)\n+   * Returns null if coordinates are out of bounds\n+   */\n+  getCellRef(x: number, y: number): Cell | null {\n+    if (!this.isValidPosition(x, y)) {\n+      return null;\n+    }\n+    return this.grid[y][x];\n+  }\n+\n+  /**\n+   * Check if coordinates are within grid bounds\n+   */\n+  isValidPosition(x: number, y: number): boolean {\n+    return x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize;\n+  }\n+\n+  /**\n+   * Get the current grid size\n+   */\n+  getSize(): number {\n+    return this.gridSize;\n+  }\n+\n+  /**\n+   * Get a snapshot (deep copy) of the entire grid\n+   */\n+  getSnapshot(): Cell[][] {\n+    return this.grid.map(row => row.map(cell => ({ ...cell })));\n+  }\n+\n+  /**\n+   * Get the internal grid reference (for physics engine)\n+   */\n+  getGridRef(): Cell[][] {\n+    return this.grid;\n+  }\n+\n+  /**\n+   * Get orthogonal neighbors (up, down, left, right) of a cell\n+   */\n+  getNeighbors(x: number, y: number): Cell[] {\n+    const neighbors: Cell[] = [];\n+    const directions = [\n+      { dx: 0, dy: -1 }, // up\n+      { dx: 0, dy: 1 },  // down\n+      { dx: -1, dy: 0 }, // left\n+      { dx: 1, dy: 0 },  // right\n+    ];\n+\n+    for (const { dx, dy } of directions) {\n+      const nx = x + dx;\n+      const ny = y + dy;\n+      if (this.isValidPosition(nx, ny)) {\n+        neighbors.push(this.grid[ny][nx]);\n+      }\n+    }\n+\n+    return neighbors;\n+  }\n+\n+  /**\n+   * Count active (non-depleted) fuel rods adjacent to a position\n+   */\n+  countAdjacentFuelRods(x: number, y: number): number {\n+    const neighbors = this.getNeighbors(x, y);\n+    return neighbors.filter(n => n.structure === StructureType.FuelRod && n.lifetime > 0).length;\n+  }\n+\n+  /**\n+   * Count filled (non-empty) cells in the grid\n+   */\n+  getFilledCellCount(): number {\n+    let count = 0;\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        if (this.grid[y][x].structure !== StructureType.Empty) {\n+          count++;\n+        }\n+      }\n+    }\n+    return count;\n+  }\n+\n+  /**\n+   * Expand the grid to a new size, preserving existing cells\n+   * Returns true if expansion was successful\n+   */\n+  expandGrid(newSize: number, maxSize: number): boolean {\n+    if (newSize <= this.gridSize) return false;\n+    if (newSize > maxSize) return false;\n+\n+    const oldGrid = this.grid;\n+    const oldSize = this.gridSize;\n+\n+    // Create new larger grid\n+    this.grid = this.createEmptyGrid(newSize);\n+    this.gridSize = newSize;\n+\n+    // Copy old grid data\n+    for (let y = 0; y < oldSize; y++) {\n+      for (let x = 0; x < oldSize; x++) {\n+        this.grid[y][x] = { ...oldGrid[y][x] };\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Reset a cell to empty state\n+   */\n+  resetCell(x: number, y: number): void {\n+    if (this.isValidPosition(x, y)) {\n+      this.grid[y][x] = this.createEmptyCell(x, y);\n+    }\n+  }\n+\n+  /**\n+   * Clear all cells in the grid (reset to empty)\n+   */\n+  clearAll(): void {\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        this.grid[y][x] = this.createEmptyCell(x, y);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Iterate over all cells, calling the callback for each\n+   */\n+  forEach(callback: (cell: Cell, x: number, y: number) => void): void {\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        callback(this.grid[y][x], x, y);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Restore grid state from serialized data\n+   */\n+  restoreFromState(grid: Cell[][], gridSize: number): void {\n+    this.gridSize = gridSize;\n+    this.grid = grid.map(row => row.map(cell => ({ ...cell })));\n+  }\n+}\ndiff --git a/src/game/HeatGame.ts b/src/game/HeatGame.ts\nindex 24971dc..eeca20d 100644\n--- a/src/game/HeatGame.ts\n+++ b/src/game/HeatGame.ts\n@@ -1,15 +1,10 @@\n /**\n  * Heat Management Game - Core Game Logic\n  *\n- * Refactored to support:\n- * - Tiered items (T1-T4)\n- * - Fuel rod lifetime and depletion\n- * - Adjacency heat bonus for fuel rods\n- * - Manual power generation (clicker)\n- * - Upgrade system (regular + secret)\n- * - Exotic fuel rods\n- * - Dynamic grid size (16x16 to 20x20)\n- * - Variable melt temperatures and conductivity\n+ * Refactored to use composed classes for better separation of concerns:\n+ * - GridManager: Grid creation and cell operations\n+ * - PhysicsEngine: Heat/power simulation\n+ * - UpgradeManager: Upgrade and secret management\n  */\n \n import {\n@@ -18,46 +13,28 @@ import {\n   Tier,\n   StructureType,\n   STRUCTURE_BASE_STATS,\n-  FUEL_ADJACENCY,\n-  ECONOMY,\n   UpgradeType,\n-  UPGRADE_DEFINITIONS,\n   SecretUpgradeType,\n   SECRET_UPGRADE_DEFINITIONS,\n-  EXOTIC_FUEL,\n   getStructureCost,\n   getFuelLifetime,\n-  getFuelHeatGeneration,\n-  getUpgradeCost,\n-  getSecretUnlockProgress,\n } from './BalanceConfig.js';\n \n+import { GridManager, Cell } from './GridManager.js';\n+import { PhysicsEngine, PhysicsEvent } from './PhysicsEngine.js';\n+import { UpgradeManager, UpgradeEvent } from './UpgradeManager.js';\n+\n // Re-export types for backward compatibility\n export { StructureType, Tier, UpgradeType, SecretUpgradeType };\n-\n-export interface Cell {\n-  x: number;\n-  y: number;\n-  structure: StructureType;\n-  tier: Tier;\n-  heat: number;\n-  power: number;\n-  /** Remaining lifetime in ticks (fuel rods only, 0 = infinite/depleted) */\n-  lifetime: number;\n-  /** Whether this is an exotic variant (fuel rods only) */\n-  isExotic: boolean;\n-}\n+export { Cell };\n \n export interface UpgradeState {\n   levels: Record<UpgradeType, number>;\n }\n \n export interface SecretState {\n-  /** Whether the unlock condition has been met */\n   unlocked: Record<SecretUpgradeType, boolean>;\n-  /** Whether the upgrade has been purchased */\n   purchased: Record<SecretUpgradeType, boolean>;\n-  /** Toggle state for toggleable secrets */\n   enabled: Record<SecretUpgradeType, boolean>;\n }\n \n@@ -107,87 +84,101 @@ export interface GameEvent {\n \n export type GameEventListener = (event: GameEvent) => void;\n \n-// Helper to create initial upgrade state\n-function createInitialUpgradeState(): UpgradeState {\n-  const levels: Record<UpgradeType, number> = {} as Record<UpgradeType, number>;\n-  for (const type of Object.values(UpgradeType)) {\n-    levels[type] = 0;\n-  }\n-  return { levels };\n-}\n-\n-// Helper to create initial secret state\n-function createInitialSecretState(): SecretState {\n-  const unlocked: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n-  const purchased: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n-  const enabled: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n-\n-  for (const type of Object.values(SecretUpgradeType)) {\n-    unlocked[type] = false;\n-    purchased[type] = false;\n-    enabled[type] = false;\n-  }\n-  return { unlocked, purchased, enabled };\n-}\n-\n+/**\n+ * HeatGame - Main game orchestrator\n+ *\n+ * Composes GridManager, PhysicsEngine, and UpgradeManager to coordinate\n+ * game logic while delegating specific responsibilities to each component.\n+ */\n export class HeatGame {\n-  private state: GameState;\n+  private gridManager: GridManager;\n+  private physicsEngine: PhysicsEngine;\n+  private upgradeManager: UpgradeManager;\n+\n+  private money: number;\n+  private stats: GameStats;\n   private eventListeners: GameEventListener[] = [];\n \n   constructor(initialMoney: number = CORE_SETTINGS.STARTING_MONEY) {\n-    this.state = this.createInitialState(initialMoney);\n-  }\n+    // Initialize composed components\n+    this.gridManager = new GridManager(CORE_SETTINGS.INITIAL_GRID_SIZE);\n+    this.upgradeManager = new UpgradeManager();\n+    this.physicsEngine = new PhysicsEngine(\n+      this.gridManager,\n+      (type: UpgradeType) => this.upgradeManager.getUpgradeLevel(type)\n+    );\n+\n+    this.money = initialMoney;\n+    this.stats = this.createInitialStats();\n \n-  private createInitialState(initialMoney: number): GameState {\n-    const gridSize = CORE_SETTINGS.INITIAL_GRID_SIZE;\n-    const grid = this.createEmptyGrid(gridSize);\n+    // Wire up event forwarding from sub-components\n+    this.setupEventForwarding();\n+  }\n \n+  private createInitialStats(): GameStats {\n     return {\n-      grid,\n-      gridSize,\n-      money: initialMoney,\n-      stats: {\n-        totalPowerGenerated: 0,\n-        totalMoneyEarned: 0,\n-        meltdownCount: 0,\n-        tickCount: 0,\n-        demolishCount: 0,\n-        ticksAtHighHeat: 0,\n-        manualClicks: 0,\n-        structuresBuilt: 0,\n-        fuelRodsDepleted: 0,\n-      },\n-      upgrades: createInitialUpgradeState(),\n-      secrets: createInitialSecretState(),\n+      totalPowerGenerated: 0,\n+      totalMoneyEarned: 0,\n+      meltdownCount: 0,\n+      tickCount: 0,\n+      demolishCount: 0,\n+      ticksAtHighHeat: 0,\n+      manualClicks: 0,\n+      structuresBuilt: 0,\n+      fuelRodsDepleted: 0,\n     };\n   }\n \n-  private createEmptyGrid(size: number): Cell[][] {\n-    const grid: Cell[][] = [];\n-    for (let y = 0; y < size; y++) {\n-      const row: Cell[] = [];\n-      for (let x = 0; x < size; x++) {\n-        row.push(this.createEmptyCell(x, y));\n+  private setupEventForwarding(): void {\n+    // Forward physics events\n+    // Note: Stats are tracked in PhysicsEngine, we only forward events here\n+    this.physicsEngine.addEventListener((event: PhysicsEvent) => {\n+      if (event.type === 'fuel_depleted') {\n+        // Don't increment here - PhysicsEngine already tracks this stat\n+        this.emitEvent({\n+          type: 'fuel_depleted',\n+          x: event.x,\n+          y: event.y,\n+          tier: event.tier,\n+        });\n+      } else if (event.type === 'power_sold') {\n+        this.emitEvent({\n+          type: 'power_sold',\n+          x: event.x,\n+          y: event.y,\n+          amount: event.amount,\n+        });\n+      } else if (event.type === 'structure_melted') {\n+        this.emitEvent({\n+          type: 'structure_melted',\n+          x: event.x,\n+          y: event.y,\n+          structure: event.structure,\n+          tier: event.tier,\n+        });\n+      } else if (event.type === 'meltdown') {\n+        this.stats.meltdownCount++;\n+        this.emitEvent({ type: 'meltdown' });\n+        this.checkSecretUnlocks();\n       }\n-      grid.push(row);\n-    }\n-    return grid;\n-  }\n+    });\n \n-  private createEmptyCell(x: number, y: number): Cell {\n-    return {\n-      x,\n-      y,\n-      structure: StructureType.Empty,\n-      tier: Tier.T1,\n-      heat: 0,\n-      power: 0,\n-      lifetime: 0,\n-      isExotic: false,\n-    };\n+    // Forward upgrade events\n+    this.upgradeManager.addEventListener((event: UpgradeEvent) => {\n+      if (event.type === 'upgrade_purchased') {\n+        this.emitEvent({ type: 'upgrade_purchased', upgradeType: event.upgradeType });\n+      } else if (event.type === 'secret_unlocked') {\n+        this.emitEvent({ type: 'secret_unlocked', secretType: event.secretType });\n+      } else if (event.type === 'secret_purchased') {\n+        this.emitEvent({ type: 'secret_purchased', secretType: event.secretType });\n+      }\n+    });\n   }\n \n-  // Event system\n+  // ==========================================================================\n+  // EVENT SYSTEM\n+  // ==========================================================================\n+\n   addEventListener(listener: GameEventListener): void {\n     this.eventListeners.push(listener);\n   }\n@@ -206,74 +197,63 @@ export class HeatGame {\n   }\n \n   // ==========================================================================\n-  // GETTERS\n+  // GETTERS (delegate to sub-components)\n   // ==========================================================================\n \n   getCell(x: number, y: number): Cell | null {\n-    if (x < 0 || x >= this.state.gridSize || y < 0 || y >= this.state.gridSize) {\n-      return null;\n-    }\n-    return { ...this.state.grid[y][x] };\n+    return this.gridManager.getCell(x, y);\n   }\n \n   getGridSize(): number {\n-    return this.state.gridSize;\n+    return this.gridManager.getSize();\n   }\n \n   getMoney(): number {\n-    return this.state.money;\n+    return this.money;\n   }\n \n   getTickCount(): number {\n-    return this.state.stats.tickCount;\n+    return this.stats.tickCount;\n   }\n \n   getMeltdownCount(): number {\n-    return this.state.stats.meltdownCount;\n+    return this.stats.meltdownCount;\n   }\n \n   getTotalPowerGenerated(): number {\n-    return this.state.stats.totalPowerGenerated;\n+    return this.stats.totalPowerGenerated;\n   }\n \n   getTotalMoneyEarned(): number {\n-    return this.state.stats.totalMoneyEarned;\n+    return this.stats.totalMoneyEarned;\n   }\n \n   getStats(): GameStats {\n-    return { ...this.state.stats };\n+    return { ...this.stats };\n   }\n \n   getUpgradeLevel(type: UpgradeType): number {\n-    return this.state.upgrades.levels[type];\n+    return this.upgradeManager.getUpgradeLevel(type);\n   }\n \n   isSecretUnlocked(type: SecretUpgradeType): boolean {\n-    return this.state.secrets.unlocked[type];\n+    return this.upgradeManager.isSecretUnlocked(type);\n   }\n \n   isSecretPurchased(type: SecretUpgradeType): boolean {\n-    return this.state.secrets.purchased[type];\n+    return this.upgradeManager.isSecretPurchased(type);\n   }\n \n   isSecretEnabled(type: SecretUpgradeType): boolean {\n-    return this.state.secrets.enabled[type];\n+    return this.upgradeManager.isSecretEnabled(type);\n   }\n \n   getGridSnapshot(): Cell[][] {\n-    return this.state.grid.map(row => row.map(cell => ({ ...cell })));\n+    return this.gridManager.getSnapshot();\n   }\n \n   getFilledCellCount(): number {\n-    let count = 0;\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        if (this.state.grid[y][x].structure !== StructureType.Empty) {\n-          count++;\n-        }\n-      }\n-    }\n-    return count;\n+    return this.gridManager.getFilledCellCount();\n   }\n \n   // ==========================================================================\n@@ -281,13 +261,13 @@ export class HeatGame {\n   // ==========================================================================\n \n   manualGenerate(): number {\n-    const upgradeLevel = this.state.upgrades.levels[UpgradeType.ManualClickPower];\n+    const upgradeLevel = this.upgradeManager.getUpgradeLevel(UpgradeType.ManualClickPower);\n     const moneyEarned = MANUAL_GENERATION.BASE_MONEY_PER_CLICK +\n       (upgradeLevel * MANUAL_GENERATION.MONEY_PER_LEVEL);\n \n-    this.state.money += moneyEarned;\n-    this.state.stats.totalMoneyEarned += moneyEarned;\n-    this.state.stats.manualClicks++;\n+    this.money += moneyEarned;\n+    this.stats.totalMoneyEarned += moneyEarned;\n+    this.stats.manualClicks++;\n \n     this.emitEvent({ type: 'manual_click', amount: moneyEarned });\n     return moneyEarned;\n@@ -302,20 +282,21 @@ export class HeatGame {\n   }\n \n   canBuild(x: number, y: number, structure: StructureType, tier: Tier = Tier.T1): boolean {\n-    const cell = this.getCell(x, y);\n+    const cell = this.gridManager.getCell(x, y);\n     if (!cell) return false;\n     if (cell.structure !== StructureType.Empty) return false;\n \n     // Check if structure is secret and not unlocked\n     const baseStats = STRUCTURE_BASE_STATS[structure];\n     if (baseStats.isSecret) {\n-      if (structure === StructureType.VoidCell && !this.state.secrets.purchased[SecretUpgradeType.VoidCellUnlock]) {\n+      if (structure === StructureType.VoidCell &&\n+          !this.upgradeManager.isSecretPurchased(SecretUpgradeType.VoidCellUnlock)) {\n         return false;\n       }\n     }\n \n     const cost = getStructureCost(structure, tier);\n-    return this.state.money >= cost;\n+    return this.money >= cost;\n   }\n \n   build(x: number, y: number, structure: StructureType, tier: Tier = Tier.T1, isExotic: boolean = false): boolean {\n@@ -323,16 +304,16 @@ export class HeatGame {\n \n     // Exotic fuel requires the secret to be purchased and enabled\n     if (isExotic && structure === StructureType.FuelRod) {\n-      if (!this.state.secrets.purchased[SecretUpgradeType.ExoticFuel] ||\n-          !this.state.secrets.enabled[SecretUpgradeType.ExoticFuel]) {\n+      if (!this.upgradeManager.isSecretPurchased(SecretUpgradeType.ExoticFuel) ||\n+          !this.upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)) {\n         isExotic = false;\n       }\n     }\n \n     const cost = getStructureCost(structure, tier);\n-    this.state.money -= cost;\n+    this.money -= cost;\n \n-    const cell = this.state.grid[y][x];\n+    const cell = this.gridManager.getCellRef(x, y)!;\n     cell.structure = structure;\n     cell.tier = tier;\n     cell.heat = 0;\n@@ -341,13 +322,13 @@ export class HeatGame {\n \n     // Set lifetime for fuel rods\n     if (structure === StructureType.FuelRod) {\n-      const upgradeLevel = this.state.upgrades.levels[UpgradeType.FuelLifetime];\n+      const upgradeLevel = this.upgradeManager.getUpgradeLevel(UpgradeType.FuelLifetime);\n       cell.lifetime = getFuelLifetime(tier, upgradeLevel);\n     } else {\n       cell.lifetime = 0;\n     }\n \n-    this.state.stats.structuresBuilt++;\n+    this.stats.structuresBuilt++;\n \n     this.emitEvent({\n       type: 'structure_built',\n@@ -357,28 +338,25 @@ export class HeatGame {\n       tier,\n     });\n \n-    // Check for secret unlocks\n     this.checkSecretUnlocks();\n-\n     return true;\n   }\n \n   demolish(x: number, y: number): boolean {\n-    const cell = this.getCell(x, y);\n+    const cell = this.gridManager.getCell(x, y);\n     if (!cell || cell.structure === StructureType.Empty) return false;\n \n-    const oldStructure = this.state.grid[y][x].structure;\n-    const oldTier = this.state.grid[y][x].tier;\n+    const oldStructure = cell.structure;\n+    const oldTier = cell.tier;\n \n     // Refund if salvage is unlocked\n-    if (this.state.secrets.purchased[SecretUpgradeType.Salvage]) {\n+    if (this.upgradeManager.isSecretPurchased(SecretUpgradeType.Salvage)) {\n       const refund = Math.floor(getStructureCost(oldStructure, oldTier) * 0.5);\n-      this.state.money += refund;\n+      this.money += refund;\n     }\n \n-    // Reset cell\n-    this.state.grid[y][x] = this.createEmptyCell(x, y);\n-    this.state.stats.demolishCount++;\n+    this.gridManager.resetCell(x, y);\n+    this.stats.demolishCount++;\n \n     this.emitEvent({\n       type: 'structure_destroyed',\n@@ -388,558 +366,157 @@ export class HeatGame {\n       tier: oldTier,\n     });\n \n-    // Check for salvage unlock\n     this.checkSecretUnlocks();\n-\n     return true;\n   }\n \n   // ==========================================================================\n-  // UPGRADES\n+  // UPGRADES (delegate to UpgradeManager)\n   // ==========================================================================\n \n   getUpgradeCost(type: UpgradeType): number {\n-    const currentLevel = this.state.upgrades.levels[type];\n-    return getUpgradeCost(type, currentLevel);\n+    return this.upgradeManager.getUpgradeCost(type);\n   }\n \n   canPurchaseUpgrade(type: UpgradeType): boolean {\n-    const definition = UPGRADE_DEFINITIONS[type];\n-    const currentLevel = this.state.upgrades.levels[type];\n-\n-    // Check max level\n-    if (definition.maxLevel > 0 && currentLevel >= definition.maxLevel) {\n-      return false;\n-    }\n-\n-    const cost = getUpgradeCost(type, currentLevel);\n-    return this.state.money >= cost;\n+    return this.upgradeManager.canPurchaseUpgrade(type, this.money);\n   }\n \n   purchaseUpgrade(type: UpgradeType): boolean {\n-    if (!this.canPurchaseUpgrade(type)) return false;\n-\n-    const cost = getUpgradeCost(type, this.state.upgrades.levels[type]);\n-    this.state.money -= cost;\n-    this.state.upgrades.levels[type]++;\n-\n-    this.emitEvent({ type: 'upgrade_purchased', upgradeType: type });\n-    return true;\n+    const cost = this.upgradeManager.purchaseUpgrade(type, this.money);\n+    if (cost > 0) {\n+      this.money -= cost;\n+      return true;\n+    }\n+    return false;\n   }\n \n   // ==========================================================================\n-  // SECRET UPGRADES\n+  // SECRET UPGRADES (delegate to UpgradeManager)\n   // ==========================================================================\n \n   getSecretCost(type: SecretUpgradeType): number {\n-    return SECRET_UPGRADE_DEFINITIONS[type].cost;\n+    return this.upgradeManager.getSecretCost(type);\n   }\n \n   canPurchaseSecret(type: SecretUpgradeType): boolean {\n-    if (!this.state.secrets.unlocked[type]) return false;\n-    if (this.state.secrets.purchased[type]) return false;\n-\n-    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n-    return this.state.money >= cost;\n+    return this.upgradeManager.canPurchaseSecret(type, this.money);\n   }\n \n   purchaseSecret(type: SecretUpgradeType): boolean {\n-    if (!this.canPurchaseSecret(type)) return false;\n-\n-    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n-    this.state.money -= cost;\n-    this.state.secrets.purchased[type] = true;\n-\n-    // Auto-enable toggleable secrets\n-    if (SECRET_UPGRADE_DEFINITIONS[type].isToggle) {\n-      this.state.secrets.enabled[type] = true;\n-    }\n+    const cost = this.upgradeManager.purchaseSecret(type, this.money);\n+    if (cost > 0) {\n+      this.money -= cost;\n+\n+      // Handle reactor expansion\n+      const expansionSize = this.upgradeManager.getExpansionSize(type);\n+      if (expansionSize !== null) {\n+        this.expandGrid(expansionSize);\n+      }\n \n-    // Handle reactor expansion\n-    if (type === SecretUpgradeType.ReactorExpansion1) {\n-      this.expandGrid(17);\n-    } else if (type === SecretUpgradeType.ReactorExpansion2) {\n-      this.expandGrid(18);\n-    } else if (type === SecretUpgradeType.ReactorExpansion3) {\n-      this.expandGrid(19);\n-    } else if (type === SecretUpgradeType.ReactorExpansion4) {\n-      this.expandGrid(20);\n+      return true;\n     }\n-\n-    this.emitEvent({ type: 'secret_purchased', secretType: type });\n-    return true;\n+    return false;\n   }\n \n   toggleSecret(type: SecretUpgradeType, enabled: boolean): void {\n-    if (!this.state.secrets.purchased[type]) return;\n-    if (!SECRET_UPGRADE_DEFINITIONS[type].isToggle) return;\n-\n-    this.state.secrets.enabled[type] = enabled;\n+    this.upgradeManager.toggleSecret(type, enabled);\n   }\n \n   private expandGrid(newSize: number): void {\n-    if (newSize <= this.state.gridSize) return;\n-    if (newSize > CORE_SETTINGS.MAX_GRID_SIZE) return;\n-\n-    const oldGrid = this.state.grid;\n-    const oldSize = this.state.gridSize;\n-\n-    // Create new larger grid\n-    this.state.grid = this.createEmptyGrid(newSize);\n-    this.state.gridSize = newSize;\n-\n-    // Copy old grid data\n-    for (let y = 0; y < oldSize; y++) {\n-      for (let x = 0; x < oldSize; x++) {\n-        this.state.grid[y][x] = { ...oldGrid[y][x] };\n-      }\n+    if (this.gridManager.expandGrid(newSize, CORE_SETTINGS.MAX_GRID_SIZE)) {\n+      this.emitEvent({ type: 'grid_expanded', newGridSize: newSize });\n     }\n-\n-    this.emitEvent({ type: 'grid_expanded', newGridSize: newSize });\n   }\n \n   private checkSecretUnlocks(): void {\n     const stats = {\n-      meltdownCount: this.state.stats.meltdownCount,\n-      filledCells: this.getFilledCellCount(),\n-      totalMoneyEarned: this.state.stats.totalMoneyEarned,\n-      demolishCount: this.state.stats.demolishCount,\n-      ticksAtHighHeat: this.state.stats.ticksAtHighHeat,\n+      meltdownCount: this.stats.meltdownCount,\n+      filledCells: this.gridManager.getFilledCellCount(),\n+      totalMoneyEarned: this.stats.totalMoneyEarned,\n+      demolishCount: this.stats.demolishCount,\n+      ticksAtHighHeat: this.stats.ticksAtHighHeat,\n     };\n \n-    for (const type of Object.values(SecretUpgradeType)) {\n-      if (this.state.secrets.unlocked[type]) continue;\n-\n-      const progress = getSecretUnlockProgress(type, stats);\n-      if (progress.unlocked) {\n-        this.state.secrets.unlocked[type] = true;\n-        this.emitEvent({ type: 'secret_unlocked', secretType: type });\n-      }\n-    }\n-  }\n-\n-  // ==========================================================================\n-  // NEIGHBORS\n-  // ==========================================================================\n-\n-  private getNeighbors(x: number, y: number): Cell[] {\n-    const neighbors: Cell[] = [];\n-    const directions = [\n-      { dx: 0, dy: -1 }, // up\n-      { dx: 0, dy: 1 },  // down\n-      { dx: -1, dy: 0 }, // left\n-      { dx: 1, dy: 0 },  // right\n-    ];\n-\n-    for (const { dx, dy } of directions) {\n-      const nx = x + dx;\n-      const ny = y + dy;\n-      if (nx >= 0 && nx < this.state.gridSize && ny >= 0 && ny < this.state.gridSize) {\n-        neighbors.push(this.state.grid[ny][nx]);\n-      }\n-    }\n-\n-    return neighbors;\n-  }\n-\n-  private countAdjacentFuelRods(x: number, y: number): number {\n-    const neighbors = this.getNeighbors(x, y);\n-    return neighbors.filter(n => n.structure === StructureType.FuelRod && n.lifetime > 0).length;\n-  }\n-\n-  // ==========================================================================\n-  // EFFECTIVE STATS (with upgrades)\n-  // ==========================================================================\n-\n-  private getEffectiveMeltTemp(structure: StructureType): number {\n-    const baseTemp = STRUCTURE_BASE_STATS[structure].meltTemp;\n-\n-    // Get the appropriate melt temp upgrade\n-    let upgradeType: UpgradeType | null = null;\n-    switch (structure) {\n-      case StructureType.FuelRod: upgradeType = UpgradeType.MeltTempFuelRod; break;\n-      case StructureType.Ventilator: upgradeType = UpgradeType.MeltTempVentilator; break;\n-      case StructureType.HeatExchanger: upgradeType = UpgradeType.MeltTempHeatExchanger; break;\n-      case StructureType.Insulator: upgradeType = UpgradeType.MeltTempInsulator; break;\n-      case StructureType.Turbine: upgradeType = UpgradeType.MeltTempTurbine; break;\n-      case StructureType.Substation: upgradeType = UpgradeType.MeltTempSubstation; break;\n-    }\n-\n-    if (upgradeType) {\n-      const level = this.state.upgrades.levels[upgradeType];\n-      const definition = UPGRADE_DEFINITIONS[upgradeType];\n-      return baseTemp + (level * definition.improvementPerLevel);\n-    }\n-\n-    return baseTemp;\n-  }\n-\n-  private getEffectiveConductivity(cell: Cell): number {\n-    const baseConductivity = STRUCTURE_BASE_STATS[cell.structure].conductivity;\n-\n-    if (cell.structure === StructureType.Turbine) {\n-      const level = this.state.upgrades.levels[UpgradeType.TurbineConductivity];\n-      const definition = UPGRADE_DEFINITIONS[UpgradeType.TurbineConductivity];\n-      return baseConductivity + (level * definition.improvementPerLevel);\n-    }\n-\n-    if (cell.structure === StructureType.Insulator) {\n-      const level = this.state.upgrades.levels[UpgradeType.InsulatorConductivity];\n-      if (level > 0) {\n-        // Multiplicative reduction\n-        return baseConductivity * Math.pow(0.5, level);\n-      }\n-    }\n-\n-    return baseConductivity;\n-  }\n-\n-  private getEffectiveHeatDissipation(cell: Cell): number {\n-    if (cell.structure !== StructureType.Ventilator && cell.structure !== StructureType.VoidCell) {\n-      return 0;\n-    }\n-\n-    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n-    let dissipation = baseStats.heatDissipation;\n-\n-    // Scale with tier for ventilators\n-    if (cell.structure === StructureType.Ventilator) {\n-      dissipation *= Math.pow(10, cell.tier - 1);\n-\n-      // Add upgrade bonus\n-      const level = this.state.upgrades.levels[UpgradeType.VentilatorDissipation];\n-      const definition = UPGRADE_DEFINITIONS[UpgradeType.VentilatorDissipation];\n-      dissipation += level * definition.improvementPerLevel;\n-    }\n-\n-    return dissipation;\n-  }\n-\n-  private getEffectivePowerSaleRate(cell: Cell): number {\n-    if (cell.structure !== StructureType.Substation) return 0;\n-\n-    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n-    let saleRate = baseStats.powerSaleRate;\n-\n-    // Scale with tier\n-    saleRate *= Math.pow(10, cell.tier - 1);\n-\n-    // Add upgrade bonus\n-    const level = this.state.upgrades.levels[UpgradeType.SubstationSaleRate];\n-    const definition = UPGRADE_DEFINITIONS[UpgradeType.SubstationSaleRate];\n-    saleRate += level * definition.improvementPerLevel;\n-\n-    return saleRate;\n+    this.upgradeManager.checkSecretUnlocks(stats);\n   }\n \n   // ==========================================================================\n-  // GAME TICK\n+  // GAME TICK (delegate to PhysicsEngine)\n   // ==========================================================================\n \n   tick(): void {\n-    this.state.stats.tickCount++;\n+    this.stats.tickCount++;\n \n-    // Phase 1: Heat generation (fuel rods with adjacency bonus)\n-    this.processHeatGeneration();\n+    // Run physics simulation\n+    const result = this.physicsEngine.tick();\n \n-    // Phase 2: Fuel depletion\n-    this.processFuelDepletion();\n+    // Sync stats from physics engine (single source of truth for physics-related stats)\n+    const physicsStats = this.physicsEngine.getStats();\n+    this.stats.totalPowerGenerated = physicsStats.totalPowerGenerated;\n+    this.stats.ticksAtHighHeat = physicsStats.ticksAtHighHeat;\n+    this.stats.fuelRodsDepleted = physicsStats.fuelRodsDepleted;\n \n-    // Phase 3: Heat transfer between cells\n-    this.processHeatTransfer();\n+    // Add money earned from power sales\n+    this.money += result.moneyEarned;\n+    this.stats.totalMoneyEarned += result.moneyEarned;\n \n-    // Phase 4: Heat dissipation (ventilators)\n-    this.processHeatDissipation();\n-\n-    // Phase 5: Power generation (turbines)\n-    this.processPowerGeneration();\n-\n-    // Phase 6: Power collection and sale (substations)\n-    this.processPowerSale();\n-\n-    // Phase 7: Check for overheating and meltdowns\n-    this.processOverheating();\n-\n-    // Phase 8: Track high heat survival\n-    this.trackHighHeatSurvival();\n-\n-    // Phase 9: Check secret unlocks\n+    // Check secret unlocks\n     this.checkSecretUnlocks();\n   }\n \n-  private processHeatGeneration(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-\n-        if (cell.structure !== StructureType.FuelRod) continue;\n-        if (cell.lifetime <= 0) continue; // Depleted fuel generates no heat\n-\n-        // Get base heat generation for this tier\n-        const upgradeLevel = this.state.upgrades.levels[UpgradeType.FuelHeatOutput];\n-        let heatGeneration = getFuelHeatGeneration(cell.tier, upgradeLevel);\n-\n-        // Adjacency bonus (4-way orthogonal)\n-        const adjacentFuelRods = this.countAdjacentFuelRods(x, y);\n-        const adjacencyMultiplier = 1 + (adjacentFuelRods * FUEL_ADJACENCY.BONUS_PER_ADJACENT);\n-        heatGeneration *= adjacencyMultiplier;\n-\n-        // Exotic fuel: heat scales with current temperature\n-        if (cell.isExotic) {\n-          const tempMultiplier = Math.min(\n-            EXOTIC_FUEL.MAX_MULTIPLIER,\n-            EXOTIC_FUEL.BASE_MULTIPLIER + (cell.heat / 1000) * EXOTIC_FUEL.HEAT_SCALING\n-          );\n-          heatGeneration *= tempMultiplier;\n-        }\n-\n-        cell.heat += heatGeneration;\n-      }\n-    }\n-  }\n-\n-  private processFuelDepletion(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-\n-        if (cell.structure !== StructureType.FuelRod) continue;\n-        if (cell.lifetime <= 0) continue;\n-\n-        cell.lifetime--;\n-\n-        if (cell.lifetime <= 0) {\n-          this.state.stats.fuelRodsDepleted++;\n-          this.emitEvent({\n-            type: 'fuel_depleted',\n-            x,\n-            y,\n-            tier: cell.tier,\n-          });\n-        }\n-      }\n-    }\n-  }\n-\n-  private processHeatTransfer(): void {\n-    const heatDeltas: number[][] = [];\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      heatDeltas.push(new Array(this.state.gridSize).fill(0));\n-    }\n-\n-    const transferRate = CORE_SETTINGS.BASE_HEAT_TRANSFER_RATE;\n-\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        const cellConductivity = this.getEffectiveConductivity(cell);\n-        const neighbors = this.getNeighbors(x, y);\n-\n-        for (const neighbor of neighbors) {\n-          const neighborConductivity = this.getEffectiveConductivity(neighbor);\n-          const heatDiff = cell.heat - neighbor.heat;\n-\n-          // Heat flows from hot to cold\n-          if (heatDiff > 0) {\n-            const conductivity = Math.min(cellConductivity, neighborConductivity);\n-            const transfer = heatDiff * transferRate * conductivity;\n-            heatDeltas[y][x] -= transfer;\n-            heatDeltas[neighbor.y][neighbor.x] += transfer;\n-          }\n-        }\n-\n-        // Edge cells lose heat to environment\n-        const edgeCount = 4 - neighbors.length;\n-        if (edgeCount > 0 && cell.heat > CORE_SETTINGS.AMBIENT_TEMPERATURE) {\n-          const heatAboveAmbient = cell.heat - CORE_SETTINGS.AMBIENT_TEMPERATURE;\n-          const envTransfer = heatAboveAmbient * CORE_SETTINGS.ENVIRONMENT_HEAT_TRANSFER_RATE * edgeCount;\n-          heatDeltas[y][x] -= envTransfer;\n-        }\n-      }\n-    }\n-\n-    // Apply deltas\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        this.state.grid[y][x].heat = Math.max(0, this.state.grid[y][x].heat + heatDeltas[y][x]);\n-      }\n-    }\n-  }\n-\n-  private processHeatDissipation(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        const dissipation = this.getEffectiveHeatDissipation(cell);\n-        cell.heat = Math.max(0, cell.heat - dissipation);\n-      }\n-    }\n-  }\n-\n-  private processPowerGeneration(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        if (cell.structure !== StructureType.Turbine) continue;\n-        if (cell.heat <= 0) continue;\n-\n-        const baseStats = STRUCTURE_BASE_STATS[StructureType.Turbine];\n-        const maxHeatConsumption = baseStats.maxHeatConsumption * Math.pow(10, cell.tier - 1);\n-        const powerGeneration = baseStats.powerGeneration;\n-\n-        const heatConsumed = Math.min(cell.heat, maxHeatConsumption);\n-        const powerGenerated = heatConsumed * powerGeneration;\n-\n-        cell.heat -= heatConsumed;\n-        cell.power += powerGenerated;\n-        this.state.stats.totalPowerGenerated += powerGenerated;\n-      }\n-    }\n-  }\n-\n-  private processPowerSale(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-\n-        // Turbines transfer power to nearby substations\n-        if (cell.structure === StructureType.Turbine && cell.power > 0) {\n-          const neighbors = this.getNeighbors(x, y);\n-          for (const neighbor of neighbors) {\n-            if (neighbor.structure === StructureType.Substation) {\n-              this.state.grid[neighbor.y][neighbor.x].power += cell.power;\n-              cell.power = 0;\n-              break;\n-            }\n-          }\n-        }\n-\n-        // Substations sell power\n-        if (cell.structure === StructureType.Substation && cell.power > 0) {\n-          const saleRate = this.getEffectivePowerSaleRate(cell);\n-          const powerToSell = Math.min(cell.power, saleRate);\n-          const earnings = powerToSell * ECONOMY.MONEY_PER_POWER;\n-\n-          this.state.money += earnings;\n-          this.state.stats.totalMoneyEarned += earnings;\n-          cell.power -= powerToSell;\n-\n-          if (earnings > 0) {\n-            this.emitEvent({\n-              type: 'power_sold',\n-              x,\n-              y,\n-              amount: earnings,\n-            });\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  private processOverheating(): void {\n-    let meltdown = false;\n-    const meltedCells: { x: number; y: number; structure: StructureType; tier: Tier }[] = [];\n-\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        if (cell.structure === StructureType.Empty) continue;\n-\n-        const meltTemp = this.getEffectiveMeltTemp(cell.structure);\n-        if (cell.heat > meltTemp) {\n-          if (cell.structure === StructureType.FuelRod) {\n-            // Fuel rod meltdown - catastrophic failure\n-            meltdown = true;\n-          } else {\n-            // Regular structure melts\n-            meltedCells.push({ x, y, structure: cell.structure, tier: cell.tier });\n-          }\n-        }\n-      }\n-    }\n-\n-    // Melt non-fuel structures\n-    for (const { x, y, structure, tier } of meltedCells) {\n-      this.state.grid[y][x] = this.createEmptyCell(x, y);\n-      this.emitEvent({\n-        type: 'structure_melted',\n-        x,\n-        y,\n-        structure,\n-        tier,\n-      });\n-    }\n-\n-    if (meltdown) {\n-      this.triggerMeltdown();\n-    }\n-  }\n-\n-  private triggerMeltdown(): void {\n-    this.state.stats.meltdownCount++;\n-\n-    // Destroy all structures but keep money\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        this.state.grid[y][x] = this.createEmptyCell(x, y);\n-      }\n-    }\n-\n-    this.emitEvent({ type: 'meltdown' });\n-\n-    // Check for exotic fuel unlock\n-    this.checkSecretUnlocks();\n-  }\n-\n-  private trackHighHeatSurvival(): void {\n-    // Check if any fuel rod is at >90% of its melt temp\n-    let hasHighHeatFuelRod = false;\n-\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        if (cell.structure !== StructureType.FuelRod) continue;\n-\n-        const meltTemp = this.getEffectiveMeltTemp(StructureType.FuelRod);\n-        if (cell.heat >= meltTemp * 0.9) {\n-          hasHighHeatFuelRod = true;\n-          break;\n-        }\n-      }\n-      if (hasHighHeatFuelRod) break;\n-    }\n-\n-    if (hasHighHeatFuelRod) {\n-      this.state.stats.ticksAtHighHeat++;\n-    }\n-  }\n-\n   // ==========================================================================\n   // SERIALIZATION\n   // ==========================================================================\n \n   serialize(): string {\n-    return JSON.stringify(this.state);\n+    const state: GameState = {\n+      grid: this.gridManager.getSnapshot(),\n+      gridSize: this.gridManager.getSize(),\n+      money: this.money,\n+      stats: { ...this.stats },\n+      upgrades: this.upgradeManager.getUpgradeState(),\n+      secrets: this.upgradeManager.getSecretState(),\n+    };\n+    return JSON.stringify(state);\n   }\n \n   static deserialize(data: string): HeatGame {\n     const state = JSON.parse(data) as GameState;\n     const game = new HeatGame(0);\n-    game.state = state;\n+\n+    // Restore grid\n+    game.gridManager.restoreFromState(state.grid, state.gridSize);\n+\n+    // Restore money and stats\n+    game.money = state.money;\n+    game.stats = { ...state.stats };\n+\n+    // Restore upgrades\n+    game.upgradeManager.restoreUpgradeState(state.upgrades);\n+    game.upgradeManager.restoreSecretState(state.secrets);\n+\n+    // Sync physics engine stats\n+    game.physicsEngine.setStats({\n+      totalPowerGenerated: state.stats.totalPowerGenerated,\n+      totalMoneyEarned: state.stats.totalMoneyEarned,\n+      fuelRodsDepleted: state.stats.fuelRodsDepleted,\n+      ticksAtHighHeat: state.stats.ticksAtHighHeat,\n+    });\n+\n     return game;\n   }\n \n   // ==========================================================================\n-  // BACKWARD COMPATIBILITY (for tests)\n+  // BACKWARD COMPATIBILITY\n   // ==========================================================================\n \n   /** @deprecated Use getGridSize() instead */\n   get GRID_SIZE(): number {\n-    return this.state.gridSize;\n+    return this.gridManager.getSize();\n   }\n }\n \n-// Re-export GRID_SIZE for backward compatibility\n+// Re-export for backward compatibility\n export { CORE_SETTINGS };\n export const GRID_SIZE = CORE_SETTINGS.INITIAL_GRID_SIZE;\ndiff --git a/src/game/PhysicsEngine.test.ts b/src/game/PhysicsEngine.test.ts\nnew file mode 100644\nindex 0000000..f49b67b\n--- /dev/null\n+++ b/src/game/PhysicsEngine.test.ts\n@@ -0,0 +1,460 @@\n+/**\n+ * Unit tests for PhysicsEngine\n+ *\n+ * Tests heat generation, transfer, dissipation, and power generation in isolation.\n+ */\n+\n+import { describe, it, expect, beforeEach, vi } from 'vitest';\n+import { GridManager } from './GridManager.js';\n+import { PhysicsEngine, PhysicsEvent } from './PhysicsEngine.js';\n+import { StructureType, Tier, UpgradeType, STRUCTURE_BASE_STATS, getFuelLifetime } from './BalanceConfig.js';\n+\n+describe('PhysicsEngine', () => {\n+  let gridManager: GridManager;\n+  let physicsEngine: PhysicsEngine;\n+  let upgradeLevels: Map<UpgradeType, number>;\n+\n+  const getUpgradeLevel = (type: UpgradeType) => upgradeLevels.get(type) ?? 0;\n+\n+  beforeEach(() => {\n+    gridManager = new GridManager(16);\n+    upgradeLevels = new Map();\n+    physicsEngine = new PhysicsEngine(gridManager, getUpgradeLevel);\n+  });\n+\n+  describe('heat generation', () => {\n+    it('should generate heat from active fuel rods', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.tier = Tier.T1;\n+      cell.lifetime = 100;\n+\n+      physicsEngine.processHeatGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeGreaterThan(0);\n+    });\n+\n+    it('should not generate heat from depleted fuel rods', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.tier = Tier.T1;\n+      cell.lifetime = 0; // depleted\n+\n+      physicsEngine.processHeatGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBe(0);\n+    });\n+\n+    it('should apply adjacency bonus for neighboring fuel rods', () => {\n+      // Place center fuel rod\n+      const center = gridManager.getCellRef(5, 5)!;\n+      center.structure = StructureType.FuelRod;\n+      center.tier = Tier.T1;\n+      center.lifetime = 100;\n+\n+      // Get baseline heat generation\n+      physicsEngine.processHeatGeneration();\n+      const baseHeat = gridManager.getCell(5, 5)!.heat;\n+\n+      // Reset and add adjacent fuel rod\n+      gridManager.getCellRef(5, 5)!.heat = 0;\n+      const adjacent = gridManager.getCellRef(5, 4)!;\n+      adjacent.structure = StructureType.FuelRod;\n+      adjacent.tier = Tier.T1;\n+      adjacent.lifetime = 100;\n+\n+      physicsEngine.processHeatGeneration();\n+      const boostedHeat = gridManager.getCell(5, 5)!.heat;\n+\n+      expect(boostedHeat).toBeGreaterThan(baseHeat);\n+    });\n+\n+    it('should generate more heat for higher tiers', () => {\n+      const cell1 = gridManager.getCellRef(3, 3)!;\n+      cell1.structure = StructureType.FuelRod;\n+      cell1.tier = Tier.T1;\n+      cell1.lifetime = 100;\n+\n+      const cell2 = gridManager.getCellRef(8, 8)!;\n+      cell2.structure = StructureType.FuelRod;\n+      cell2.tier = Tier.T2;\n+      cell2.lifetime = 100;\n+\n+      physicsEngine.processHeatGeneration();\n+\n+      expect(gridManager.getCell(8, 8)!.heat).toBeGreaterThan(gridManager.getCell(3, 3)!.heat);\n+    });\n+  });\n+\n+  describe('fuel depletion', () => {\n+    it('should decrease fuel lifetime each tick', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 100;\n+\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(gridManager.getCell(5, 5)!.lifetime).toBe(99);\n+    });\n+\n+    it('should emit event when fuel is depleted', () => {\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(events).toHaveLength(1);\n+      expect(events[0].type).toBe('fuel_depleted');\n+      expect(events[0].x).toBe(5);\n+      expect(events[0].y).toBe(5);\n+    });\n+\n+    it('should track depleted fuel rods in stats', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(physicsEngine.getStats().fuelRodsDepleted).toBe(1);\n+    });\n+  });\n+\n+  describe('heat transfer', () => {\n+    it('should transfer heat from hot to cold cells', () => {\n+      const hotCell = gridManager.getCellRef(5, 5)!;\n+      hotCell.heat = 1000;\n+\n+      const coldCell = gridManager.getCellRef(5, 6)!;\n+      coldCell.heat = 0;\n+\n+      physicsEngine.processHeatTransfer();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeLessThan(1000);\n+      expect(gridManager.getCell(5, 6)!.heat).toBeGreaterThan(0);\n+    });\n+\n+    it('should respect conductivity differences', () => {\n+      // Place insulator (low conductivity) and regular cell\n+      const insulator = gridManager.getCellRef(5, 5)!;\n+      insulator.structure = StructureType.Insulator;\n+      insulator.heat = 1000;\n+\n+      physicsEngine.processHeatTransfer();\n+      const insulatorHeatAfter = gridManager.getCell(5, 5)!.heat;\n+\n+      // Compare with empty cell\n+      gridManager.getCellRef(5, 5)!.structure = StructureType.Empty;\n+      gridManager.getCellRef(5, 5)!.heat = 1000;\n+\n+      physicsEngine.processHeatTransfer();\n+      const emptyHeatAfter = gridManager.getCell(5, 5)!.heat;\n+\n+      // Insulator should retain more heat due to low conductivity\n+      expect(insulatorHeatAfter).toBeGreaterThan(emptyHeatAfter);\n+    });\n+\n+    it('should lose heat to environment at edges', () => {\n+      // Place heat at corner (2 edges exposed)\n+      const corner = gridManager.getCellRef(0, 0)!;\n+      corner.heat = 1000;\n+\n+      physicsEngine.processHeatTransfer();\n+\n+      expect(gridManager.getCell(0, 0)!.heat).toBeLessThan(1000);\n+    });\n+  });\n+\n+  describe('heat dissipation', () => {\n+    it('should dissipate heat from ventilators', () => {\n+      const vent = gridManager.getCellRef(5, 5)!;\n+      vent.structure = StructureType.Ventilator;\n+      vent.tier = Tier.T1;\n+      vent.heat = 100;\n+\n+      physicsEngine.processHeatDissipation();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeLessThan(100);\n+    });\n+\n+    it('should not go below zero heat', () => {\n+      const vent = gridManager.getCellRef(5, 5)!;\n+      vent.structure = StructureType.Ventilator;\n+      vent.tier = Tier.T1;\n+      vent.heat = 1; // Very low heat\n+\n+      physicsEngine.processHeatDissipation();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeGreaterThanOrEqual(0);\n+    });\n+\n+    it('should dissipate more heat for higher tier ventilators', () => {\n+      const vent1 = gridManager.getCellRef(3, 3)!;\n+      vent1.structure = StructureType.Ventilator;\n+      vent1.tier = Tier.T1;\n+      vent1.heat = 500;\n+\n+      const vent2 = gridManager.getCellRef(8, 8)!;\n+      vent2.structure = StructureType.Ventilator;\n+      vent2.tier = Tier.T2;\n+      vent2.heat = 500;\n+\n+      physicsEngine.processHeatDissipation();\n+\n+      // T2 should dissipate more, leaving less heat\n+      expect(gridManager.getCell(8, 8)!.heat).toBeLessThan(gridManager.getCell(3, 3)!.heat);\n+    });\n+  });\n+\n+  describe('power generation', () => {\n+    it('should generate power from turbines with heat', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = 100;\n+\n+      physicsEngine.processPowerGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.power).toBeGreaterThan(0);\n+      expect(gridManager.getCell(5, 5)!.heat).toBeLessThan(100);\n+    });\n+\n+    it('should not generate power without heat', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = 0;\n+\n+      physicsEngine.processPowerGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.power).toBe(0);\n+    });\n+\n+    it('should track total power generated in stats', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = 100;\n+\n+      physicsEngine.processPowerGeneration();\n+\n+      expect(physicsEngine.getStats().totalPowerGenerated).toBeGreaterThan(0);\n+    });\n+  });\n+\n+  describe('power sale', () => {\n+    it('should transfer power from turbine to adjacent substation', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.power = 100;\n+\n+      const substation = gridManager.getCellRef(5, 6)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+\n+      physicsEngine.processPowerSale();\n+\n+      // Turbine should have transferred power\n+      expect(gridManager.getCell(5, 5)!.power).toBe(0);\n+      // Substation receives power but also sells some (saleRate applies)\n+      // Just verify it received the power (it may sell some immediately)\n+      expect(physicsEngine.getStats().totalMoneyEarned).toBeGreaterThan(0);\n+    });\n+\n+    it('should sell power from substations and return earnings', () => {\n+      const substation = gridManager.getCellRef(5, 5)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+      substation.power = 100;\n+\n+      const earnings = physicsEngine.processPowerSale();\n+\n+      expect(earnings).toBeGreaterThan(0);\n+      expect(gridManager.getCell(5, 5)!.power).toBeLessThan(100);\n+    });\n+\n+    it('should emit power_sold event', () => {\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      const substation = gridManager.getCellRef(5, 5)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+      substation.power = 100;\n+\n+      physicsEngine.processPowerSale();\n+\n+      expect(events.some(e => e.type === 'power_sold')).toBe(true);\n+    });\n+  });\n+\n+  describe('overheating', () => {\n+    it('should melt structures that exceed melt temperature', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = STRUCTURE_BASE_STATS[StructureType.Turbine].meltTemp + 100;\n+\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      physicsEngine.processOverheating();\n+\n+      expect(gridManager.getCell(5, 5)!.structure).toBe(StructureType.Empty);\n+      expect(events.some(e => e.type === 'structure_melted')).toBe(true);\n+    });\n+\n+    it('should trigger meltdown when fuel rod overheats', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp + 100;\n+\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      const meltdown = physicsEngine.processOverheating();\n+\n+      expect(meltdown).toBe(true);\n+      expect(events.some(e => e.type === 'meltdown')).toBe(true);\n+    });\n+\n+    it('should clear entire grid on meltdown', () => {\n+      // Place some structures\n+      gridManager.getCellRef(3, 3)!.structure = StructureType.Turbine;\n+      gridManager.getCellRef(8, 8)!.structure = StructureType.Ventilator;\n+\n+      // Trigger meltdown\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp + 100;\n+\n+      physicsEngine.processOverheating();\n+\n+      expect(gridManager.getFilledCellCount()).toBe(0);\n+    });\n+  });\n+\n+  describe('high heat tracking', () => {\n+    it('should track ticks at high heat', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      // Set heat to 90% of melt temp\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp * 0.91;\n+\n+      physicsEngine.trackHighHeatSurvival();\n+\n+      expect(physicsEngine.getStats().ticksAtHighHeat).toBe(1);\n+    });\n+\n+    it('should not track when below 90% melt temp', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp * 0.5;\n+\n+      physicsEngine.trackHighHeatSurvival();\n+\n+      expect(physicsEngine.getStats().ticksAtHighHeat).toBe(0);\n+    });\n+  });\n+\n+  describe('effective stats with upgrades', () => {\n+    it('should increase melt temp with upgrades', () => {\n+      const baseMeltTemp = physicsEngine.getEffectiveMeltTemp(StructureType.FuelRod);\n+\n+      upgradeLevels.set(UpgradeType.MeltTempFuelRod, 3);\n+      const upgradedMeltTemp = physicsEngine.getEffectiveMeltTemp(StructureType.FuelRod);\n+\n+      expect(upgradedMeltTemp).toBeGreaterThan(baseMeltTemp);\n+    });\n+\n+    it('should increase turbine conductivity with upgrades', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+\n+      const baseConductivity = physicsEngine.getEffectiveConductivity(turbine);\n+\n+      upgradeLevels.set(UpgradeType.TurbineConductivity, 2);\n+      const upgradedConductivity = physicsEngine.getEffectiveConductivity(turbine);\n+\n+      expect(upgradedConductivity).toBeGreaterThan(baseConductivity);\n+    });\n+\n+    it('should decrease insulator conductivity with upgrades', () => {\n+      const insulator = gridManager.getCellRef(5, 5)!;\n+      insulator.structure = StructureType.Insulator;\n+\n+      const baseConductivity = physicsEngine.getEffectiveConductivity(insulator);\n+\n+      upgradeLevels.set(UpgradeType.InsulatorConductivity, 2);\n+      const upgradedConductivity = physicsEngine.getEffectiveConductivity(insulator);\n+\n+      expect(upgradedConductivity).toBeLessThan(baseConductivity);\n+    });\n+  });\n+\n+  describe('tick', () => {\n+    it('should run all physics phases', () => {\n+      // Set up a simple reactor\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      fuelRod.lifetime = 100;\n+\n+      const turbine = gridManager.getCellRef(5, 6)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+\n+      const substation = gridManager.getCellRef(5, 7)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+\n+      const result = physicsEngine.tick();\n+\n+      expect(result.moneyEarned).toBeGreaterThanOrEqual(0);\n+      expect(result.meltdown).toBe(false);\n+    });\n+\n+    it('should report meltdown in tick result', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.lifetime = 100; // Active fuel rod\n+      // Set very high heat to ensure it still exceeds meltTemp after heat transfer/dissipation\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp * 2;\n+\n+      const result = physicsEngine.tick();\n+\n+      expect(result.meltdown).toBe(true);\n+    });\n+  });\n+\n+  describe('event listeners', () => {\n+    it('should allow adding and removing listeners', () => {\n+      const events: PhysicsEvent[] = [];\n+      const listener = (e: PhysicsEvent) => events.push(e);\n+\n+      physicsEngine.addEventListener(listener);\n+\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+\n+      physicsEngine.processFuelDepletion();\n+      expect(events).toHaveLength(1);\n+\n+      physicsEngine.removeEventListener(listener);\n+\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(events).toHaveLength(1); // No new events\n+    });\n+  });\n+});\ndiff --git a/src/game/PhysicsEngine.ts b/src/game/PhysicsEngine.ts\nnew file mode 100644\nindex 0000000..ef4c504\n--- /dev/null\n+++ b/src/game/PhysicsEngine.ts\n@@ -0,0 +1,483 @@\n+/**\n+ * PhysicsEngine - Handles heat generation, transfer, dissipation, and power generation\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ * This class is responsible for all physics simulation logic.\n+ */\n+\n+import {\n+  CORE_SETTINGS,\n+  StructureType,\n+  Tier,\n+  STRUCTURE_BASE_STATS,\n+  FUEL_ADJACENCY,\n+  ECONOMY,\n+  UpgradeType,\n+  UPGRADE_DEFINITIONS,\n+  EXOTIC_FUEL,\n+  getFuelHeatGeneration,\n+} from './BalanceConfig.js';\n+import { Cell, GridManager } from './GridManager.js';\n+\n+export interface PhysicsEvent {\n+  type: 'fuel_depleted' | 'power_sold' | 'structure_melted' | 'meltdown';\n+  x?: number;\n+  y?: number;\n+  tier?: Tier;\n+  structure?: StructureType;\n+  amount?: number;\n+}\n+\n+export type PhysicsEventListener = (event: PhysicsEvent) => void;\n+\n+export interface UpgradeLevels {\n+  [key: string]: number;\n+}\n+\n+export interface PhysicsStats {\n+  totalPowerGenerated: number;\n+  totalMoneyEarned: number;\n+  fuelRodsDepleted: number;\n+  ticksAtHighHeat: number;\n+}\n+\n+/**\n+ * PhysicsEngine handles all physics simulation for the heat game.\n+ * It operates on a GridManager and uses upgrade levels for calculations.\n+ */\n+export class PhysicsEngine {\n+  private eventListeners: PhysicsEventListener[] = [];\n+  private stats: PhysicsStats = {\n+    totalPowerGenerated: 0,\n+    totalMoneyEarned: 0,\n+    fuelRodsDepleted: 0,\n+    ticksAtHighHeat: 0,\n+  };\n+\n+  constructor(\n+    private gridManager: GridManager,\n+    private getUpgradeLevel: (type: UpgradeType) => number\n+  ) {}\n+\n+  /**\n+   * Add an event listener for physics events\n+   */\n+  addEventListener(listener: PhysicsEventListener): void {\n+    this.eventListeners.push(listener);\n+  }\n+\n+  /**\n+   * Remove an event listener\n+   */\n+  removeEventListener(listener: PhysicsEventListener): void {\n+    const index = this.eventListeners.indexOf(listener);\n+    if (index !== -1) {\n+      this.eventListeners.splice(index, 1);\n+    }\n+  }\n+\n+  private emitEvent(event: PhysicsEvent): void {\n+    for (const listener of this.eventListeners) {\n+      listener(event);\n+    }\n+  }\n+\n+  /**\n+   * Get the current physics stats\n+   */\n+  getStats(): PhysicsStats {\n+    return { ...this.stats };\n+  }\n+\n+  /**\n+   * Reset stats (used after deserialization)\n+   */\n+  setStats(stats: PhysicsStats): void {\n+    this.stats = { ...stats };\n+  }\n+\n+  /**\n+   * Get effective melt temperature for a structure type (with upgrades)\n+   */\n+  getEffectiveMeltTemp(structure: StructureType): number {\n+    const baseTemp = STRUCTURE_BASE_STATS[structure].meltTemp;\n+\n+    let upgradeType: UpgradeType | null = null;\n+    switch (structure) {\n+      case StructureType.FuelRod: upgradeType = UpgradeType.MeltTempFuelRod; break;\n+      case StructureType.Ventilator: upgradeType = UpgradeType.MeltTempVentilator; break;\n+      case StructureType.HeatExchanger: upgradeType = UpgradeType.MeltTempHeatExchanger; break;\n+      case StructureType.Insulator: upgradeType = UpgradeType.MeltTempInsulator; break;\n+      case StructureType.Turbine: upgradeType = UpgradeType.MeltTempTurbine; break;\n+      case StructureType.Substation: upgradeType = UpgradeType.MeltTempSubstation; break;\n+    }\n+\n+    if (upgradeType) {\n+      const level = this.getUpgradeLevel(upgradeType);\n+      const definition = UPGRADE_DEFINITIONS[upgradeType];\n+      return baseTemp + (level * definition.improvementPerLevel);\n+    }\n+\n+    return baseTemp;\n+  }\n+\n+  /**\n+   * Get effective conductivity for a cell (with upgrades)\n+   */\n+  getEffectiveConductivity(cell: Cell): number {\n+    const baseConductivity = STRUCTURE_BASE_STATS[cell.structure].conductivity;\n+\n+    if (cell.structure === StructureType.Turbine) {\n+      const level = this.getUpgradeLevel(UpgradeType.TurbineConductivity);\n+      const definition = UPGRADE_DEFINITIONS[UpgradeType.TurbineConductivity];\n+      return baseConductivity + (level * definition.improvementPerLevel);\n+    }\n+\n+    if (cell.structure === StructureType.Insulator) {\n+      const level = this.getUpgradeLevel(UpgradeType.InsulatorConductivity);\n+      if (level > 0) {\n+        return baseConductivity * Math.pow(0.5, level);\n+      }\n+    }\n+\n+    return baseConductivity;\n+  }\n+\n+  /**\n+   * Get effective heat dissipation for a cell (with upgrades)\n+   */\n+  getEffectiveHeatDissipation(cell: Cell): number {\n+    if (cell.structure !== StructureType.Ventilator && cell.structure !== StructureType.VoidCell) {\n+      return 0;\n+    }\n+\n+    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n+    let dissipation = baseStats.heatDissipation;\n+\n+    if (cell.structure === StructureType.Ventilator) {\n+      dissipation *= Math.pow(10, cell.tier - 1);\n+\n+      const level = this.getUpgradeLevel(UpgradeType.VentilatorDissipation);\n+      const definition = UPGRADE_DEFINITIONS[UpgradeType.VentilatorDissipation];\n+      dissipation += level * definition.improvementPerLevel;\n+    }\n+\n+    return dissipation;\n+  }\n+\n+  /**\n+   * Get effective power sale rate for a cell (with upgrades)\n+   */\n+  getEffectivePowerSaleRate(cell: Cell): number {\n+    if (cell.structure !== StructureType.Substation) return 0;\n+\n+    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n+    let saleRate = baseStats.powerSaleRate;\n+\n+    saleRate *= Math.pow(10, cell.tier - 1);\n+\n+    const level = this.getUpgradeLevel(UpgradeType.SubstationSaleRate);\n+    const definition = UPGRADE_DEFINITIONS[UpgradeType.SubstationSaleRate];\n+    saleRate += level * definition.improvementPerLevel;\n+\n+    return saleRate;\n+  }\n+\n+  /**\n+   * Process heat generation from fuel rods\n+   */\n+  processHeatGeneration(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+        if (cell.lifetime <= 0) continue;\n+\n+        const upgradeLevel = this.getUpgradeLevel(UpgradeType.FuelHeatOutput);\n+        let heatGeneration = getFuelHeatGeneration(cell.tier, upgradeLevel);\n+\n+        // Adjacency bonus\n+        const adjacentFuelRods = this.gridManager.countAdjacentFuelRods(x, y);\n+        const adjacencyMultiplier = 1 + (adjacentFuelRods * FUEL_ADJACENCY.BONUS_PER_ADJACENT);\n+        heatGeneration *= adjacencyMultiplier;\n+\n+        // Exotic fuel scaling\n+        if (cell.isExotic) {\n+          const tempMultiplier = Math.min(\n+            EXOTIC_FUEL.MAX_MULTIPLIER,\n+            EXOTIC_FUEL.BASE_MULTIPLIER + (cell.heat / 1000) * EXOTIC_FUEL.HEAT_SCALING\n+          );\n+          heatGeneration *= tempMultiplier;\n+        }\n+\n+        cell.heat += heatGeneration;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process fuel depletion\n+   */\n+  processFuelDepletion(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+        if (cell.lifetime <= 0) continue;\n+\n+        cell.lifetime--;\n+\n+        if (cell.lifetime <= 0) {\n+          this.stats.fuelRodsDepleted++;\n+          this.emitEvent({\n+            type: 'fuel_depleted',\n+            x,\n+            y,\n+            tier: cell.tier,\n+          });\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process heat transfer between cells\n+   */\n+  processHeatTransfer(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    const heatDeltas: number[][] = [];\n+    for (let y = 0; y < gridSize; y++) {\n+      heatDeltas.push(new Array(gridSize).fill(0));\n+    }\n+\n+    const transferRate = CORE_SETTINGS.BASE_HEAT_TRANSFER_RATE;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        const cellConductivity = this.getEffectiveConductivity(cell);\n+        const neighbors = this.gridManager.getNeighbors(x, y);\n+\n+        for (const neighbor of neighbors) {\n+          const neighborConductivity = this.getEffectiveConductivity(neighbor);\n+          const heatDiff = cell.heat - neighbor.heat;\n+\n+          if (heatDiff > 0) {\n+            const conductivity = Math.min(cellConductivity, neighborConductivity);\n+            const transfer = heatDiff * transferRate * conductivity;\n+            heatDeltas[y][x] -= transfer;\n+            heatDeltas[neighbor.y][neighbor.x] += transfer;\n+          }\n+        }\n+\n+        // Edge cells lose heat to environment\n+        const edgeCount = 4 - neighbors.length;\n+        if (edgeCount > 0 && cell.heat > CORE_SETTINGS.AMBIENT_TEMPERATURE) {\n+          const heatAboveAmbient = cell.heat - CORE_SETTINGS.AMBIENT_TEMPERATURE;\n+          const envTransfer = heatAboveAmbient * CORE_SETTINGS.ENVIRONMENT_HEAT_TRANSFER_RATE * edgeCount;\n+          heatDeltas[y][x] -= envTransfer;\n+        }\n+      }\n+    }\n+\n+    // Apply deltas\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        grid[y][x].heat = Math.max(0, grid[y][x].heat + heatDeltas[y][x]);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process heat dissipation (ventilators and void cells)\n+   */\n+  processHeatDissipation(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        const dissipation = this.getEffectiveHeatDissipation(cell);\n+        cell.heat = Math.max(0, cell.heat - dissipation);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process power generation (turbines)\n+   */\n+  processPowerGeneration(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure !== StructureType.Turbine) continue;\n+        if (cell.heat <= 0) continue;\n+\n+        const baseStats = STRUCTURE_BASE_STATS[StructureType.Turbine];\n+        const maxHeatConsumption = baseStats.maxHeatConsumption * Math.pow(10, cell.tier - 1);\n+        const powerGeneration = baseStats.powerGeneration;\n+\n+        const heatConsumed = Math.min(cell.heat, maxHeatConsumption);\n+        const powerGenerated = heatConsumed * powerGeneration;\n+\n+        cell.heat -= heatConsumed;\n+        cell.power += powerGenerated;\n+        this.stats.totalPowerGenerated += powerGenerated;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process power sale (substations)\n+   * Returns the amount of money earned\n+   */\n+  processPowerSale(): number {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let totalEarnings = 0;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        // Turbines transfer power to nearby substations\n+        if (cell.structure === StructureType.Turbine && cell.power > 0) {\n+          const neighbors = this.gridManager.getNeighbors(x, y);\n+          for (const neighbor of neighbors) {\n+            if (neighbor.structure === StructureType.Substation) {\n+              grid[neighbor.y][neighbor.x].power += cell.power;\n+              cell.power = 0;\n+              break;\n+            }\n+          }\n+        }\n+\n+        // Substations sell power\n+        if (cell.structure === StructureType.Substation && cell.power > 0) {\n+          const saleRate = this.getEffectivePowerSaleRate(cell);\n+          const powerToSell = Math.min(cell.power, saleRate);\n+          const earnings = powerToSell * ECONOMY.MONEY_PER_POWER;\n+\n+          totalEarnings += earnings;\n+          this.stats.totalMoneyEarned += earnings;\n+          cell.power -= powerToSell;\n+\n+          if (earnings > 0) {\n+            this.emitEvent({\n+              type: 'power_sold',\n+              x,\n+              y,\n+              amount: earnings,\n+            });\n+          }\n+        }\n+      }\n+    }\n+\n+    return totalEarnings;\n+  }\n+\n+  /**\n+   * Process overheating and meltdowns\n+   * Returns true if a meltdown occurred\n+   */\n+  processOverheating(): boolean {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let meltdown = false;\n+    const meltedCells: { x: number; y: number; structure: StructureType; tier: Tier }[] = [];\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure === StructureType.Empty) continue;\n+\n+        const meltTemp = this.getEffectiveMeltTemp(cell.structure);\n+        if (cell.heat > meltTemp) {\n+          if (cell.structure === StructureType.FuelRod) {\n+            meltdown = true;\n+          } else {\n+            meltedCells.push({ x, y, structure: cell.structure, tier: cell.tier });\n+          }\n+        }\n+      }\n+    }\n+\n+    // Melt non-fuel structures\n+    for (const { x, y, structure, tier } of meltedCells) {\n+      this.gridManager.resetCell(x, y);\n+      this.emitEvent({\n+        type: 'structure_melted',\n+        x,\n+        y,\n+        structure,\n+        tier,\n+      });\n+    }\n+\n+    if (meltdown) {\n+      this.gridManager.clearAll();\n+      this.emitEvent({ type: 'meltdown' });\n+    }\n+\n+    return meltdown;\n+  }\n+\n+  /**\n+   * Track high heat survival (for secret unlock)\n+   */\n+  trackHighHeatSurvival(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let hasHighHeatFuelRod = false;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+\n+        const meltTemp = this.getEffectiveMeltTemp(StructureType.FuelRod);\n+        if (cell.heat >= meltTemp * 0.9) {\n+          hasHighHeatFuelRod = true;\n+          break;\n+        }\n+      }\n+      if (hasHighHeatFuelRod) break;\n+    }\n+\n+    if (hasHighHeatFuelRod) {\n+      this.stats.ticksAtHighHeat++;\n+    }\n+  }\n+\n+  /**\n+   * Run a complete physics tick\n+   * Returns the money earned from power sales\n+   */\n+  tick(): { moneyEarned: number; meltdown: boolean } {\n+    this.processHeatGeneration();\n+    this.processFuelDepletion();\n+    this.processHeatTransfer();\n+    this.processHeatDissipation();\n+    this.processPowerGeneration();\n+    const moneyEarned = this.processPowerSale();\n+    const meltdown = this.processOverheating();\n+    this.trackHighHeatSurvival();\n+\n+    return { moneyEarned, meltdown };\n+  }\n+}\ndiff --git a/src/game/UpgradeManager.test.ts b/src/game/UpgradeManager.test.ts\nnew file mode 100644\nindex 0000000..a6d3f1a\n--- /dev/null\n+++ b/src/game/UpgradeManager.test.ts\n@@ -0,0 +1,318 @@\n+/**\n+ * Unit tests for UpgradeManager\n+ *\n+ * Tests upgrade purchasing, secret unlocking, and toggle states in isolation.\n+ */\n+\n+import { describe, it, expect, beforeEach } from 'vitest';\n+import { UpgradeManager, UpgradeEvent } from './UpgradeManager.js';\n+import { UpgradeType, SecretUpgradeType, UPGRADE_DEFINITIONS, SECRET_UPGRADE_DEFINITIONS } from './BalanceConfig.js';\n+\n+describe('UpgradeManager', () => {\n+  let upgradeManager: UpgradeManager;\n+\n+  beforeEach(() => {\n+    upgradeManager = new UpgradeManager();\n+  });\n+\n+  describe('initialization', () => {\n+    it('should start with all upgrades at level 0', () => {\n+      for (const type of Object.values(UpgradeType)) {\n+        expect(upgradeManager.getUpgradeLevel(type)).toBe(0);\n+      }\n+    });\n+\n+    it('should start with all secrets locked', () => {\n+      for (const type of Object.values(SecretUpgradeType)) {\n+        expect(upgradeManager.isSecretUnlocked(type)).toBe(false);\n+        expect(upgradeManager.isSecretPurchased(type)).toBe(false);\n+        expect(upgradeManager.isSecretEnabled(type)).toBe(false);\n+      }\n+    });\n+  });\n+\n+  describe('regular upgrades', () => {\n+    it('should return correct upgrade cost', () => {\n+      const cost = upgradeManager.getUpgradeCost(UpgradeType.FuelHeatOutput);\n+      expect(cost).toBeGreaterThan(0);\n+    });\n+\n+    it('should allow purchasing upgrades with enough money', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+      const cost = upgradeManager.getUpgradeCost(type);\n+\n+      expect(upgradeManager.canPurchaseUpgrade(type, cost)).toBe(true);\n+      expect(upgradeManager.canPurchaseUpgrade(type, cost - 1)).toBe(false);\n+    });\n+\n+    it('should increase level on purchase', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+      const cost = upgradeManager.getUpgradeCost(type);\n+\n+      const spent = upgradeManager.purchaseUpgrade(type, cost);\n+\n+      expect(spent).toBe(cost);\n+      expect(upgradeManager.getUpgradeLevel(type)).toBe(1);\n+    });\n+\n+    it('should return 0 if purchase fails', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+\n+      const spent = upgradeManager.purchaseUpgrade(type, 0);\n+\n+      expect(spent).toBe(0);\n+      expect(upgradeManager.getUpgradeLevel(type)).toBe(0);\n+    });\n+\n+    it('should increase cost after each purchase', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+      const initialCost = upgradeManager.getUpgradeCost(type);\n+\n+      upgradeManager.purchaseUpgrade(type, 1000000);\n+\n+      const newCost = upgradeManager.getUpgradeCost(type);\n+      expect(newCost).toBeGreaterThan(initialCost);\n+    });\n+\n+    it('should respect max level', () => {\n+      // TurbineConductivity has maxLevel: 10\n+      const type = UpgradeType.TurbineConductivity;\n+      const maxLevel = UPGRADE_DEFINITIONS[type].maxLevel;\n+\n+      // Purchase up to max level\n+      for (let i = 0; i < maxLevel; i++) {\n+        upgradeManager.purchaseUpgrade(type, 1000000000);\n+      }\n+\n+      expect(upgradeManager.getUpgradeLevel(type)).toBe(maxLevel);\n+      expect(upgradeManager.canPurchaseUpgrade(type, 1000000000)).toBe(false);\n+    });\n+\n+    it('should emit event on purchase', () => {\n+      const events: UpgradeEvent[] = [];\n+      upgradeManager.addEventListener(e => events.push(e));\n+\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+\n+      expect(events).toHaveLength(1);\n+      expect(events[0].type).toBe('upgrade_purchased');\n+      expect(events[0].upgradeType).toBe(UpgradeType.FuelHeatOutput);\n+    });\n+  });\n+\n+  describe('secret upgrades', () => {\n+    it('should return correct secret cost', () => {\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.Salvage);\n+      expect(cost).toBe(SECRET_UPGRADE_DEFINITIONS[SecretUpgradeType.Salvage].cost);\n+    });\n+\n+    it('should not allow purchasing locked secrets', () => {\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.Salvage, 1000000)).toBe(false);\n+    });\n+\n+    it('should not allow purchasing already purchased secrets', () => {\n+      // ExoticFuel requires 1 meltdown to unlock\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.ExoticFuel);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, cost);\n+\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.ExoticFuel, 1000000)).toBe(false);\n+    });\n+\n+    it('should unlock secrets based on stats', () => {\n+      // ExoticFuel requires 1 meltdown\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+\n+      const unlocked = upgradeManager.checkSecretUnlocks(stats);\n+\n+      expect(unlocked).toContain(SecretUpgradeType.ExoticFuel);\n+      expect(upgradeManager.isSecretUnlocked(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should emit event on secret unlock', () => {\n+      const events: UpgradeEvent[] = [];\n+      upgradeManager.addEventListener(e => events.push(e));\n+\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      expect(events.some(e => e.type === 'secret_unlocked')).toBe(true);\n+    });\n+\n+    it('should allow purchasing unlocked secrets with enough money', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.ExoticFuel);\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.ExoticFuel, cost)).toBe(true);\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.ExoticFuel, cost - 1)).toBe(false);\n+    });\n+\n+    it('should mark secret as purchased after buying', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.ExoticFuel);\n+      const spent = upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, cost);\n+\n+      expect(spent).toBe(cost);\n+      expect(upgradeManager.isSecretPurchased(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should emit event on secret purchase', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const events: UpgradeEvent[] = [];\n+      upgradeManager.addEventListener(e => events.push(e));\n+\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      expect(events.some(e => e.type === 'secret_purchased')).toBe(true);\n+    });\n+  });\n+\n+  describe('toggleable secrets', () => {\n+    it('should auto-enable toggleable secrets on purchase', () => {\n+      // Exotic fuel is toggleable, requires 1 meltdown\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should allow toggling purchased toggleable secrets', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.ExoticFuel, false);\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(false);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.ExoticFuel, true);\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should not toggle unpurchased secrets', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.ExoticFuel, true);\n+\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(false);\n+    });\n+\n+    it('should not toggle non-toggleable secrets', () => {\n+      // Salvage requires 100 demolishes and is not toggleable\n+      const stats = { meltdownCount: 0, filledCells: 0, totalMoneyEarned: 0, demolishCount: 100, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.Salvage, 1000000);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.Salvage, true);\n+\n+      // Salvage is not toggleable, so enabled should remain false\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.Salvage)).toBe(false);\n+    });\n+  });\n+\n+  describe('reactor expansion', () => {\n+    it('should return correct expansion size for reactor expansions', () => {\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion1)).toBe(17);\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion2)).toBe(18);\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion3)).toBe(19);\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion4)).toBe(20);\n+    });\n+\n+    it('should return null for non-expansion secrets', () => {\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.Salvage)).toBeNull();\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ExoticFuel)).toBeNull();\n+    });\n+  });\n+\n+  describe('serialization', () => {\n+    it('should get upgrade state for serialization', () => {\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+\n+      const state = upgradeManager.getUpgradeState();\n+\n+      expect(state.levels[UpgradeType.FuelHeatOutput]).toBe(2);\n+    });\n+\n+    it('should get secret state for serialization', () => {\n+      // ExoticFuel requires 1 meltdown\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      const state = upgradeManager.getSecretState();\n+\n+      expect(state.unlocked[SecretUpgradeType.ExoticFuel]).toBe(true);\n+      expect(state.purchased[SecretUpgradeType.ExoticFuel]).toBe(true);\n+    });\n+\n+    it('should restore upgrade state from serialization', () => {\n+      const state = upgradeManager.getUpgradeState();\n+      state.levels[UpgradeType.FuelHeatOutput] = 5;\n+\n+      const newManager = new UpgradeManager();\n+      newManager.restoreUpgradeState(state);\n+\n+      expect(newManager.getUpgradeLevel(UpgradeType.FuelHeatOutput)).toBe(5);\n+    });\n+\n+    it('should restore secret state from serialization', () => {\n+      const state = upgradeManager.getSecretState();\n+      state.unlocked[SecretUpgradeType.Salvage] = true;\n+      state.purchased[SecretUpgradeType.Salvage] = true;\n+\n+      const newManager = new UpgradeManager();\n+      newManager.restoreSecretState(state);\n+\n+      expect(newManager.isSecretUnlocked(SecretUpgradeType.Salvage)).toBe(true);\n+      expect(newManager.isSecretPurchased(SecretUpgradeType.Salvage)).toBe(true);\n+    });\n+  });\n+\n+  describe('event listeners', () => {\n+    it('should allow adding and removing listeners', () => {\n+      const events: UpgradeEvent[] = [];\n+      const listener = (e: UpgradeEvent) => events.push(e);\n+\n+      upgradeManager.addEventListener(listener);\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+      expect(events).toHaveLength(1);\n+\n+      upgradeManager.removeEventListener(listener);\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+      expect(events).toHaveLength(1); // No new events\n+    });\n+  });\n+\n+  describe('multiple unlock conditions', () => {\n+    it('should unlock multiple secrets when conditions are met', () => {\n+      // Stats that should unlock both Salvage (100 demolishes) and ExoticFuel (1 meltdown) and Overclock (10000 money)\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 10000, demolishCount: 100, ticksAtHighHeat: 0 };\n+\n+      const unlocked = upgradeManager.checkSecretUnlocks(stats);\n+\n+      expect(unlocked).toContain(SecretUpgradeType.ExoticFuel);\n+      expect(unlocked).toContain(SecretUpgradeType.Salvage);\n+      expect(unlocked).toContain(SecretUpgradeType.Overclock);\n+    });\n+\n+    it('should not re-unlock already unlocked secrets', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+\n+      const firstUnlock = upgradeManager.checkSecretUnlocks(stats);\n+      expect(firstUnlock).toContain(SecretUpgradeType.ExoticFuel);\n+\n+      const secondUnlock = upgradeManager.checkSecretUnlocks(stats);\n+      expect(secondUnlock).not.toContain(SecretUpgradeType.ExoticFuel);\n+    });\n+  });\n+});\ndiff --git a/src/game/UpgradeManager.ts b/src/game/UpgradeManager.ts\nnew file mode 100644\nindex 0000000..34d4ec4\n--- /dev/null\n+++ b/src/game/UpgradeManager.ts\n@@ -0,0 +1,299 @@\n+/**\n+ * UpgradeManager - Handles regular upgrades and secret upgrades\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ * This class manages upgrade purchasing, secret unlock conditions, and toggle states.\n+ */\n+\n+import {\n+  UpgradeType,\n+  UPGRADE_DEFINITIONS,\n+  SecretUpgradeType,\n+  SECRET_UPGRADE_DEFINITIONS,\n+  getUpgradeCost,\n+  getSecretUnlockProgress,\n+} from './BalanceConfig.js';\n+\n+export interface UpgradeState {\n+  levels: Record<UpgradeType, number>;\n+}\n+\n+export interface SecretState {\n+  unlocked: Record<SecretUpgradeType, boolean>;\n+  purchased: Record<SecretUpgradeType, boolean>;\n+  enabled: Record<SecretUpgradeType, boolean>;\n+}\n+\n+export interface UpgradeEvent {\n+  type: 'upgrade_purchased' | 'secret_unlocked' | 'secret_purchased';\n+  upgradeType?: UpgradeType;\n+  secretType?: SecretUpgradeType;\n+}\n+\n+export type UpgradeEventListener = (event: UpgradeEvent) => void;\n+\n+export interface UnlockStats {\n+  meltdownCount: number;\n+  filledCells: number;\n+  totalMoneyEarned: number;\n+  demolishCount: number;\n+  ticksAtHighHeat: number;\n+}\n+\n+/**\n+ * UpgradeManager handles all upgrade-related logic including:\n+ * - Regular upgrade purchasing and level tracking\n+ * - Secret upgrade unlocking, purchasing, and toggling\n+ */\n+export class UpgradeManager {\n+  private upgrades: UpgradeState;\n+  private secrets: SecretState;\n+  private eventListeners: UpgradeEventListener[] = [];\n+\n+  constructor() {\n+    this.upgrades = this.createInitialUpgradeState();\n+    this.secrets = this.createInitialSecretState();\n+  }\n+\n+  private createInitialUpgradeState(): UpgradeState {\n+    const levels: Record<UpgradeType, number> = {} as Record<UpgradeType, number>;\n+    for (const type of Object.values(UpgradeType)) {\n+      levels[type] = 0;\n+    }\n+    return { levels };\n+  }\n+\n+  private createInitialSecretState(): SecretState {\n+    const unlocked: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+    const purchased: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+    const enabled: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+\n+    for (const type of Object.values(SecretUpgradeType)) {\n+      unlocked[type] = false;\n+      purchased[type] = false;\n+      enabled[type] = false;\n+    }\n+    return { unlocked, purchased, enabled };\n+  }\n+\n+  /**\n+   * Add an event listener for upgrade events\n+   */\n+  addEventListener(listener: UpgradeEventListener): void {\n+    this.eventListeners.push(listener);\n+  }\n+\n+  /**\n+   * Remove an event listener\n+   */\n+  removeEventListener(listener: UpgradeEventListener): void {\n+    const index = this.eventListeners.indexOf(listener);\n+    if (index !== -1) {\n+      this.eventListeners.splice(index, 1);\n+    }\n+  }\n+\n+  private emitEvent(event: UpgradeEvent): void {\n+    for (const listener of this.eventListeners) {\n+      listener(event);\n+    }\n+  }\n+\n+  // ==========================================================================\n+  // REGULAR UPGRADES\n+  // ==========================================================================\n+\n+  /**\n+   * Get the current level of an upgrade\n+   */\n+  getUpgradeLevel(type: UpgradeType): number {\n+    return this.upgrades.levels[type];\n+  }\n+\n+  /**\n+   * Get the cost for the next level of an upgrade\n+   */\n+  getUpgradeCost(type: UpgradeType): number {\n+    const currentLevel = this.upgrades.levels[type];\n+    return getUpgradeCost(type, currentLevel);\n+  }\n+\n+  /**\n+   * Check if an upgrade can be purchased\n+   */\n+  canPurchaseUpgrade(type: UpgradeType, currentMoney: number): boolean {\n+    const definition = UPGRADE_DEFINITIONS[type];\n",
          "actualWorkers": 1
        },
        "id": "chromium",
        "name": "chromium",
        "testDir": "/home/runner/work/claudetest123/claudetest123/e2e",
        "testIgnore": [],
        "testMatch": [
          "**/*.@(spec|test).?(c|m)[jt]s?(x)"
        ],
        "timeout": 30000
      }
    ],
    "quiet": false,
    "reporter": [
      [
        "html",
        {
          "outputFolder": "playwright-report"
        }
      ],
      [
        "list",
        null
      ],
      [
        "json",
        {
          "outputFile": "test-results/results.json"
        }
      ]
    ],
    "reportSlowTests": {
      "max": 5,
      "threshold": 300000
    },
    "runAgents": "none",
    "shard": null,
    "tags": [],
    "updateSnapshots": "missing",
    "updateSourceMethod": "patch",
    "version": "1.58.0",
    "workers": 1,
    "webServer": {
      "command": "npm run serve",
      "url": "http://localhost:3000",
      "reuseExistingServer": false,
      "timeout": 120000
    }
  },
  "suites": [
    {
      "title": "heat-game.spec.ts",
      "file": "heat-game.spec.ts",
      "column": 0,
      "line": 0,
      "specs": [],
      "suites": [
        {
          "title": "Heat Game E2E Tests",
          "file": "heat-game.spec.ts",
          "line": 40,
          "column": 6,
          "specs": [
            {
              "title": "should load the game and display initial state",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 520,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:28:35.659Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-2428b-e-and-display-initial-state-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-2428b-e-and-display-initial-state-chromium/attachments/browser-logs-252e98eebb6d2a6fd5612fd184955e74f7d8fa0e.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-1f7f90ca45f76c134f4d",
              "file": "heat-game.spec.ts",
              "line": 86,
              "column": 3
            },
            {
              "title": "should place a Fuel Rod on the grid",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 601,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:28:37.367Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-05fff-lace-a-Fuel-Rod-on-the-grid-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-05fff-lace-a-Fuel-Rod-on-the-grid-chromium/attachments/browser-logs-daa597c1e58cdd3735064670bc098a56f535a7d5.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-a31bde006f3c29450fad",
              "file": "heat-game.spec.ts",
              "line": 116,
              "column": 3
            },
            {
              "title": "should place multiple structures and observe heat dynamics",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1218,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:28:37.986Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-edba4-s-and-observe-heat-dynamics-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-edba4-s-and-observe-heat-dynamics-chromium/attachments/browser-logs-a9526112523c68aa24fe78334be3ec2af4a1ba62.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-2ed04ebe32d9c471053a",
              "file": "heat-game.spec.ts",
              "line": 148,
              "column": 3
            },
            {
              "title": "should demolish a structure with right-click",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 520,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:28:39.219Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-53724--structure-with-right-click-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-53724--structure-with-right-click-chromium/attachments/browser-logs-d97b4f4e87a5cc31e1b5dee61d33b7cf6ee7bb2f.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-ff211d87a2ad19067056",
              "file": "heat-game.spec.ts",
              "line": 185,
              "column": 3
            },
            {
              "title": "should build a power generation setup",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1683,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:28:39.756Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-206ae-ld-a-power-generation-setup-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-206ae-ld-a-power-generation-setup-chromium/attachments/browser-logs-6db27ca250b3a1a4083663dd5a90aeedb0e1a354.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-abe0096aa1a1c45a3b34",
              "file": "heat-game.spec.ts",
              "line": 216,
              "column": 3
            },
            {
              "title": "should show heat buildup with clustered fuel rods",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1586,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:28:41.453Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-1ce31-up-with-clustered-fuel-rods-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-1ce31-up-with-clustered-fuel-rods-chromium/attachments/browser-logs-4108f70a5376472a80710ba1c287f526e1cfc9b4.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-ac87d21624a439db98b8",
              "file": "heat-game.spec.ts",
              "line": 253,
              "column": 3
            },
            {
              "title": "should not allow building without sufficient money",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1418,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:28:43.052Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-ee0f6-ng-without-sufficient-money-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-ee0f6-ng-without-sufficient-money-chromium/attachments/browser-logs-67852c21b9cbe344288f7cfb81aa3e88ded21441.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-b096005e15a85f67c2a8",
              "file": "heat-game.spec.ts",
              "line": 291,
              "column": 3
            },
            {
              "title": "should handle rapid clicking on the grid",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1185,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:28:44.488Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-c664c--rapid-clicking-on-the-grid-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-c664c--rapid-clicking-on-the-grid-chromium/attachments/browser-logs-8830c25d0c901f07d14f24299509ec6ff3fc0a0b.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-1b3f7a34798ed668be9c",
              "file": "heat-game.spec.ts",
              "line": 333,
              "column": 3
            }
          ]
        }
      ]
    }
  ],
  "errors": [],
  "stats": {
    "startTime": "2026-01-31T12:28:29.280Z",
    "duration": 16466.775,
    "expected": 8,
    "skipped": 0,
    "unexpected": 0,
    "flaky": 0
  }
}