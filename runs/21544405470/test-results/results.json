{
  "config": {
    "configFile": "/home/runner/work/claudetest123/claudetest123/playwright.config.ts",
    "rootDir": "/home/runner/work/claudetest123/claudetest123/e2e",
    "forbidOnly": true,
    "fullyParallel": true,
    "globalSetup": null,
    "globalTeardown": null,
    "globalTimeout": 0,
    "grep": {},
    "grepInvert": null,
    "maxFailures": 0,
    "metadata": {
      "ci": {
        "commitHref": "https://github.com/bjuergens/claudetest123/commit/165ce2dddbaf7f3650602253c44314246c55b990",
        "commitHash": "165ce2dddbaf7f3650602253c44314246c55b990",
        "prHref": "https://github.com/bjuergens/claudetest123/pull/10",
        "prTitle": "Extract GridManager, PhysicsEngine, and UpgradeManager from HeatGame",
        "prBaseHash": "f29e01ec7cb04beabadc275fcf431907f165675e",
        "buildHref": "https://github.com/bjuergens/claudetest123/actions/runs/21544405470"
      },
      "gitCommit": {
        "shortHash": "165ce2d",
        "hash": "165ce2dddbaf7f3650602253c44314246c55b990",
        "subject": "Merge 50871673fe1c73a34bab1f0a44ec4cc76922c43c into f29e01ec7cb04beabadc275fcf431907f165675e",
        "body": "Merge 50871673fe1c73a34bab1f0a44ec4cc76922c43c into f29e01ec7cb04beabadc275fcf431907f165675e\n",
        "author": {
          "name": "Björn Jürgens",
          "email": "4362465+bjuergens@users.noreply.github.com",
          "time": 1769862093000
        },
        "committer": {
          "name": "GitHub",
          "email": "noreply@github.com",
          "time": 1769862093000
        },
        "branch": "HEAD"
      },
      "gitDiff": "diff --git a/src/game/GridManager.test.ts b/src/game/GridManager.test.ts\nnew file mode 100644\nindex 0000000..468ae34\n--- /dev/null\n+++ b/src/game/GridManager.test.ts\n@@ -0,0 +1,277 @@\n+/**\n+ * Unit tests for GridManager\n+ *\n+ * Tests grid creation, neighbor calculations, and cell operations in isolation.\n+ */\n+\n+import { describe, it, expect, beforeEach } from 'vitest';\n+import { GridManager } from './GridManager.js';\n+import { StructureType, Tier } from './BalanceConfig.js';\n+\n+describe('GridManager', () => {\n+  let gridManager: GridManager;\n+\n+  beforeEach(() => {\n+    gridManager = new GridManager(16);\n+  });\n+\n+  describe('initialization', () => {\n+    it('should create a grid of the specified size', () => {\n+      expect(gridManager.getSize()).toBe(16);\n+    });\n+\n+    it('should initialize all cells as empty', () => {\n+      const snapshot = gridManager.getSnapshot();\n+      for (let y = 0; y < 16; y++) {\n+        for (let x = 0; x < 16; x++) {\n+          expect(snapshot[y][x].structure).toBe(StructureType.Empty);\n+          expect(snapshot[y][x].heat).toBe(0);\n+          expect(snapshot[y][x].power).toBe(0);\n+        }\n+      }\n+    });\n+\n+    it('should set correct x,y coordinates for each cell', () => {\n+      const snapshot = gridManager.getSnapshot();\n+      for (let y = 0; y < 16; y++) {\n+        for (let x = 0; x < 16; x++) {\n+          expect(snapshot[y][x].x).toBe(x);\n+          expect(snapshot[y][x].y).toBe(y);\n+        }\n+      }\n+    });\n+  });\n+\n+  describe('getCell', () => {\n+    it('should return a copy of the cell at valid coordinates', () => {\n+      const cell = gridManager.getCell(5, 5);\n+      expect(cell).not.toBeNull();\n+      expect(cell!.x).toBe(5);\n+      expect(cell!.y).toBe(5);\n+    });\n+\n+    it('should return null for out-of-bounds coordinates', () => {\n+      expect(gridManager.getCell(-1, 0)).toBeNull();\n+      expect(gridManager.getCell(0, -1)).toBeNull();\n+      expect(gridManager.getCell(16, 0)).toBeNull();\n+      expect(gridManager.getCell(0, 16)).toBeNull();\n+    });\n+\n+    it('should return a copy, not a reference', () => {\n+      const cell = gridManager.getCell(5, 5);\n+      cell!.heat = 100;\n+      const cellAgain = gridManager.getCell(5, 5);\n+      expect(cellAgain!.heat).toBe(0);\n+    });\n+  });\n+\n+  describe('getCellRef', () => {\n+    it('should return a reference that can be mutated', () => {\n+      const cellRef = gridManager.getCellRef(5, 5);\n+      cellRef!.heat = 100;\n+      const cell = gridManager.getCell(5, 5);\n+      expect(cell!.heat).toBe(100);\n+    });\n+\n+    it('should return null for out-of-bounds coordinates', () => {\n+      expect(gridManager.getCellRef(-1, 0)).toBeNull();\n+      expect(gridManager.getCellRef(16, 0)).toBeNull();\n+    });\n+  });\n+\n+  describe('isValidPosition', () => {\n+    it('should return true for valid positions', () => {\n+      expect(gridManager.isValidPosition(0, 0)).toBe(true);\n+      expect(gridManager.isValidPosition(15, 15)).toBe(true);\n+      expect(gridManager.isValidPosition(8, 8)).toBe(true);\n+    });\n+\n+    it('should return false for invalid positions', () => {\n+      expect(gridManager.isValidPosition(-1, 0)).toBe(false);\n+      expect(gridManager.isValidPosition(0, -1)).toBe(false);\n+      expect(gridManager.isValidPosition(16, 0)).toBe(false);\n+      expect(gridManager.isValidPosition(0, 16)).toBe(false);\n+    });\n+  });\n+\n+  describe('getNeighbors', () => {\n+    it('should return 4 neighbors for center cells', () => {\n+      const neighbors = gridManager.getNeighbors(8, 8);\n+      expect(neighbors).toHaveLength(4);\n+    });\n+\n+    it('should return 3 neighbors for edge cells', () => {\n+      const neighbors = gridManager.getNeighbors(0, 8);\n+      expect(neighbors).toHaveLength(3);\n+    });\n+\n+    it('should return 2 neighbors for corner cells', () => {\n+      const neighbors = gridManager.getNeighbors(0, 0);\n+      expect(neighbors).toHaveLength(2);\n+    });\n+\n+    it('should return orthogonal neighbors only', () => {\n+      const neighbors = gridManager.getNeighbors(5, 5);\n+      const positions = neighbors.map(n => ({ x: n.x, y: n.y }));\n+\n+      expect(positions).toContainEqual({ x: 5, y: 4 }); // up\n+      expect(positions).toContainEqual({ x: 5, y: 6 }); // down\n+      expect(positions).toContainEqual({ x: 4, y: 5 }); // left\n+      expect(positions).toContainEqual({ x: 6, y: 5 }); // right\n+    });\n+  });\n+\n+  describe('countAdjacentFuelRods', () => {\n+    it('should return 0 when no fuel rods are adjacent', () => {\n+      expect(gridManager.countAdjacentFuelRods(5, 5)).toBe(0);\n+    });\n+\n+    it('should count active fuel rods only', () => {\n+      // Place active fuel rod\n+      const cell1 = gridManager.getCellRef(5, 4)!;\n+      cell1.structure = StructureType.FuelRod;\n+      cell1.lifetime = 100;\n+\n+      // Place depleted fuel rod\n+      const cell2 = gridManager.getCellRef(5, 6)!;\n+      cell2.structure = StructureType.FuelRod;\n+      cell2.lifetime = 0;\n+\n+      expect(gridManager.countAdjacentFuelRods(5, 5)).toBe(1);\n+    });\n+\n+    it('should count all adjacent active fuel rods', () => {\n+      const positions = [\n+        { x: 5, y: 4 },\n+        { x: 5, y: 6 },\n+        { x: 4, y: 5 },\n+        { x: 6, y: 5 },\n+      ];\n+\n+      for (const pos of positions) {\n+        const cell = gridManager.getCellRef(pos.x, pos.y)!;\n+        cell.structure = StructureType.FuelRod;\n+        cell.lifetime = 100;\n+      }\n+\n+      expect(gridManager.countAdjacentFuelRods(5, 5)).toBe(4);\n+    });\n+  });\n+\n+  describe('getFilledCellCount', () => {\n+    it('should return 0 for empty grid', () => {\n+      expect(gridManager.getFilledCellCount()).toBe(0);\n+    });\n+\n+    it('should count non-empty cells', () => {\n+      gridManager.getCellRef(0, 0)!.structure = StructureType.FuelRod;\n+      gridManager.getCellRef(1, 1)!.structure = StructureType.Turbine;\n+      gridManager.getCellRef(2, 2)!.structure = StructureType.Ventilator;\n+\n+      expect(gridManager.getFilledCellCount()).toBe(3);\n+    });\n+  });\n+\n+  describe('expandGrid', () => {\n+    it('should expand grid to new size', () => {\n+      gridManager.getCellRef(5, 5)!.structure = StructureType.FuelRod;\n+\n+      const result = gridManager.expandGrid(18, 20);\n+      expect(result).toBe(true);\n+      expect(gridManager.getSize()).toBe(18);\n+    });\n+\n+    it('should preserve existing cells after expansion', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.heat = 500;\n+\n+      gridManager.expandGrid(18, 20);\n+\n+      const preserved = gridManager.getCell(5, 5);\n+      expect(preserved!.structure).toBe(StructureType.FuelRod);\n+      expect(preserved!.heat).toBe(500);\n+    });\n+\n+    it('should not expand beyond max size', () => {\n+      const result = gridManager.expandGrid(25, 20);\n+      expect(result).toBe(false);\n+      expect(gridManager.getSize()).toBe(16);\n+    });\n+\n+    it('should not shrink the grid', () => {\n+      const result = gridManager.expandGrid(10, 20);\n+      expect(result).toBe(false);\n+      expect(gridManager.getSize()).toBe(16);\n+    });\n+  });\n+\n+  describe('resetCell', () => {\n+    it('should reset a cell to empty state', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.Turbine;\n+      cell.heat = 500;\n+      cell.power = 100;\n+\n+      gridManager.resetCell(5, 5);\n+\n+      const reset = gridManager.getCell(5, 5);\n+      expect(reset!.structure).toBe(StructureType.Empty);\n+      expect(reset!.heat).toBe(0);\n+      expect(reset!.power).toBe(0);\n+    });\n+\n+    it('should preserve coordinates after reset', () => {\n+      gridManager.resetCell(5, 5);\n+      const cell = gridManager.getCell(5, 5);\n+      expect(cell!.x).toBe(5);\n+      expect(cell!.y).toBe(5);\n+    });\n+  });\n+\n+  describe('clearAll', () => {\n+    it('should reset all cells to empty', () => {\n+      // Fill some cells\n+      for (let i = 0; i < 5; i++) {\n+        gridManager.getCellRef(i, i)!.structure = StructureType.FuelRod;\n+      }\n+\n+      gridManager.clearAll();\n+\n+      expect(gridManager.getFilledCellCount()).toBe(0);\n+    });\n+  });\n+\n+  describe('forEach', () => {\n+    it('should iterate over all cells', () => {\n+      let count = 0;\n+      gridManager.forEach(() => count++);\n+      expect(count).toBe(16 * 16);\n+    });\n+\n+    it('should provide correct cell references', () => {\n+      gridManager.forEach((cell, x, y) => {\n+        expect(cell.x).toBe(x);\n+        expect(cell.y).toBe(y);\n+      });\n+    });\n+  });\n+\n+  describe('restoreFromState', () => {\n+    it('should restore grid from serialized state', () => {\n+      // Create a state to restore\n+      const state = gridManager.getSnapshot();\n+      state[5][5].structure = StructureType.Turbine;\n+      state[5][5].heat = 250;\n+\n+      // Create new grid manager and restore\n+      const newGridManager = new GridManager(10);\n+      newGridManager.restoreFromState(state, 16);\n+\n+      expect(newGridManager.getSize()).toBe(16);\n+      const cell = newGridManager.getCell(5, 5);\n+      expect(cell!.structure).toBe(StructureType.Turbine);\n+      expect(cell!.heat).toBe(250);\n+    });\n+  });\n+});\ndiff --git a/src/game/GridManager.ts b/src/game/GridManager.ts\nnew file mode 100644\nindex 0000000..0e158a8\n--- /dev/null\n+++ b/src/game/GridManager.ts\n@@ -0,0 +1,221 @@\n+/**\n+ * GridManager - Handles grid creation, neighbor calculations, and cell operations\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ */\n+\n+import { StructureType, Tier } from './BalanceConfig.js';\n+\n+export interface Cell {\n+  x: number;\n+  y: number;\n+  structure: StructureType;\n+  tier: Tier;\n+  heat: number;\n+  power: number;\n+  /** Remaining lifetime in ticks (fuel rods only, 0 = infinite/depleted) */\n+  lifetime: number;\n+  /** Whether this is an exotic variant (fuel rods only) */\n+  isExotic: boolean;\n+}\n+\n+export class GridManager {\n+  private grid: Cell[][];\n+  private gridSize: number;\n+\n+  constructor(initialSize: number) {\n+    this.gridSize = initialSize;\n+    this.grid = this.createEmptyGrid(initialSize);\n+  }\n+\n+  /**\n+   * Create a new empty grid of the specified size\n+   */\n+  createEmptyGrid(size: number): Cell[][] {\n+    const grid: Cell[][] = [];\n+    for (let y = 0; y < size; y++) {\n+      const row: Cell[] = [];\n+      for (let x = 0; x < size; x++) {\n+        row.push(this.createEmptyCell(x, y));\n+      }\n+      grid.push(row);\n+    }\n+    return grid;\n+  }\n+\n+  /**\n+   * Create an empty cell at the specified coordinates\n+   */\n+  createEmptyCell(x: number, y: number): Cell {\n+    return {\n+      x,\n+      y,\n+      structure: StructureType.Empty,\n+      tier: Tier.T1,\n+      heat: 0,\n+      power: 0,\n+      lifetime: 0,\n+      isExotic: false,\n+    };\n+  }\n+\n+  /**\n+   * Get a copy of a cell at the specified coordinates\n+   * Returns null if coordinates are out of bounds\n+   */\n+  getCell(x: number, y: number): Cell | null {\n+    if (!this.isValidPosition(x, y)) {\n+      return null;\n+    }\n+    return { ...this.grid[y][x] };\n+  }\n+\n+  /**\n+   * Get a direct reference to a cell (for mutation)\n+   * Returns null if coordinates are out of bounds\n+   */\n+  getCellRef(x: number, y: number): Cell | null {\n+    if (!this.isValidPosition(x, y)) {\n+      return null;\n+    }\n+    return this.grid[y][x];\n+  }\n+\n+  /**\n+   * Check if coordinates are within grid bounds\n+   */\n+  isValidPosition(x: number, y: number): boolean {\n+    return x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize;\n+  }\n+\n+  /**\n+   * Get the current grid size\n+   */\n+  getSize(): number {\n+    return this.gridSize;\n+  }\n+\n+  /**\n+   * Get a snapshot (deep copy) of the entire grid\n+   */\n+  getSnapshot(): Cell[][] {\n+    return this.grid.map(row => row.map(cell => ({ ...cell })));\n+  }\n+\n+  /**\n+   * Get the internal grid reference (for physics engine)\n+   */\n+  getGridRef(): Cell[][] {\n+    return this.grid;\n+  }\n+\n+  /**\n+   * Get orthogonal neighbors (up, down, left, right) of a cell\n+   */\n+  getNeighbors(x: number, y: number): Cell[] {\n+    const neighbors: Cell[] = [];\n+    const directions = [\n+      { dx: 0, dy: -1 }, // up\n+      { dx: 0, dy: 1 },  // down\n+      { dx: -1, dy: 0 }, // left\n+      { dx: 1, dy: 0 },  // right\n+    ];\n+\n+    for (const { dx, dy } of directions) {\n+      const nx = x + dx;\n+      const ny = y + dy;\n+      if (this.isValidPosition(nx, ny)) {\n+        neighbors.push(this.grid[ny][nx]);\n+      }\n+    }\n+\n+    return neighbors;\n+  }\n+\n+  /**\n+   * Count active (non-depleted) fuel rods adjacent to a position\n+   */\n+  countAdjacentFuelRods(x: number, y: number): number {\n+    const neighbors = this.getNeighbors(x, y);\n+    return neighbors.filter(n => n.structure === StructureType.FuelRod && n.lifetime > 0).length;\n+  }\n+\n+  /**\n+   * Count filled (non-empty) cells in the grid\n+   */\n+  getFilledCellCount(): number {\n+    let count = 0;\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        if (this.grid[y][x].structure !== StructureType.Empty) {\n+          count++;\n+        }\n+      }\n+    }\n+    return count;\n+  }\n+\n+  /**\n+   * Expand the grid to a new size, preserving existing cells\n+   * Returns true if expansion was successful\n+   */\n+  expandGrid(newSize: number, maxSize: number): boolean {\n+    if (newSize <= this.gridSize) return false;\n+    if (newSize > maxSize) return false;\n+\n+    const oldGrid = this.grid;\n+    const oldSize = this.gridSize;\n+\n+    // Create new larger grid\n+    this.grid = this.createEmptyGrid(newSize);\n+    this.gridSize = newSize;\n+\n+    // Copy old grid data\n+    for (let y = 0; y < oldSize; y++) {\n+      for (let x = 0; x < oldSize; x++) {\n+        this.grid[y][x] = { ...oldGrid[y][x] };\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Reset a cell to empty state\n+   */\n+  resetCell(x: number, y: number): void {\n+    if (this.isValidPosition(x, y)) {\n+      this.grid[y][x] = this.createEmptyCell(x, y);\n+    }\n+  }\n+\n+  /**\n+   * Clear all cells in the grid (reset to empty)\n+   */\n+  clearAll(): void {\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        this.grid[y][x] = this.createEmptyCell(x, y);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Iterate over all cells, calling the callback for each\n+   */\n+  forEach(callback: (cell: Cell, x: number, y: number) => void): void {\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        callback(this.grid[y][x], x, y);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Restore grid state from serialized data\n+   */\n+  restoreFromState(grid: Cell[][], gridSize: number): void {\n+    this.gridSize = gridSize;\n+    this.grid = grid.map(row => row.map(cell => ({ ...cell })));\n+  }\n+}\ndiff --git a/src/game/PhysicsEngine.test.ts b/src/game/PhysicsEngine.test.ts\nnew file mode 100644\nindex 0000000..f49b67b\n--- /dev/null\n+++ b/src/game/PhysicsEngine.test.ts\n@@ -0,0 +1,460 @@\n+/**\n+ * Unit tests for PhysicsEngine\n+ *\n+ * Tests heat generation, transfer, dissipation, and power generation in isolation.\n+ */\n+\n+import { describe, it, expect, beforeEach, vi } from 'vitest';\n+import { GridManager } from './GridManager.js';\n+import { PhysicsEngine, PhysicsEvent } from './PhysicsEngine.js';\n+import { StructureType, Tier, UpgradeType, STRUCTURE_BASE_STATS, getFuelLifetime } from './BalanceConfig.js';\n+\n+describe('PhysicsEngine', () => {\n+  let gridManager: GridManager;\n+  let physicsEngine: PhysicsEngine;\n+  let upgradeLevels: Map<UpgradeType, number>;\n+\n+  const getUpgradeLevel = (type: UpgradeType) => upgradeLevels.get(type) ?? 0;\n+\n+  beforeEach(() => {\n+    gridManager = new GridManager(16);\n+    upgradeLevels = new Map();\n+    physicsEngine = new PhysicsEngine(gridManager, getUpgradeLevel);\n+  });\n+\n+  describe('heat generation', () => {\n+    it('should generate heat from active fuel rods', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.tier = Tier.T1;\n+      cell.lifetime = 100;\n+\n+      physicsEngine.processHeatGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeGreaterThan(0);\n+    });\n+\n+    it('should not generate heat from depleted fuel rods', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.tier = Tier.T1;\n+      cell.lifetime = 0; // depleted\n+\n+      physicsEngine.processHeatGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBe(0);\n+    });\n+\n+    it('should apply adjacency bonus for neighboring fuel rods', () => {\n+      // Place center fuel rod\n+      const center = gridManager.getCellRef(5, 5)!;\n+      center.structure = StructureType.FuelRod;\n+      center.tier = Tier.T1;\n+      center.lifetime = 100;\n+\n+      // Get baseline heat generation\n+      physicsEngine.processHeatGeneration();\n+      const baseHeat = gridManager.getCell(5, 5)!.heat;\n+\n+      // Reset and add adjacent fuel rod\n+      gridManager.getCellRef(5, 5)!.heat = 0;\n+      const adjacent = gridManager.getCellRef(5, 4)!;\n+      adjacent.structure = StructureType.FuelRod;\n+      adjacent.tier = Tier.T1;\n+      adjacent.lifetime = 100;\n+\n+      physicsEngine.processHeatGeneration();\n+      const boostedHeat = gridManager.getCell(5, 5)!.heat;\n+\n+      expect(boostedHeat).toBeGreaterThan(baseHeat);\n+    });\n+\n+    it('should generate more heat for higher tiers', () => {\n+      const cell1 = gridManager.getCellRef(3, 3)!;\n+      cell1.structure = StructureType.FuelRod;\n+      cell1.tier = Tier.T1;\n+      cell1.lifetime = 100;\n+\n+      const cell2 = gridManager.getCellRef(8, 8)!;\n+      cell2.structure = StructureType.FuelRod;\n+      cell2.tier = Tier.T2;\n+      cell2.lifetime = 100;\n+\n+      physicsEngine.processHeatGeneration();\n+\n+      expect(gridManager.getCell(8, 8)!.heat).toBeGreaterThan(gridManager.getCell(3, 3)!.heat);\n+    });\n+  });\n+\n+  describe('fuel depletion', () => {\n+    it('should decrease fuel lifetime each tick', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 100;\n+\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(gridManager.getCell(5, 5)!.lifetime).toBe(99);\n+    });\n+\n+    it('should emit event when fuel is depleted', () => {\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(events).toHaveLength(1);\n+      expect(events[0].type).toBe('fuel_depleted');\n+      expect(events[0].x).toBe(5);\n+      expect(events[0].y).toBe(5);\n+    });\n+\n+    it('should track depleted fuel rods in stats', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(physicsEngine.getStats().fuelRodsDepleted).toBe(1);\n+    });\n+  });\n+\n+  describe('heat transfer', () => {\n+    it('should transfer heat from hot to cold cells', () => {\n+      const hotCell = gridManager.getCellRef(5, 5)!;\n+      hotCell.heat = 1000;\n+\n+      const coldCell = gridManager.getCellRef(5, 6)!;\n+      coldCell.heat = 0;\n+\n+      physicsEngine.processHeatTransfer();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeLessThan(1000);\n+      expect(gridManager.getCell(5, 6)!.heat).toBeGreaterThan(0);\n+    });\n+\n+    it('should respect conductivity differences', () => {\n+      // Place insulator (low conductivity) and regular cell\n+      const insulator = gridManager.getCellRef(5, 5)!;\n+      insulator.structure = StructureType.Insulator;\n+      insulator.heat = 1000;\n+\n+      physicsEngine.processHeatTransfer();\n+      const insulatorHeatAfter = gridManager.getCell(5, 5)!.heat;\n+\n+      // Compare with empty cell\n+      gridManager.getCellRef(5, 5)!.structure = StructureType.Empty;\n+      gridManager.getCellRef(5, 5)!.heat = 1000;\n+\n+      physicsEngine.processHeatTransfer();\n+      const emptyHeatAfter = gridManager.getCell(5, 5)!.heat;\n+\n+      // Insulator should retain more heat due to low conductivity\n+      expect(insulatorHeatAfter).toBeGreaterThan(emptyHeatAfter);\n+    });\n+\n+    it('should lose heat to environment at edges', () => {\n+      // Place heat at corner (2 edges exposed)\n+      const corner = gridManager.getCellRef(0, 0)!;\n+      corner.heat = 1000;\n+\n+      physicsEngine.processHeatTransfer();\n+\n+      expect(gridManager.getCell(0, 0)!.heat).toBeLessThan(1000);\n+    });\n+  });\n+\n+  describe('heat dissipation', () => {\n+    it('should dissipate heat from ventilators', () => {\n+      const vent = gridManager.getCellRef(5, 5)!;\n+      vent.structure = StructureType.Ventilator;\n+      vent.tier = Tier.T1;\n+      vent.heat = 100;\n+\n+      physicsEngine.processHeatDissipation();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeLessThan(100);\n+    });\n+\n+    it('should not go below zero heat', () => {\n+      const vent = gridManager.getCellRef(5, 5)!;\n+      vent.structure = StructureType.Ventilator;\n+      vent.tier = Tier.T1;\n+      vent.heat = 1; // Very low heat\n+\n+      physicsEngine.processHeatDissipation();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeGreaterThanOrEqual(0);\n+    });\n+\n+    it('should dissipate more heat for higher tier ventilators', () => {\n+      const vent1 = gridManager.getCellRef(3, 3)!;\n+      vent1.structure = StructureType.Ventilator;\n+      vent1.tier = Tier.T1;\n+      vent1.heat = 500;\n+\n+      const vent2 = gridManager.getCellRef(8, 8)!;\n+      vent2.structure = StructureType.Ventilator;\n+      vent2.tier = Tier.T2;\n+      vent2.heat = 500;\n+\n+      physicsEngine.processHeatDissipation();\n+\n+      // T2 should dissipate more, leaving less heat\n+      expect(gridManager.getCell(8, 8)!.heat).toBeLessThan(gridManager.getCell(3, 3)!.heat);\n+    });\n+  });\n+\n+  describe('power generation', () => {\n+    it('should generate power from turbines with heat', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = 100;\n+\n+      physicsEngine.processPowerGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.power).toBeGreaterThan(0);\n+      expect(gridManager.getCell(5, 5)!.heat).toBeLessThan(100);\n+    });\n+\n+    it('should not generate power without heat', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = 0;\n+\n+      physicsEngine.processPowerGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.power).toBe(0);\n+    });\n+\n+    it('should track total power generated in stats', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = 100;\n+\n+      physicsEngine.processPowerGeneration();\n+\n+      expect(physicsEngine.getStats().totalPowerGenerated).toBeGreaterThan(0);\n+    });\n+  });\n+\n+  describe('power sale', () => {\n+    it('should transfer power from turbine to adjacent substation', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.power = 100;\n+\n+      const substation = gridManager.getCellRef(5, 6)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+\n+      physicsEngine.processPowerSale();\n+\n+      // Turbine should have transferred power\n+      expect(gridManager.getCell(5, 5)!.power).toBe(0);\n+      // Substation receives power but also sells some (saleRate applies)\n+      // Just verify it received the power (it may sell some immediately)\n+      expect(physicsEngine.getStats().totalMoneyEarned).toBeGreaterThan(0);\n+    });\n+\n+    it('should sell power from substations and return earnings', () => {\n+      const substation = gridManager.getCellRef(5, 5)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+      substation.power = 100;\n+\n+      const earnings = physicsEngine.processPowerSale();\n+\n+      expect(earnings).toBeGreaterThan(0);\n+      expect(gridManager.getCell(5, 5)!.power).toBeLessThan(100);\n+    });\n+\n+    it('should emit power_sold event', () => {\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      const substation = gridManager.getCellRef(5, 5)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+      substation.power = 100;\n+\n+      physicsEngine.processPowerSale();\n+\n+      expect(events.some(e => e.type === 'power_sold')).toBe(true);\n+    });\n+  });\n+\n+  describe('overheating', () => {\n+    it('should melt structures that exceed melt temperature', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = STRUCTURE_BASE_STATS[StructureType.Turbine].meltTemp + 100;\n+\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      physicsEngine.processOverheating();\n+\n+      expect(gridManager.getCell(5, 5)!.structure).toBe(StructureType.Empty);\n+      expect(events.some(e => e.type === 'structure_melted')).toBe(true);\n+    });\n+\n+    it('should trigger meltdown when fuel rod overheats', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp + 100;\n+\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      const meltdown = physicsEngine.processOverheating();\n+\n+      expect(meltdown).toBe(true);\n+      expect(events.some(e => e.type === 'meltdown')).toBe(true);\n+    });\n+\n+    it('should clear entire grid on meltdown', () => {\n+      // Place some structures\n+      gridManager.getCellRef(3, 3)!.structure = StructureType.Turbine;\n+      gridManager.getCellRef(8, 8)!.structure = StructureType.Ventilator;\n+\n+      // Trigger meltdown\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp + 100;\n+\n+      physicsEngine.processOverheating();\n+\n+      expect(gridManager.getFilledCellCount()).toBe(0);\n+    });\n+  });\n+\n+  describe('high heat tracking', () => {\n+    it('should track ticks at high heat', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      // Set heat to 90% of melt temp\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp * 0.91;\n+\n+      physicsEngine.trackHighHeatSurvival();\n+\n+      expect(physicsEngine.getStats().ticksAtHighHeat).toBe(1);\n+    });\n+\n+    it('should not track when below 90% melt temp', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp * 0.5;\n+\n+      physicsEngine.trackHighHeatSurvival();\n+\n+      expect(physicsEngine.getStats().ticksAtHighHeat).toBe(0);\n+    });\n+  });\n+\n+  describe('effective stats with upgrades', () => {\n+    it('should increase melt temp with upgrades', () => {\n+      const baseMeltTemp = physicsEngine.getEffectiveMeltTemp(StructureType.FuelRod);\n+\n+      upgradeLevels.set(UpgradeType.MeltTempFuelRod, 3);\n+      const upgradedMeltTemp = physicsEngine.getEffectiveMeltTemp(StructureType.FuelRod);\n+\n+      expect(upgradedMeltTemp).toBeGreaterThan(baseMeltTemp);\n+    });\n+\n+    it('should increase turbine conductivity with upgrades', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+\n+      const baseConductivity = physicsEngine.getEffectiveConductivity(turbine);\n+\n+      upgradeLevels.set(UpgradeType.TurbineConductivity, 2);\n+      const upgradedConductivity = physicsEngine.getEffectiveConductivity(turbine);\n+\n+      expect(upgradedConductivity).toBeGreaterThan(baseConductivity);\n+    });\n+\n+    it('should decrease insulator conductivity with upgrades', () => {\n+      const insulator = gridManager.getCellRef(5, 5)!;\n+      insulator.structure = StructureType.Insulator;\n+\n+      const baseConductivity = physicsEngine.getEffectiveConductivity(insulator);\n+\n+      upgradeLevels.set(UpgradeType.InsulatorConductivity, 2);\n+      const upgradedConductivity = physicsEngine.getEffectiveConductivity(insulator);\n+\n+      expect(upgradedConductivity).toBeLessThan(baseConductivity);\n+    });\n+  });\n+\n+  describe('tick', () => {\n+    it('should run all physics phases', () => {\n+      // Set up a simple reactor\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      fuelRod.lifetime = 100;\n+\n+      const turbine = gridManager.getCellRef(5, 6)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+\n+      const substation = gridManager.getCellRef(5, 7)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+\n+      const result = physicsEngine.tick();\n+\n+      expect(result.moneyEarned).toBeGreaterThanOrEqual(0);\n+      expect(result.meltdown).toBe(false);\n+    });\n+\n+    it('should report meltdown in tick result', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.lifetime = 100; // Active fuel rod\n+      // Set very high heat to ensure it still exceeds meltTemp after heat transfer/dissipation\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp * 2;\n+\n+      const result = physicsEngine.tick();\n+\n+      expect(result.meltdown).toBe(true);\n+    });\n+  });\n+\n+  describe('event listeners', () => {\n+    it('should allow adding and removing listeners', () => {\n+      const events: PhysicsEvent[] = [];\n+      const listener = (e: PhysicsEvent) => events.push(e);\n+\n+      physicsEngine.addEventListener(listener);\n+\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+\n+      physicsEngine.processFuelDepletion();\n+      expect(events).toHaveLength(1);\n+\n+      physicsEngine.removeEventListener(listener);\n+\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(events).toHaveLength(1); // No new events\n+    });\n+  });\n+});\ndiff --git a/src/game/PhysicsEngine.ts b/src/game/PhysicsEngine.ts\nnew file mode 100644\nindex 0000000..ef4c504\n--- /dev/null\n+++ b/src/game/PhysicsEngine.ts\n@@ -0,0 +1,483 @@\n+/**\n+ * PhysicsEngine - Handles heat generation, transfer, dissipation, and power generation\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ * This class is responsible for all physics simulation logic.\n+ */\n+\n+import {\n+  CORE_SETTINGS,\n+  StructureType,\n+  Tier,\n+  STRUCTURE_BASE_STATS,\n+  FUEL_ADJACENCY,\n+  ECONOMY,\n+  UpgradeType,\n+  UPGRADE_DEFINITIONS,\n+  EXOTIC_FUEL,\n+  getFuelHeatGeneration,\n+} from './BalanceConfig.js';\n+import { Cell, GridManager } from './GridManager.js';\n+\n+export interface PhysicsEvent {\n+  type: 'fuel_depleted' | 'power_sold' | 'structure_melted' | 'meltdown';\n+  x?: number;\n+  y?: number;\n+  tier?: Tier;\n+  structure?: StructureType;\n+  amount?: number;\n+}\n+\n+export type PhysicsEventListener = (event: PhysicsEvent) => void;\n+\n+export interface UpgradeLevels {\n+  [key: string]: number;\n+}\n+\n+export interface PhysicsStats {\n+  totalPowerGenerated: number;\n+  totalMoneyEarned: number;\n+  fuelRodsDepleted: number;\n+  ticksAtHighHeat: number;\n+}\n+\n+/**\n+ * PhysicsEngine handles all physics simulation for the heat game.\n+ * It operates on a GridManager and uses upgrade levels for calculations.\n+ */\n+export class PhysicsEngine {\n+  private eventListeners: PhysicsEventListener[] = [];\n+  private stats: PhysicsStats = {\n+    totalPowerGenerated: 0,\n+    totalMoneyEarned: 0,\n+    fuelRodsDepleted: 0,\n+    ticksAtHighHeat: 0,\n+  };\n+\n+  constructor(\n+    private gridManager: GridManager,\n+    private getUpgradeLevel: (type: UpgradeType) => number\n+  ) {}\n+\n+  /**\n+   * Add an event listener for physics events\n+   */\n+  addEventListener(listener: PhysicsEventListener): void {\n+    this.eventListeners.push(listener);\n+  }\n+\n+  /**\n+   * Remove an event listener\n+   */\n+  removeEventListener(listener: PhysicsEventListener): void {\n+    const index = this.eventListeners.indexOf(listener);\n+    if (index !== -1) {\n+      this.eventListeners.splice(index, 1);\n+    }\n+  }\n+\n+  private emitEvent(event: PhysicsEvent): void {\n+    for (const listener of this.eventListeners) {\n+      listener(event);\n+    }\n+  }\n+\n+  /**\n+   * Get the current physics stats\n+   */\n+  getStats(): PhysicsStats {\n+    return { ...this.stats };\n+  }\n+\n+  /**\n+   * Reset stats (used after deserialization)\n+   */\n+  setStats(stats: PhysicsStats): void {\n+    this.stats = { ...stats };\n+  }\n+\n+  /**\n+   * Get effective melt temperature for a structure type (with upgrades)\n+   */\n+  getEffectiveMeltTemp(structure: StructureType): number {\n+    const baseTemp = STRUCTURE_BASE_STATS[structure].meltTemp;\n+\n+    let upgradeType: UpgradeType | null = null;\n+    switch (structure) {\n+      case StructureType.FuelRod: upgradeType = UpgradeType.MeltTempFuelRod; break;\n+      case StructureType.Ventilator: upgradeType = UpgradeType.MeltTempVentilator; break;\n+      case StructureType.HeatExchanger: upgradeType = UpgradeType.MeltTempHeatExchanger; break;\n+      case StructureType.Insulator: upgradeType = UpgradeType.MeltTempInsulator; break;\n+      case StructureType.Turbine: upgradeType = UpgradeType.MeltTempTurbine; break;\n+      case StructureType.Substation: upgradeType = UpgradeType.MeltTempSubstation; break;\n+    }\n+\n+    if (upgradeType) {\n+      const level = this.getUpgradeLevel(upgradeType);\n+      const definition = UPGRADE_DEFINITIONS[upgradeType];\n+      return baseTemp + (level * definition.improvementPerLevel);\n+    }\n+\n+    return baseTemp;\n+  }\n+\n+  /**\n+   * Get effective conductivity for a cell (with upgrades)\n+   */\n+  getEffectiveConductivity(cell: Cell): number {\n+    const baseConductivity = STRUCTURE_BASE_STATS[cell.structure].conductivity;\n+\n+    if (cell.structure === StructureType.Turbine) {\n+      const level = this.getUpgradeLevel(UpgradeType.TurbineConductivity);\n+      const definition = UPGRADE_DEFINITIONS[UpgradeType.TurbineConductivity];\n+      return baseConductivity + (level * definition.improvementPerLevel);\n+    }\n+\n+    if (cell.structure === StructureType.Insulator) {\n+      const level = this.getUpgradeLevel(UpgradeType.InsulatorConductivity);\n+      if (level > 0) {\n+        return baseConductivity * Math.pow(0.5, level);\n+      }\n+    }\n+\n+    return baseConductivity;\n+  }\n+\n+  /**\n+   * Get effective heat dissipation for a cell (with upgrades)\n+   */\n+  getEffectiveHeatDissipation(cell: Cell): number {\n+    if (cell.structure !== StructureType.Ventilator && cell.structure !== StructureType.VoidCell) {\n+      return 0;\n+    }\n+\n+    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n+    let dissipation = baseStats.heatDissipation;\n+\n+    if (cell.structure === StructureType.Ventilator) {\n+      dissipation *= Math.pow(10, cell.tier - 1);\n+\n+      const level = this.getUpgradeLevel(UpgradeType.VentilatorDissipation);\n+      const definition = UPGRADE_DEFINITIONS[UpgradeType.VentilatorDissipation];\n+      dissipation += level * definition.improvementPerLevel;\n+    }\n+\n+    return dissipation;\n+  }\n+\n+  /**\n+   * Get effective power sale rate for a cell (with upgrades)\n+   */\n+  getEffectivePowerSaleRate(cell: Cell): number {\n+    if (cell.structure !== StructureType.Substation) return 0;\n+\n+    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n+    let saleRate = baseStats.powerSaleRate;\n+\n+    saleRate *= Math.pow(10, cell.tier - 1);\n+\n+    const level = this.getUpgradeLevel(UpgradeType.SubstationSaleRate);\n+    const definition = UPGRADE_DEFINITIONS[UpgradeType.SubstationSaleRate];\n+    saleRate += level * definition.improvementPerLevel;\n+\n+    return saleRate;\n+  }\n+\n+  /**\n+   * Process heat generation from fuel rods\n+   */\n+  processHeatGeneration(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+        if (cell.lifetime <= 0) continue;\n+\n+        const upgradeLevel = this.getUpgradeLevel(UpgradeType.FuelHeatOutput);\n+        let heatGeneration = getFuelHeatGeneration(cell.tier, upgradeLevel);\n+\n+        // Adjacency bonus\n+        const adjacentFuelRods = this.gridManager.countAdjacentFuelRods(x, y);\n+        const adjacencyMultiplier = 1 + (adjacentFuelRods * FUEL_ADJACENCY.BONUS_PER_ADJACENT);\n+        heatGeneration *= adjacencyMultiplier;\n+\n+        // Exotic fuel scaling\n+        if (cell.isExotic) {\n+          const tempMultiplier = Math.min(\n+            EXOTIC_FUEL.MAX_MULTIPLIER,\n+            EXOTIC_FUEL.BASE_MULTIPLIER + (cell.heat / 1000) * EXOTIC_FUEL.HEAT_SCALING\n+          );\n+          heatGeneration *= tempMultiplier;\n+        }\n+\n+        cell.heat += heatGeneration;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process fuel depletion\n+   */\n+  processFuelDepletion(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+        if (cell.lifetime <= 0) continue;\n+\n+        cell.lifetime--;\n+\n+        if (cell.lifetime <= 0) {\n+          this.stats.fuelRodsDepleted++;\n+          this.emitEvent({\n+            type: 'fuel_depleted',\n+            x,\n+            y,\n+            tier: cell.tier,\n+          });\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process heat transfer between cells\n+   */\n+  processHeatTransfer(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    const heatDeltas: number[][] = [];\n+    for (let y = 0; y < gridSize; y++) {\n+      heatDeltas.push(new Array(gridSize).fill(0));\n+    }\n+\n+    const transferRate = CORE_SETTINGS.BASE_HEAT_TRANSFER_RATE;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        const cellConductivity = this.getEffectiveConductivity(cell);\n+        const neighbors = this.gridManager.getNeighbors(x, y);\n+\n+        for (const neighbor of neighbors) {\n+          const neighborConductivity = this.getEffectiveConductivity(neighbor);\n+          const heatDiff = cell.heat - neighbor.heat;\n+\n+          if (heatDiff > 0) {\n+            const conductivity = Math.min(cellConductivity, neighborConductivity);\n+            const transfer = heatDiff * transferRate * conductivity;\n+            heatDeltas[y][x] -= transfer;\n+            heatDeltas[neighbor.y][neighbor.x] += transfer;\n+          }\n+        }\n+\n+        // Edge cells lose heat to environment\n+        const edgeCount = 4 - neighbors.length;\n+        if (edgeCount > 0 && cell.heat > CORE_SETTINGS.AMBIENT_TEMPERATURE) {\n+          const heatAboveAmbient = cell.heat - CORE_SETTINGS.AMBIENT_TEMPERATURE;\n+          const envTransfer = heatAboveAmbient * CORE_SETTINGS.ENVIRONMENT_HEAT_TRANSFER_RATE * edgeCount;\n+          heatDeltas[y][x] -= envTransfer;\n+        }\n+      }\n+    }\n+\n+    // Apply deltas\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        grid[y][x].heat = Math.max(0, grid[y][x].heat + heatDeltas[y][x]);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process heat dissipation (ventilators and void cells)\n+   */\n+  processHeatDissipation(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        const dissipation = this.getEffectiveHeatDissipation(cell);\n+        cell.heat = Math.max(0, cell.heat - dissipation);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process power generation (turbines)\n+   */\n+  processPowerGeneration(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure !== StructureType.Turbine) continue;\n+        if (cell.heat <= 0) continue;\n+\n+        const baseStats = STRUCTURE_BASE_STATS[StructureType.Turbine];\n+        const maxHeatConsumption = baseStats.maxHeatConsumption * Math.pow(10, cell.tier - 1);\n+        const powerGeneration = baseStats.powerGeneration;\n+\n+        const heatConsumed = Math.min(cell.heat, maxHeatConsumption);\n+        const powerGenerated = heatConsumed * powerGeneration;\n+\n+        cell.heat -= heatConsumed;\n+        cell.power += powerGenerated;\n+        this.stats.totalPowerGenerated += powerGenerated;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process power sale (substations)\n+   * Returns the amount of money earned\n+   */\n+  processPowerSale(): number {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let totalEarnings = 0;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        // Turbines transfer power to nearby substations\n+        if (cell.structure === StructureType.Turbine && cell.power > 0) {\n+          const neighbors = this.gridManager.getNeighbors(x, y);\n+          for (const neighbor of neighbors) {\n+            if (neighbor.structure === StructureType.Substation) {\n+              grid[neighbor.y][neighbor.x].power += cell.power;\n+              cell.power = 0;\n+              break;\n+            }\n+          }\n+        }\n+\n+        // Substations sell power\n+        if (cell.structure === StructureType.Substation && cell.power > 0) {\n+          const saleRate = this.getEffectivePowerSaleRate(cell);\n+          const powerToSell = Math.min(cell.power, saleRate);\n+          const earnings = powerToSell * ECONOMY.MONEY_PER_POWER;\n+\n+          totalEarnings += earnings;\n+          this.stats.totalMoneyEarned += earnings;\n+          cell.power -= powerToSell;\n+\n+          if (earnings > 0) {\n+            this.emitEvent({\n+              type: 'power_sold',\n+              x,\n+              y,\n+              amount: earnings,\n+            });\n+          }\n+        }\n+      }\n+    }\n+\n+    return totalEarnings;\n+  }\n+\n+  /**\n+   * Process overheating and meltdowns\n+   * Returns true if a meltdown occurred\n+   */\n+  processOverheating(): boolean {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let meltdown = false;\n+    const meltedCells: { x: number; y: number; structure: StructureType; tier: Tier }[] = [];\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure === StructureType.Empty) continue;\n+\n+        const meltTemp = this.getEffectiveMeltTemp(cell.structure);\n+        if (cell.heat > meltTemp) {\n+          if (cell.structure === StructureType.FuelRod) {\n+            meltdown = true;\n+          } else {\n+            meltedCells.push({ x, y, structure: cell.structure, tier: cell.tier });\n+          }\n+        }\n+      }\n+    }\n+\n+    // Melt non-fuel structures\n+    for (const { x, y, structure, tier } of meltedCells) {\n+      this.gridManager.resetCell(x, y);\n+      this.emitEvent({\n+        type: 'structure_melted',\n+        x,\n+        y,\n+        structure,\n+        tier,\n+      });\n+    }\n+\n+    if (meltdown) {\n+      this.gridManager.clearAll();\n+      this.emitEvent({ type: 'meltdown' });\n+    }\n+\n+    return meltdown;\n+  }\n+\n+  /**\n+   * Track high heat survival (for secret unlock)\n+   */\n+  trackHighHeatSurvival(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let hasHighHeatFuelRod = false;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+\n+        const meltTemp = this.getEffectiveMeltTemp(StructureType.FuelRod);\n+        if (cell.heat >= meltTemp * 0.9) {\n+          hasHighHeatFuelRod = true;\n+          break;\n+        }\n+      }\n+      if (hasHighHeatFuelRod) break;\n+    }\n+\n+    if (hasHighHeatFuelRod) {\n+      this.stats.ticksAtHighHeat++;\n+    }\n+  }\n+\n+  /**\n+   * Run a complete physics tick\n+   * Returns the money earned from power sales\n+   */\n+  tick(): { moneyEarned: number; meltdown: boolean } {\n+    this.processHeatGeneration();\n+    this.processFuelDepletion();\n+    this.processHeatTransfer();\n+    this.processHeatDissipation();\n+    this.processPowerGeneration();\n+    const moneyEarned = this.processPowerSale();\n+    const meltdown = this.processOverheating();\n+    this.trackHighHeatSurvival();\n+\n+    return { moneyEarned, meltdown };\n+  }\n+}\ndiff --git a/src/game/UpgradeManager.test.ts b/src/game/UpgradeManager.test.ts\nnew file mode 100644\nindex 0000000..a6d3f1a\n--- /dev/null\n+++ b/src/game/UpgradeManager.test.ts\n@@ -0,0 +1,318 @@\n+/**\n+ * Unit tests for UpgradeManager\n+ *\n+ * Tests upgrade purchasing, secret unlocking, and toggle states in isolation.\n+ */\n+\n+import { describe, it, expect, beforeEach } from 'vitest';\n+import { UpgradeManager, UpgradeEvent } from './UpgradeManager.js';\n+import { UpgradeType, SecretUpgradeType, UPGRADE_DEFINITIONS, SECRET_UPGRADE_DEFINITIONS } from './BalanceConfig.js';\n+\n+describe('UpgradeManager', () => {\n+  let upgradeManager: UpgradeManager;\n+\n+  beforeEach(() => {\n+    upgradeManager = new UpgradeManager();\n+  });\n+\n+  describe('initialization', () => {\n+    it('should start with all upgrades at level 0', () => {\n+      for (const type of Object.values(UpgradeType)) {\n+        expect(upgradeManager.getUpgradeLevel(type)).toBe(0);\n+      }\n+    });\n+\n+    it('should start with all secrets locked', () => {\n+      for (const type of Object.values(SecretUpgradeType)) {\n+        expect(upgradeManager.isSecretUnlocked(type)).toBe(false);\n+        expect(upgradeManager.isSecretPurchased(type)).toBe(false);\n+        expect(upgradeManager.isSecretEnabled(type)).toBe(false);\n+      }\n+    });\n+  });\n+\n+  describe('regular upgrades', () => {\n+    it('should return correct upgrade cost', () => {\n+      const cost = upgradeManager.getUpgradeCost(UpgradeType.FuelHeatOutput);\n+      expect(cost).toBeGreaterThan(0);\n+    });\n+\n+    it('should allow purchasing upgrades with enough money', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+      const cost = upgradeManager.getUpgradeCost(type);\n+\n+      expect(upgradeManager.canPurchaseUpgrade(type, cost)).toBe(true);\n+      expect(upgradeManager.canPurchaseUpgrade(type, cost - 1)).toBe(false);\n+    });\n+\n+    it('should increase level on purchase', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+      const cost = upgradeManager.getUpgradeCost(type);\n+\n+      const spent = upgradeManager.purchaseUpgrade(type, cost);\n+\n+      expect(spent).toBe(cost);\n+      expect(upgradeManager.getUpgradeLevel(type)).toBe(1);\n+    });\n+\n+    it('should return 0 if purchase fails', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+\n+      const spent = upgradeManager.purchaseUpgrade(type, 0);\n+\n+      expect(spent).toBe(0);\n+      expect(upgradeManager.getUpgradeLevel(type)).toBe(0);\n+    });\n+\n+    it('should increase cost after each purchase', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+      const initialCost = upgradeManager.getUpgradeCost(type);\n+\n+      upgradeManager.purchaseUpgrade(type, 1000000);\n+\n+      const newCost = upgradeManager.getUpgradeCost(type);\n+      expect(newCost).toBeGreaterThan(initialCost);\n+    });\n+\n+    it('should respect max level', () => {\n+      // TurbineConductivity has maxLevel: 10\n+      const type = UpgradeType.TurbineConductivity;\n+      const maxLevel = UPGRADE_DEFINITIONS[type].maxLevel;\n+\n+      // Purchase up to max level\n+      for (let i = 0; i < maxLevel; i++) {\n+        upgradeManager.purchaseUpgrade(type, 1000000000);\n+      }\n+\n+      expect(upgradeManager.getUpgradeLevel(type)).toBe(maxLevel);\n+      expect(upgradeManager.canPurchaseUpgrade(type, 1000000000)).toBe(false);\n+    });\n+\n+    it('should emit event on purchase', () => {\n+      const events: UpgradeEvent[] = [];\n+      upgradeManager.addEventListener(e => events.push(e));\n+\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+\n+      expect(events).toHaveLength(1);\n+      expect(events[0].type).toBe('upgrade_purchased');\n+      expect(events[0].upgradeType).toBe(UpgradeType.FuelHeatOutput);\n+    });\n+  });\n+\n+  describe('secret upgrades', () => {\n+    it('should return correct secret cost', () => {\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.Salvage);\n+      expect(cost).toBe(SECRET_UPGRADE_DEFINITIONS[SecretUpgradeType.Salvage].cost);\n+    });\n+\n+    it('should not allow purchasing locked secrets', () => {\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.Salvage, 1000000)).toBe(false);\n+    });\n+\n+    it('should not allow purchasing already purchased secrets', () => {\n+      // ExoticFuel requires 1 meltdown to unlock\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.ExoticFuel);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, cost);\n+\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.ExoticFuel, 1000000)).toBe(false);\n+    });\n+\n+    it('should unlock secrets based on stats', () => {\n+      // ExoticFuel requires 1 meltdown\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+\n+      const unlocked = upgradeManager.checkSecretUnlocks(stats);\n+\n+      expect(unlocked).toContain(SecretUpgradeType.ExoticFuel);\n+      expect(upgradeManager.isSecretUnlocked(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should emit event on secret unlock', () => {\n+      const events: UpgradeEvent[] = [];\n+      upgradeManager.addEventListener(e => events.push(e));\n+\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      expect(events.some(e => e.type === 'secret_unlocked')).toBe(true);\n+    });\n+\n+    it('should allow purchasing unlocked secrets with enough money', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.ExoticFuel);\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.ExoticFuel, cost)).toBe(true);\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.ExoticFuel, cost - 1)).toBe(false);\n+    });\n+\n+    it('should mark secret as purchased after buying', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.ExoticFuel);\n+      const spent = upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, cost);\n+\n+      expect(spent).toBe(cost);\n+      expect(upgradeManager.isSecretPurchased(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should emit event on secret purchase', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const events: UpgradeEvent[] = [];\n+      upgradeManager.addEventListener(e => events.push(e));\n+\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      expect(events.some(e => e.type === 'secret_purchased')).toBe(true);\n+    });\n+  });\n+\n+  describe('toggleable secrets', () => {\n+    it('should auto-enable toggleable secrets on purchase', () => {\n+      // Exotic fuel is toggleable, requires 1 meltdown\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should allow toggling purchased toggleable secrets', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.ExoticFuel, false);\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(false);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.ExoticFuel, true);\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should not toggle unpurchased secrets', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.ExoticFuel, true);\n+\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(false);\n+    });\n+\n+    it('should not toggle non-toggleable secrets', () => {\n+      // Salvage requires 100 demolishes and is not toggleable\n+      const stats = { meltdownCount: 0, filledCells: 0, totalMoneyEarned: 0, demolishCount: 100, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.Salvage, 1000000);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.Salvage, true);\n+\n+      // Salvage is not toggleable, so enabled should remain false\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.Salvage)).toBe(false);\n+    });\n+  });\n+\n+  describe('reactor expansion', () => {\n+    it('should return correct expansion size for reactor expansions', () => {\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion1)).toBe(17);\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion2)).toBe(18);\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion3)).toBe(19);\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion4)).toBe(20);\n+    });\n+\n+    it('should return null for non-expansion secrets', () => {\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.Salvage)).toBeNull();\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ExoticFuel)).toBeNull();\n+    });\n+  });\n+\n+  describe('serialization', () => {\n+    it('should get upgrade state for serialization', () => {\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+\n+      const state = upgradeManager.getUpgradeState();\n+\n+      expect(state.levels[UpgradeType.FuelHeatOutput]).toBe(2);\n+    });\n+\n+    it('should get secret state for serialization', () => {\n+      // ExoticFuel requires 1 meltdown\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      const state = upgradeManager.getSecretState();\n+\n+      expect(state.unlocked[SecretUpgradeType.ExoticFuel]).toBe(true);\n+      expect(state.purchased[SecretUpgradeType.ExoticFuel]).toBe(true);\n+    });\n+\n+    it('should restore upgrade state from serialization', () => {\n+      const state = upgradeManager.getUpgradeState();\n+      state.levels[UpgradeType.FuelHeatOutput] = 5;\n+\n+      const newManager = new UpgradeManager();\n+      newManager.restoreUpgradeState(state);\n+\n+      expect(newManager.getUpgradeLevel(UpgradeType.FuelHeatOutput)).toBe(5);\n+    });\n+\n+    it('should restore secret state from serialization', () => {\n+      const state = upgradeManager.getSecretState();\n+      state.unlocked[SecretUpgradeType.Salvage] = true;\n+      state.purchased[SecretUpgradeType.Salvage] = true;\n+\n+      const newManager = new UpgradeManager();\n+      newManager.restoreSecretState(state);\n+\n+      expect(newManager.isSecretUnlocked(SecretUpgradeType.Salvage)).toBe(true);\n+      expect(newManager.isSecretPurchased(SecretUpgradeType.Salvage)).toBe(true);\n+    });\n+  });\n+\n+  describe('event listeners', () => {\n+    it('should allow adding and removing listeners', () => {\n+      const events: UpgradeEvent[] = [];\n+      const listener = (e: UpgradeEvent) => events.push(e);\n+\n+      upgradeManager.addEventListener(listener);\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+      expect(events).toHaveLength(1);\n+\n+      upgradeManager.removeEventListener(listener);\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+      expect(events).toHaveLength(1); // No new events\n+    });\n+  });\n+\n+  describe('multiple unlock conditions', () => {\n+    it('should unlock multiple secrets when conditions are met', () => {\n+      // Stats that should unlock both Salvage (100 demolishes) and ExoticFuel (1 meltdown) and Overclock (10000 money)\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 10000, demolishCount: 100, ticksAtHighHeat: 0 };\n+\n+      const unlocked = upgradeManager.checkSecretUnlocks(stats);\n+\n+      expect(unlocked).toContain(SecretUpgradeType.ExoticFuel);\n+      expect(unlocked).toContain(SecretUpgradeType.Salvage);\n+      expect(unlocked).toContain(SecretUpgradeType.Overclock);\n+    });\n+\n+    it('should not re-unlock already unlocked secrets', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+\n+      const firstUnlock = upgradeManager.checkSecretUnlocks(stats);\n+      expect(firstUnlock).toContain(SecretUpgradeType.ExoticFuel);\n+\n+      const secondUnlock = upgradeManager.checkSecretUnlocks(stats);\n+      expect(secondUnlock).not.toContain(SecretUpgradeType.ExoticFuel);\n+    });\n+  });\n+});\ndiff --git a/src/game/UpgradeManager.ts b/src/game/UpgradeManager.ts\nnew file mode 100644\nindex 0000000..34d4ec4\n--- /dev/null\n+++ b/src/game/UpgradeManager.ts\n@@ -0,0 +1,299 @@\n+/**\n+ * UpgradeManager - Handles regular upgrades and secret upgrades\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ * This class manages upgrade purchasing, secret unlock conditions, and toggle states.\n+ */\n+\n+import {\n+  UpgradeType,\n+  UPGRADE_DEFINITIONS,\n+  SecretUpgradeType,\n+  SECRET_UPGRADE_DEFINITIONS,\n+  getUpgradeCost,\n+  getSecretUnlockProgress,\n+} from './BalanceConfig.js';\n+\n+export interface UpgradeState {\n+  levels: Record<UpgradeType, number>;\n+}\n+\n+export interface SecretState {\n+  unlocked: Record<SecretUpgradeType, boolean>;\n+  purchased: Record<SecretUpgradeType, boolean>;\n+  enabled: Record<SecretUpgradeType, boolean>;\n+}\n+\n+export interface UpgradeEvent {\n+  type: 'upgrade_purchased' | 'secret_unlocked' | 'secret_purchased';\n+  upgradeType?: UpgradeType;\n+  secretType?: SecretUpgradeType;\n+}\n+\n+export type UpgradeEventListener = (event: UpgradeEvent) => void;\n+\n+export interface UnlockStats {\n+  meltdownCount: number;\n+  filledCells: number;\n+  totalMoneyEarned: number;\n+  demolishCount: number;\n+  ticksAtHighHeat: number;\n+}\n+\n+/**\n+ * UpgradeManager handles all upgrade-related logic including:\n+ * - Regular upgrade purchasing and level tracking\n+ * - Secret upgrade unlocking, purchasing, and toggling\n+ */\n+export class UpgradeManager {\n+  private upgrades: UpgradeState;\n+  private secrets: SecretState;\n+  private eventListeners: UpgradeEventListener[] = [];\n+\n+  constructor() {\n+    this.upgrades = this.createInitialUpgradeState();\n+    this.secrets = this.createInitialSecretState();\n+  }\n+\n+  private createInitialUpgradeState(): UpgradeState {\n+    const levels: Record<UpgradeType, number> = {} as Record<UpgradeType, number>;\n+    for (const type of Object.values(UpgradeType)) {\n+      levels[type] = 0;\n+    }\n+    return { levels };\n+  }\n+\n+  private createInitialSecretState(): SecretState {\n+    const unlocked: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+    const purchased: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+    const enabled: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+\n+    for (const type of Object.values(SecretUpgradeType)) {\n+      unlocked[type] = false;\n+      purchased[type] = false;\n+      enabled[type] = false;\n+    }\n+    return { unlocked, purchased, enabled };\n+  }\n+\n+  /**\n+   * Add an event listener for upgrade events\n+   */\n+  addEventListener(listener: UpgradeEventListener): void {\n+    this.eventListeners.push(listener);\n+  }\n+\n+  /**\n+   * Remove an event listener\n+   */\n+  removeEventListener(listener: UpgradeEventListener): void {\n+    const index = this.eventListeners.indexOf(listener);\n+    if (index !== -1) {\n+      this.eventListeners.splice(index, 1);\n+    }\n+  }\n+\n+  private emitEvent(event: UpgradeEvent): void {\n+    for (const listener of this.eventListeners) {\n+      listener(event);\n+    }\n+  }\n+\n+  // ==========================================================================\n+  // REGULAR UPGRADES\n+  // ==========================================================================\n+\n+  /**\n+   * Get the current level of an upgrade\n+   */\n+  getUpgradeLevel(type: UpgradeType): number {\n+    return this.upgrades.levels[type];\n+  }\n+\n+  /**\n+   * Get the cost for the next level of an upgrade\n+   */\n+  getUpgradeCost(type: UpgradeType): number {\n+    const currentLevel = this.upgrades.levels[type];\n+    return getUpgradeCost(type, currentLevel);\n+  }\n+\n+  /**\n+   * Check if an upgrade can be purchased\n+   */\n+  canPurchaseUpgrade(type: UpgradeType, currentMoney: number): boolean {\n+    const definition = UPGRADE_DEFINITIONS[type];\n+    const currentLevel = this.upgrades.levels[type];\n+\n+    if (definition.maxLevel > 0 && currentLevel >= definition.maxLevel) {\n+      return false;\n+    }\n+\n+    const cost = getUpgradeCost(type, currentLevel);\n+    return currentMoney >= cost;\n+  }\n+\n+  /**\n+   * Purchase an upgrade\n+   * Returns the cost if successful, 0 if failed\n+   */\n+  purchaseUpgrade(type: UpgradeType, currentMoney: number): number {\n+    if (!this.canPurchaseUpgrade(type, currentMoney)) return 0;\n+\n+    const cost = getUpgradeCost(type, this.upgrades.levels[type]);\n+    this.upgrades.levels[type]++;\n+\n+    this.emitEvent({ type: 'upgrade_purchased', upgradeType: type });\n+    return cost;\n+  }\n+\n+  // ==========================================================================\n+  // SECRET UPGRADES\n+  // ==========================================================================\n+\n+  /**\n+   * Check if a secret upgrade is unlocked\n+   */\n+  isSecretUnlocked(type: SecretUpgradeType): boolean {\n+    return this.secrets.unlocked[type];\n+  }\n+\n+  /**\n+   * Check if a secret upgrade has been purchased\n+   */\n+  isSecretPurchased(type: SecretUpgradeType): boolean {\n+    return this.secrets.purchased[type];\n+  }\n+\n+  /**\n+   * Check if a toggleable secret is enabled\n+   */\n+  isSecretEnabled(type: SecretUpgradeType): boolean {\n+    return this.secrets.enabled[type];\n+  }\n+\n+  /**\n+   * Get the cost of a secret upgrade\n+   */\n+  getSecretCost(type: SecretUpgradeType): number {\n+    return SECRET_UPGRADE_DEFINITIONS[type].cost;\n+  }\n+\n+  /**\n+   * Check if a secret can be purchased\n+   */\n+  canPurchaseSecret(type: SecretUpgradeType, currentMoney: number): boolean {\n+    if (!this.secrets.unlocked[type]) return false;\n+    if (this.secrets.purchased[type]) return false;\n+\n+    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n+    return currentMoney >= cost;\n+  }\n+\n+  /**\n+   * Purchase a secret upgrade\n+   * Returns the cost if successful, 0 if failed\n+   */\n+  purchaseSecret(type: SecretUpgradeType, currentMoney: number): number {\n+    if (!this.canPurchaseSecret(type, currentMoney)) return 0;\n+\n+    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n+    this.secrets.purchased[type] = true;\n+\n+    // Auto-enable toggleable secrets\n+    if (SECRET_UPGRADE_DEFINITIONS[type].isToggle) {\n+      this.secrets.enabled[type] = true;\n+    }\n+\n+    this.emitEvent({ type: 'secret_purchased', secretType: type });\n+    return cost;\n+  }\n+\n+  /**\n+   * Toggle a secret upgrade on/off\n+   */\n+  toggleSecret(type: SecretUpgradeType, enabled: boolean): void {\n+    if (!this.secrets.purchased[type]) return;\n+    if (!SECRET_UPGRADE_DEFINITIONS[type].isToggle) return;\n+\n+    this.secrets.enabled[type] = enabled;\n+  }\n+\n+  /**\n+   * Check and unlock secrets based on current game stats\n+   * Returns array of newly unlocked secrets\n+   */\n+  checkSecretUnlocks(stats: UnlockStats): SecretUpgradeType[] {\n+    const newlyUnlocked: SecretUpgradeType[] = [];\n+\n+    for (const type of Object.values(SecretUpgradeType)) {\n+      if (this.secrets.unlocked[type]) continue;\n+\n+      const progress = getSecretUnlockProgress(type, stats);\n+      if (progress.unlocked) {\n+        this.secrets.unlocked[type] = true;\n+        newlyUnlocked.push(type);\n+        this.emitEvent({ type: 'secret_unlocked', secretType: type });\n+      }\n+    }\n+\n+    return newlyUnlocked;\n+  }\n+\n+  /**\n+   * Get the grid size expansion for a reactor expansion secret\n+   */\n+  getExpansionSize(type: SecretUpgradeType): number | null {\n+    switch (type) {\n+      case SecretUpgradeType.ReactorExpansion1: return 17;\n+      case SecretUpgradeType.ReactorExpansion2: return 18;\n+      case SecretUpgradeType.ReactorExpansion3: return 19;\n+      case SecretUpgradeType.ReactorExpansion4: return 20;\n+      default: return null;\n+    }\n+  }\n+\n+  // ==========================================================================\n+  // SERIALIZATION\n+  // ==========================================================================\n+\n+  /**\n+   * Get the current upgrade state for serialization\n+   */\n+  getUpgradeState(): UpgradeState {\n+    return {\n+      levels: { ...this.upgrades.levels },\n+    };\n+  }\n+\n+  /**\n+   * Get the current secret state for serialization\n+   */\n+  getSecretState(): SecretState {\n+    return {\n+      unlocked: { ...this.secrets.unlocked },\n+      purchased: { ...this.secrets.purchased },\n+      enabled: { ...this.secrets.enabled },\n+    };\n+  }\n+\n+  /**\n+   * Restore upgrade state from serialized data\n+   */\n+  restoreUpgradeState(state: UpgradeState): void {\n+    this.upgrades = {\n+      levels: { ...state.levels },\n+    };\n+  }\n+\n+  /**\n+   * Restore secret state from serialized data\n+   */\n+  restoreSecretState(state: SecretState): void {\n+    this.secrets = {\n+      unlocked: { ...state.unlocked },\n+      purchased: { ...state.purchased },\n+      enabled: { ...state.enabled },\n+    };\n+  }\n+}",
      "actualWorkers": 1
    },
    "preserveOutput": "always",
    "projects": [
      {
        "outputDir": "/home/runner/work/claudetest123/claudetest123/test-results",
        "repeatEach": 1,
        "retries": 2,
        "metadata": {
          "ci": {
            "commitHref": "https://github.com/bjuergens/claudetest123/commit/165ce2dddbaf7f3650602253c44314246c55b990",
            "commitHash": "165ce2dddbaf7f3650602253c44314246c55b990",
            "prHref": "https://github.com/bjuergens/claudetest123/pull/10",
            "prTitle": "Extract GridManager, PhysicsEngine, and UpgradeManager from HeatGame",
            "prBaseHash": "f29e01ec7cb04beabadc275fcf431907f165675e",
            "buildHref": "https://github.com/bjuergens/claudetest123/actions/runs/21544405470"
          },
          "gitCommit": {
            "shortHash": "165ce2d",
            "hash": "165ce2dddbaf7f3650602253c44314246c55b990",
            "subject": "Merge 50871673fe1c73a34bab1f0a44ec4cc76922c43c into f29e01ec7cb04beabadc275fcf431907f165675e",
            "body": "Merge 50871673fe1c73a34bab1f0a44ec4cc76922c43c into f29e01ec7cb04beabadc275fcf431907f165675e\n",
            "author": {
              "name": "Björn Jürgens",
              "email": "4362465+bjuergens@users.noreply.github.com",
              "time": 1769862093000
            },
            "committer": {
              "name": "GitHub",
              "email": "noreply@github.com",
              "time": 1769862093000
            },
            "branch": "HEAD"
          },
          "gitDiff": "diff --git a/src/game/GridManager.test.ts b/src/game/GridManager.test.ts\nnew file mode 100644\nindex 0000000..468ae34\n--- /dev/null\n+++ b/src/game/GridManager.test.ts\n@@ -0,0 +1,277 @@\n+/**\n+ * Unit tests for GridManager\n+ *\n+ * Tests grid creation, neighbor calculations, and cell operations in isolation.\n+ */\n+\n+import { describe, it, expect, beforeEach } from 'vitest';\n+import { GridManager } from './GridManager.js';\n+import { StructureType, Tier } from './BalanceConfig.js';\n+\n+describe('GridManager', () => {\n+  let gridManager: GridManager;\n+\n+  beforeEach(() => {\n+    gridManager = new GridManager(16);\n+  });\n+\n+  describe('initialization', () => {\n+    it('should create a grid of the specified size', () => {\n+      expect(gridManager.getSize()).toBe(16);\n+    });\n+\n+    it('should initialize all cells as empty', () => {\n+      const snapshot = gridManager.getSnapshot();\n+      for (let y = 0; y < 16; y++) {\n+        for (let x = 0; x < 16; x++) {\n+          expect(snapshot[y][x].structure).toBe(StructureType.Empty);\n+          expect(snapshot[y][x].heat).toBe(0);\n+          expect(snapshot[y][x].power).toBe(0);\n+        }\n+      }\n+    });\n+\n+    it('should set correct x,y coordinates for each cell', () => {\n+      const snapshot = gridManager.getSnapshot();\n+      for (let y = 0; y < 16; y++) {\n+        for (let x = 0; x < 16; x++) {\n+          expect(snapshot[y][x].x).toBe(x);\n+          expect(snapshot[y][x].y).toBe(y);\n+        }\n+      }\n+    });\n+  });\n+\n+  describe('getCell', () => {\n+    it('should return a copy of the cell at valid coordinates', () => {\n+      const cell = gridManager.getCell(5, 5);\n+      expect(cell).not.toBeNull();\n+      expect(cell!.x).toBe(5);\n+      expect(cell!.y).toBe(5);\n+    });\n+\n+    it('should return null for out-of-bounds coordinates', () => {\n+      expect(gridManager.getCell(-1, 0)).toBeNull();\n+      expect(gridManager.getCell(0, -1)).toBeNull();\n+      expect(gridManager.getCell(16, 0)).toBeNull();\n+      expect(gridManager.getCell(0, 16)).toBeNull();\n+    });\n+\n+    it('should return a copy, not a reference', () => {\n+      const cell = gridManager.getCell(5, 5);\n+      cell!.heat = 100;\n+      const cellAgain = gridManager.getCell(5, 5);\n+      expect(cellAgain!.heat).toBe(0);\n+    });\n+  });\n+\n+  describe('getCellRef', () => {\n+    it('should return a reference that can be mutated', () => {\n+      const cellRef = gridManager.getCellRef(5, 5);\n+      cellRef!.heat = 100;\n+      const cell = gridManager.getCell(5, 5);\n+      expect(cell!.heat).toBe(100);\n+    });\n+\n+    it('should return null for out-of-bounds coordinates', () => {\n+      expect(gridManager.getCellRef(-1, 0)).toBeNull();\n+      expect(gridManager.getCellRef(16, 0)).toBeNull();\n+    });\n+  });\n+\n+  describe('isValidPosition', () => {\n+    it('should return true for valid positions', () => {\n+      expect(gridManager.isValidPosition(0, 0)).toBe(true);\n+      expect(gridManager.isValidPosition(15, 15)).toBe(true);\n+      expect(gridManager.isValidPosition(8, 8)).toBe(true);\n+    });\n+\n+    it('should return false for invalid positions', () => {\n+      expect(gridManager.isValidPosition(-1, 0)).toBe(false);\n+      expect(gridManager.isValidPosition(0, -1)).toBe(false);\n+      expect(gridManager.isValidPosition(16, 0)).toBe(false);\n+      expect(gridManager.isValidPosition(0, 16)).toBe(false);\n+    });\n+  });\n+\n+  describe('getNeighbors', () => {\n+    it('should return 4 neighbors for center cells', () => {\n+      const neighbors = gridManager.getNeighbors(8, 8);\n+      expect(neighbors).toHaveLength(4);\n+    });\n+\n+    it('should return 3 neighbors for edge cells', () => {\n+      const neighbors = gridManager.getNeighbors(0, 8);\n+      expect(neighbors).toHaveLength(3);\n+    });\n+\n+    it('should return 2 neighbors for corner cells', () => {\n+      const neighbors = gridManager.getNeighbors(0, 0);\n+      expect(neighbors).toHaveLength(2);\n+    });\n+\n+    it('should return orthogonal neighbors only', () => {\n+      const neighbors = gridManager.getNeighbors(5, 5);\n+      const positions = neighbors.map(n => ({ x: n.x, y: n.y }));\n+\n+      expect(positions).toContainEqual({ x: 5, y: 4 }); // up\n+      expect(positions).toContainEqual({ x: 5, y: 6 }); // down\n+      expect(positions).toContainEqual({ x: 4, y: 5 }); // left\n+      expect(positions).toContainEqual({ x: 6, y: 5 }); // right\n+    });\n+  });\n+\n+  describe('countAdjacentFuelRods', () => {\n+    it('should return 0 when no fuel rods are adjacent', () => {\n+      expect(gridManager.countAdjacentFuelRods(5, 5)).toBe(0);\n+    });\n+\n+    it('should count active fuel rods only', () => {\n+      // Place active fuel rod\n+      const cell1 = gridManager.getCellRef(5, 4)!;\n+      cell1.structure = StructureType.FuelRod;\n+      cell1.lifetime = 100;\n+\n+      // Place depleted fuel rod\n+      const cell2 = gridManager.getCellRef(5, 6)!;\n+      cell2.structure = StructureType.FuelRod;\n+      cell2.lifetime = 0;\n+\n+      expect(gridManager.countAdjacentFuelRods(5, 5)).toBe(1);\n+    });\n+\n+    it('should count all adjacent active fuel rods', () => {\n+      const positions = [\n+        { x: 5, y: 4 },\n+        { x: 5, y: 6 },\n+        { x: 4, y: 5 },\n+        { x: 6, y: 5 },\n+      ];\n+\n+      for (const pos of positions) {\n+        const cell = gridManager.getCellRef(pos.x, pos.y)!;\n+        cell.structure = StructureType.FuelRod;\n+        cell.lifetime = 100;\n+      }\n+\n+      expect(gridManager.countAdjacentFuelRods(5, 5)).toBe(4);\n+    });\n+  });\n+\n+  describe('getFilledCellCount', () => {\n+    it('should return 0 for empty grid', () => {\n+      expect(gridManager.getFilledCellCount()).toBe(0);\n+    });\n+\n+    it('should count non-empty cells', () => {\n+      gridManager.getCellRef(0, 0)!.structure = StructureType.FuelRod;\n+      gridManager.getCellRef(1, 1)!.structure = StructureType.Turbine;\n+      gridManager.getCellRef(2, 2)!.structure = StructureType.Ventilator;\n+\n+      expect(gridManager.getFilledCellCount()).toBe(3);\n+    });\n+  });\n+\n+  describe('expandGrid', () => {\n+    it('should expand grid to new size', () => {\n+      gridManager.getCellRef(5, 5)!.structure = StructureType.FuelRod;\n+\n+      const result = gridManager.expandGrid(18, 20);\n+      expect(result).toBe(true);\n+      expect(gridManager.getSize()).toBe(18);\n+    });\n+\n+    it('should preserve existing cells after expansion', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.heat = 500;\n+\n+      gridManager.expandGrid(18, 20);\n+\n+      const preserved = gridManager.getCell(5, 5);\n+      expect(preserved!.structure).toBe(StructureType.FuelRod);\n+      expect(preserved!.heat).toBe(500);\n+    });\n+\n+    it('should not expand beyond max size', () => {\n+      const result = gridManager.expandGrid(25, 20);\n+      expect(result).toBe(false);\n+      expect(gridManager.getSize()).toBe(16);\n+    });\n+\n+    it('should not shrink the grid', () => {\n+      const result = gridManager.expandGrid(10, 20);\n+      expect(result).toBe(false);\n+      expect(gridManager.getSize()).toBe(16);\n+    });\n+  });\n+\n+  describe('resetCell', () => {\n+    it('should reset a cell to empty state', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.Turbine;\n+      cell.heat = 500;\n+      cell.power = 100;\n+\n+      gridManager.resetCell(5, 5);\n+\n+      const reset = gridManager.getCell(5, 5);\n+      expect(reset!.structure).toBe(StructureType.Empty);\n+      expect(reset!.heat).toBe(0);\n+      expect(reset!.power).toBe(0);\n+    });\n+\n+    it('should preserve coordinates after reset', () => {\n+      gridManager.resetCell(5, 5);\n+      const cell = gridManager.getCell(5, 5);\n+      expect(cell!.x).toBe(5);\n+      expect(cell!.y).toBe(5);\n+    });\n+  });\n+\n+  describe('clearAll', () => {\n+    it('should reset all cells to empty', () => {\n+      // Fill some cells\n+      for (let i = 0; i < 5; i++) {\n+        gridManager.getCellRef(i, i)!.structure = StructureType.FuelRod;\n+      }\n+\n+      gridManager.clearAll();\n+\n+      expect(gridManager.getFilledCellCount()).toBe(0);\n+    });\n+  });\n+\n+  describe('forEach', () => {\n+    it('should iterate over all cells', () => {\n+      let count = 0;\n+      gridManager.forEach(() => count++);\n+      expect(count).toBe(16 * 16);\n+    });\n+\n+    it('should provide correct cell references', () => {\n+      gridManager.forEach((cell, x, y) => {\n+        expect(cell.x).toBe(x);\n+        expect(cell.y).toBe(y);\n+      });\n+    });\n+  });\n+\n+  describe('restoreFromState', () => {\n+    it('should restore grid from serialized state', () => {\n+      // Create a state to restore\n+      const state = gridManager.getSnapshot();\n+      state[5][5].structure = StructureType.Turbine;\n+      state[5][5].heat = 250;\n+\n+      // Create new grid manager and restore\n+      const newGridManager = new GridManager(10);\n+      newGridManager.restoreFromState(state, 16);\n+\n+      expect(newGridManager.getSize()).toBe(16);\n+      const cell = newGridManager.getCell(5, 5);\n+      expect(cell!.structure).toBe(StructureType.Turbine);\n+      expect(cell!.heat).toBe(250);\n+    });\n+  });\n+});\ndiff --git a/src/game/GridManager.ts b/src/game/GridManager.ts\nnew file mode 100644\nindex 0000000..0e158a8\n--- /dev/null\n+++ b/src/game/GridManager.ts\n@@ -0,0 +1,221 @@\n+/**\n+ * GridManager - Handles grid creation, neighbor calculations, and cell operations\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ */\n+\n+import { StructureType, Tier } from './BalanceConfig.js';\n+\n+export interface Cell {\n+  x: number;\n+  y: number;\n+  structure: StructureType;\n+  tier: Tier;\n+  heat: number;\n+  power: number;\n+  /** Remaining lifetime in ticks (fuel rods only, 0 = infinite/depleted) */\n+  lifetime: number;\n+  /** Whether this is an exotic variant (fuel rods only) */\n+  isExotic: boolean;\n+}\n+\n+export class GridManager {\n+  private grid: Cell[][];\n+  private gridSize: number;\n+\n+  constructor(initialSize: number) {\n+    this.gridSize = initialSize;\n+    this.grid = this.createEmptyGrid(initialSize);\n+  }\n+\n+  /**\n+   * Create a new empty grid of the specified size\n+   */\n+  createEmptyGrid(size: number): Cell[][] {\n+    const grid: Cell[][] = [];\n+    for (let y = 0; y < size; y++) {\n+      const row: Cell[] = [];\n+      for (let x = 0; x < size; x++) {\n+        row.push(this.createEmptyCell(x, y));\n+      }\n+      grid.push(row);\n+    }\n+    return grid;\n+  }\n+\n+  /**\n+   * Create an empty cell at the specified coordinates\n+   */\n+  createEmptyCell(x: number, y: number): Cell {\n+    return {\n+      x,\n+      y,\n+      structure: StructureType.Empty,\n+      tier: Tier.T1,\n+      heat: 0,\n+      power: 0,\n+      lifetime: 0,\n+      isExotic: false,\n+    };\n+  }\n+\n+  /**\n+   * Get a copy of a cell at the specified coordinates\n+   * Returns null if coordinates are out of bounds\n+   */\n+  getCell(x: number, y: number): Cell | null {\n+    if (!this.isValidPosition(x, y)) {\n+      return null;\n+    }\n+    return { ...this.grid[y][x] };\n+  }\n+\n+  /**\n+   * Get a direct reference to a cell (for mutation)\n+   * Returns null if coordinates are out of bounds\n+   */\n+  getCellRef(x: number, y: number): Cell | null {\n+    if (!this.isValidPosition(x, y)) {\n+      return null;\n+    }\n+    return this.grid[y][x];\n+  }\n+\n+  /**\n+   * Check if coordinates are within grid bounds\n+   */\n+  isValidPosition(x: number, y: number): boolean {\n+    return x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize;\n+  }\n+\n+  /**\n+   * Get the current grid size\n+   */\n+  getSize(): number {\n+    return this.gridSize;\n+  }\n+\n+  /**\n+   * Get a snapshot (deep copy) of the entire grid\n+   */\n+  getSnapshot(): Cell[][] {\n+    return this.grid.map(row => row.map(cell => ({ ...cell })));\n+  }\n+\n+  /**\n+   * Get the internal grid reference (for physics engine)\n+   */\n+  getGridRef(): Cell[][] {\n+    return this.grid;\n+  }\n+\n+  /**\n+   * Get orthogonal neighbors (up, down, left, right) of a cell\n+   */\n+  getNeighbors(x: number, y: number): Cell[] {\n+    const neighbors: Cell[] = [];\n+    const directions = [\n+      { dx: 0, dy: -1 }, // up\n+      { dx: 0, dy: 1 },  // down\n+      { dx: -1, dy: 0 }, // left\n+      { dx: 1, dy: 0 },  // right\n+    ];\n+\n+    for (const { dx, dy } of directions) {\n+      const nx = x + dx;\n+      const ny = y + dy;\n+      if (this.isValidPosition(nx, ny)) {\n+        neighbors.push(this.grid[ny][nx]);\n+      }\n+    }\n+\n+    return neighbors;\n+  }\n+\n+  /**\n+   * Count active (non-depleted) fuel rods adjacent to a position\n+   */\n+  countAdjacentFuelRods(x: number, y: number): number {\n+    const neighbors = this.getNeighbors(x, y);\n+    return neighbors.filter(n => n.structure === StructureType.FuelRod && n.lifetime > 0).length;\n+  }\n+\n+  /**\n+   * Count filled (non-empty) cells in the grid\n+   */\n+  getFilledCellCount(): number {\n+    let count = 0;\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        if (this.grid[y][x].structure !== StructureType.Empty) {\n+          count++;\n+        }\n+      }\n+    }\n+    return count;\n+  }\n+\n+  /**\n+   * Expand the grid to a new size, preserving existing cells\n+   * Returns true if expansion was successful\n+   */\n+  expandGrid(newSize: number, maxSize: number): boolean {\n+    if (newSize <= this.gridSize) return false;\n+    if (newSize > maxSize) return false;\n+\n+    const oldGrid = this.grid;\n+    const oldSize = this.gridSize;\n+\n+    // Create new larger grid\n+    this.grid = this.createEmptyGrid(newSize);\n+    this.gridSize = newSize;\n+\n+    // Copy old grid data\n+    for (let y = 0; y < oldSize; y++) {\n+      for (let x = 0; x < oldSize; x++) {\n+        this.grid[y][x] = { ...oldGrid[y][x] };\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Reset a cell to empty state\n+   */\n+  resetCell(x: number, y: number): void {\n+    if (this.isValidPosition(x, y)) {\n+      this.grid[y][x] = this.createEmptyCell(x, y);\n+    }\n+  }\n+\n+  /**\n+   * Clear all cells in the grid (reset to empty)\n+   */\n+  clearAll(): void {\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        this.grid[y][x] = this.createEmptyCell(x, y);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Iterate over all cells, calling the callback for each\n+   */\n+  forEach(callback: (cell: Cell, x: number, y: number) => void): void {\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        callback(this.grid[y][x], x, y);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Restore grid state from serialized data\n+   */\n+  restoreFromState(grid: Cell[][], gridSize: number): void {\n+    this.gridSize = gridSize;\n+    this.grid = grid.map(row => row.map(cell => ({ ...cell })));\n+  }\n+}\ndiff --git a/src/game/PhysicsEngine.test.ts b/src/game/PhysicsEngine.test.ts\nnew file mode 100644\nindex 0000000..f49b67b\n--- /dev/null\n+++ b/src/game/PhysicsEngine.test.ts\n@@ -0,0 +1,460 @@\n+/**\n+ * Unit tests for PhysicsEngine\n+ *\n+ * Tests heat generation, transfer, dissipation, and power generation in isolation.\n+ */\n+\n+import { describe, it, expect, beforeEach, vi } from 'vitest';\n+import { GridManager } from './GridManager.js';\n+import { PhysicsEngine, PhysicsEvent } from './PhysicsEngine.js';\n+import { StructureType, Tier, UpgradeType, STRUCTURE_BASE_STATS, getFuelLifetime } from './BalanceConfig.js';\n+\n+describe('PhysicsEngine', () => {\n+  let gridManager: GridManager;\n+  let physicsEngine: PhysicsEngine;\n+  let upgradeLevels: Map<UpgradeType, number>;\n+\n+  const getUpgradeLevel = (type: UpgradeType) => upgradeLevels.get(type) ?? 0;\n+\n+  beforeEach(() => {\n+    gridManager = new GridManager(16);\n+    upgradeLevels = new Map();\n+    physicsEngine = new PhysicsEngine(gridManager, getUpgradeLevel);\n+  });\n+\n+  describe('heat generation', () => {\n+    it('should generate heat from active fuel rods', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.tier = Tier.T1;\n+      cell.lifetime = 100;\n+\n+      physicsEngine.processHeatGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeGreaterThan(0);\n+    });\n+\n+    it('should not generate heat from depleted fuel rods', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.tier = Tier.T1;\n+      cell.lifetime = 0; // depleted\n+\n+      physicsEngine.processHeatGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBe(0);\n+    });\n+\n+    it('should apply adjacency bonus for neighboring fuel rods', () => {\n+      // Place center fuel rod\n+      const center = gridManager.getCellRef(5, 5)!;\n+      center.structure = StructureType.FuelRod;\n+      center.tier = Tier.T1;\n+      center.lifetime = 100;\n+\n+      // Get baseline heat generation\n+      physicsEngine.processHeatGeneration();\n+      const baseHeat = gridManager.getCell(5, 5)!.heat;\n+\n+      // Reset and add adjacent fuel rod\n+      gridManager.getCellRef(5, 5)!.heat = 0;\n+      const adjacent = gridManager.getCellRef(5, 4)!;\n+      adjacent.structure = StructureType.FuelRod;\n+      adjacent.tier = Tier.T1;\n+      adjacent.lifetime = 100;\n+\n+      physicsEngine.processHeatGeneration();\n+      const boostedHeat = gridManager.getCell(5, 5)!.heat;\n+\n+      expect(boostedHeat).toBeGreaterThan(baseHeat);\n+    });\n+\n+    it('should generate more heat for higher tiers', () => {\n+      const cell1 = gridManager.getCellRef(3, 3)!;\n+      cell1.structure = StructureType.FuelRod;\n+      cell1.tier = Tier.T1;\n+      cell1.lifetime = 100;\n+\n+      const cell2 = gridManager.getCellRef(8, 8)!;\n+      cell2.structure = StructureType.FuelRod;\n+      cell2.tier = Tier.T2;\n+      cell2.lifetime = 100;\n+\n+      physicsEngine.processHeatGeneration();\n+\n+      expect(gridManager.getCell(8, 8)!.heat).toBeGreaterThan(gridManager.getCell(3, 3)!.heat);\n+    });\n+  });\n+\n+  describe('fuel depletion', () => {\n+    it('should decrease fuel lifetime each tick', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 100;\n+\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(gridManager.getCell(5, 5)!.lifetime).toBe(99);\n+    });\n+\n+    it('should emit event when fuel is depleted', () => {\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(events).toHaveLength(1);\n+      expect(events[0].type).toBe('fuel_depleted');\n+      expect(events[0].x).toBe(5);\n+      expect(events[0].y).toBe(5);\n+    });\n+\n+    it('should track depleted fuel rods in stats', () => {\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(physicsEngine.getStats().fuelRodsDepleted).toBe(1);\n+    });\n+  });\n+\n+  describe('heat transfer', () => {\n+    it('should transfer heat from hot to cold cells', () => {\n+      const hotCell = gridManager.getCellRef(5, 5)!;\n+      hotCell.heat = 1000;\n+\n+      const coldCell = gridManager.getCellRef(5, 6)!;\n+      coldCell.heat = 0;\n+\n+      physicsEngine.processHeatTransfer();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeLessThan(1000);\n+      expect(gridManager.getCell(5, 6)!.heat).toBeGreaterThan(0);\n+    });\n+\n+    it('should respect conductivity differences', () => {\n+      // Place insulator (low conductivity) and regular cell\n+      const insulator = gridManager.getCellRef(5, 5)!;\n+      insulator.structure = StructureType.Insulator;\n+      insulator.heat = 1000;\n+\n+      physicsEngine.processHeatTransfer();\n+      const insulatorHeatAfter = gridManager.getCell(5, 5)!.heat;\n+\n+      // Compare with empty cell\n+      gridManager.getCellRef(5, 5)!.structure = StructureType.Empty;\n+      gridManager.getCellRef(5, 5)!.heat = 1000;\n+\n+      physicsEngine.processHeatTransfer();\n+      const emptyHeatAfter = gridManager.getCell(5, 5)!.heat;\n+\n+      // Insulator should retain more heat due to low conductivity\n+      expect(insulatorHeatAfter).toBeGreaterThan(emptyHeatAfter);\n+    });\n+\n+    it('should lose heat to environment at edges', () => {\n+      // Place heat at corner (2 edges exposed)\n+      const corner = gridManager.getCellRef(0, 0)!;\n+      corner.heat = 1000;\n+\n+      physicsEngine.processHeatTransfer();\n+\n+      expect(gridManager.getCell(0, 0)!.heat).toBeLessThan(1000);\n+    });\n+  });\n+\n+  describe('heat dissipation', () => {\n+    it('should dissipate heat from ventilators', () => {\n+      const vent = gridManager.getCellRef(5, 5)!;\n+      vent.structure = StructureType.Ventilator;\n+      vent.tier = Tier.T1;\n+      vent.heat = 100;\n+\n+      physicsEngine.processHeatDissipation();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeLessThan(100);\n+    });\n+\n+    it('should not go below zero heat', () => {\n+      const vent = gridManager.getCellRef(5, 5)!;\n+      vent.structure = StructureType.Ventilator;\n+      vent.tier = Tier.T1;\n+      vent.heat = 1; // Very low heat\n+\n+      physicsEngine.processHeatDissipation();\n+\n+      expect(gridManager.getCell(5, 5)!.heat).toBeGreaterThanOrEqual(0);\n+    });\n+\n+    it('should dissipate more heat for higher tier ventilators', () => {\n+      const vent1 = gridManager.getCellRef(3, 3)!;\n+      vent1.structure = StructureType.Ventilator;\n+      vent1.tier = Tier.T1;\n+      vent1.heat = 500;\n+\n+      const vent2 = gridManager.getCellRef(8, 8)!;\n+      vent2.structure = StructureType.Ventilator;\n+      vent2.tier = Tier.T2;\n+      vent2.heat = 500;\n+\n+      physicsEngine.processHeatDissipation();\n+\n+      // T2 should dissipate more, leaving less heat\n+      expect(gridManager.getCell(8, 8)!.heat).toBeLessThan(gridManager.getCell(3, 3)!.heat);\n+    });\n+  });\n+\n+  describe('power generation', () => {\n+    it('should generate power from turbines with heat', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = 100;\n+\n+      physicsEngine.processPowerGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.power).toBeGreaterThan(0);\n+      expect(gridManager.getCell(5, 5)!.heat).toBeLessThan(100);\n+    });\n+\n+    it('should not generate power without heat', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = 0;\n+\n+      physicsEngine.processPowerGeneration();\n+\n+      expect(gridManager.getCell(5, 5)!.power).toBe(0);\n+    });\n+\n+    it('should track total power generated in stats', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = 100;\n+\n+      physicsEngine.processPowerGeneration();\n+\n+      expect(physicsEngine.getStats().totalPowerGenerated).toBeGreaterThan(0);\n+    });\n+  });\n+\n+  describe('power sale', () => {\n+    it('should transfer power from turbine to adjacent substation', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.power = 100;\n+\n+      const substation = gridManager.getCellRef(5, 6)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+\n+      physicsEngine.processPowerSale();\n+\n+      // Turbine should have transferred power\n+      expect(gridManager.getCell(5, 5)!.power).toBe(0);\n+      // Substation receives power but also sells some (saleRate applies)\n+      // Just verify it received the power (it may sell some immediately)\n+      expect(physicsEngine.getStats().totalMoneyEarned).toBeGreaterThan(0);\n+    });\n+\n+    it('should sell power from substations and return earnings', () => {\n+      const substation = gridManager.getCellRef(5, 5)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+      substation.power = 100;\n+\n+      const earnings = physicsEngine.processPowerSale();\n+\n+      expect(earnings).toBeGreaterThan(0);\n+      expect(gridManager.getCell(5, 5)!.power).toBeLessThan(100);\n+    });\n+\n+    it('should emit power_sold event', () => {\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      const substation = gridManager.getCellRef(5, 5)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+      substation.power = 100;\n+\n+      physicsEngine.processPowerSale();\n+\n+      expect(events.some(e => e.type === 'power_sold')).toBe(true);\n+    });\n+  });\n+\n+  describe('overheating', () => {\n+    it('should melt structures that exceed melt temperature', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+      turbine.heat = STRUCTURE_BASE_STATS[StructureType.Turbine].meltTemp + 100;\n+\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      physicsEngine.processOverheating();\n+\n+      expect(gridManager.getCell(5, 5)!.structure).toBe(StructureType.Empty);\n+      expect(events.some(e => e.type === 'structure_melted')).toBe(true);\n+    });\n+\n+    it('should trigger meltdown when fuel rod overheats', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp + 100;\n+\n+      const events: PhysicsEvent[] = [];\n+      physicsEngine.addEventListener(e => events.push(e));\n+\n+      const meltdown = physicsEngine.processOverheating();\n+\n+      expect(meltdown).toBe(true);\n+      expect(events.some(e => e.type === 'meltdown')).toBe(true);\n+    });\n+\n+    it('should clear entire grid on meltdown', () => {\n+      // Place some structures\n+      gridManager.getCellRef(3, 3)!.structure = StructureType.Turbine;\n+      gridManager.getCellRef(8, 8)!.structure = StructureType.Ventilator;\n+\n+      // Trigger meltdown\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp + 100;\n+\n+      physicsEngine.processOverheating();\n+\n+      expect(gridManager.getFilledCellCount()).toBe(0);\n+    });\n+  });\n+\n+  describe('high heat tracking', () => {\n+    it('should track ticks at high heat', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      // Set heat to 90% of melt temp\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp * 0.91;\n+\n+      physicsEngine.trackHighHeatSurvival();\n+\n+      expect(physicsEngine.getStats().ticksAtHighHeat).toBe(1);\n+    });\n+\n+    it('should not track when below 90% melt temp', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp * 0.5;\n+\n+      physicsEngine.trackHighHeatSurvival();\n+\n+      expect(physicsEngine.getStats().ticksAtHighHeat).toBe(0);\n+    });\n+  });\n+\n+  describe('effective stats with upgrades', () => {\n+    it('should increase melt temp with upgrades', () => {\n+      const baseMeltTemp = physicsEngine.getEffectiveMeltTemp(StructureType.FuelRod);\n+\n+      upgradeLevels.set(UpgradeType.MeltTempFuelRod, 3);\n+      const upgradedMeltTemp = physicsEngine.getEffectiveMeltTemp(StructureType.FuelRod);\n+\n+      expect(upgradedMeltTemp).toBeGreaterThan(baseMeltTemp);\n+    });\n+\n+    it('should increase turbine conductivity with upgrades', () => {\n+      const turbine = gridManager.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+\n+      const baseConductivity = physicsEngine.getEffectiveConductivity(turbine);\n+\n+      upgradeLevels.set(UpgradeType.TurbineConductivity, 2);\n+      const upgradedConductivity = physicsEngine.getEffectiveConductivity(turbine);\n+\n+      expect(upgradedConductivity).toBeGreaterThan(baseConductivity);\n+    });\n+\n+    it('should decrease insulator conductivity with upgrades', () => {\n+      const insulator = gridManager.getCellRef(5, 5)!;\n+      insulator.structure = StructureType.Insulator;\n+\n+      const baseConductivity = physicsEngine.getEffectiveConductivity(insulator);\n+\n+      upgradeLevels.set(UpgradeType.InsulatorConductivity, 2);\n+      const upgradedConductivity = physicsEngine.getEffectiveConductivity(insulator);\n+\n+      expect(upgradedConductivity).toBeLessThan(baseConductivity);\n+    });\n+  });\n+\n+  describe('tick', () => {\n+    it('should run all physics phases', () => {\n+      // Set up a simple reactor\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.tier = Tier.T1;\n+      fuelRod.lifetime = 100;\n+\n+      const turbine = gridManager.getCellRef(5, 6)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.tier = Tier.T1;\n+\n+      const substation = gridManager.getCellRef(5, 7)!;\n+      substation.structure = StructureType.Substation;\n+      substation.tier = Tier.T1;\n+\n+      const result = physicsEngine.tick();\n+\n+      expect(result.moneyEarned).toBeGreaterThanOrEqual(0);\n+      expect(result.meltdown).toBe(false);\n+    });\n+\n+    it('should report meltdown in tick result', () => {\n+      const fuelRod = gridManager.getCellRef(5, 5)!;\n+      fuelRod.structure = StructureType.FuelRod;\n+      fuelRod.lifetime = 100; // Active fuel rod\n+      // Set very high heat to ensure it still exceeds meltTemp after heat transfer/dissipation\n+      fuelRod.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp * 2;\n+\n+      const result = physicsEngine.tick();\n+\n+      expect(result.meltdown).toBe(true);\n+    });\n+  });\n+\n+  describe('event listeners', () => {\n+    it('should allow adding and removing listeners', () => {\n+      const events: PhysicsEvent[] = [];\n+      const listener = (e: PhysicsEvent) => events.push(e);\n+\n+      physicsEngine.addEventListener(listener);\n+\n+      const cell = gridManager.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+\n+      physicsEngine.processFuelDepletion();\n+      expect(events).toHaveLength(1);\n+\n+      physicsEngine.removeEventListener(listener);\n+\n+      cell.structure = StructureType.FuelRod;\n+      cell.lifetime = 1;\n+      physicsEngine.processFuelDepletion();\n+\n+      expect(events).toHaveLength(1); // No new events\n+    });\n+  });\n+});\ndiff --git a/src/game/PhysicsEngine.ts b/src/game/PhysicsEngine.ts\nnew file mode 100644\nindex 0000000..ef4c504\n--- /dev/null\n+++ b/src/game/PhysicsEngine.ts\n@@ -0,0 +1,483 @@\n+/**\n+ * PhysicsEngine - Handles heat generation, transfer, dissipation, and power generation\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ * This class is responsible for all physics simulation logic.\n+ */\n+\n+import {\n+  CORE_SETTINGS,\n+  StructureType,\n+  Tier,\n+  STRUCTURE_BASE_STATS,\n+  FUEL_ADJACENCY,\n+  ECONOMY,\n+  UpgradeType,\n+  UPGRADE_DEFINITIONS,\n+  EXOTIC_FUEL,\n+  getFuelHeatGeneration,\n+} from './BalanceConfig.js';\n+import { Cell, GridManager } from './GridManager.js';\n+\n+export interface PhysicsEvent {\n+  type: 'fuel_depleted' | 'power_sold' | 'structure_melted' | 'meltdown';\n+  x?: number;\n+  y?: number;\n+  tier?: Tier;\n+  structure?: StructureType;\n+  amount?: number;\n+}\n+\n+export type PhysicsEventListener = (event: PhysicsEvent) => void;\n+\n+export interface UpgradeLevels {\n+  [key: string]: number;\n+}\n+\n+export interface PhysicsStats {\n+  totalPowerGenerated: number;\n+  totalMoneyEarned: number;\n+  fuelRodsDepleted: number;\n+  ticksAtHighHeat: number;\n+}\n+\n+/**\n+ * PhysicsEngine handles all physics simulation for the heat game.\n+ * It operates on a GridManager and uses upgrade levels for calculations.\n+ */\n+export class PhysicsEngine {\n+  private eventListeners: PhysicsEventListener[] = [];\n+  private stats: PhysicsStats = {\n+    totalPowerGenerated: 0,\n+    totalMoneyEarned: 0,\n+    fuelRodsDepleted: 0,\n+    ticksAtHighHeat: 0,\n+  };\n+\n+  constructor(\n+    private gridManager: GridManager,\n+    private getUpgradeLevel: (type: UpgradeType) => number\n+  ) {}\n+\n+  /**\n+   * Add an event listener for physics events\n+   */\n+  addEventListener(listener: PhysicsEventListener): void {\n+    this.eventListeners.push(listener);\n+  }\n+\n+  /**\n+   * Remove an event listener\n+   */\n+  removeEventListener(listener: PhysicsEventListener): void {\n+    const index = this.eventListeners.indexOf(listener);\n+    if (index !== -1) {\n+      this.eventListeners.splice(index, 1);\n+    }\n+  }\n+\n+  private emitEvent(event: PhysicsEvent): void {\n+    for (const listener of this.eventListeners) {\n+      listener(event);\n+    }\n+  }\n+\n+  /**\n+   * Get the current physics stats\n+   */\n+  getStats(): PhysicsStats {\n+    return { ...this.stats };\n+  }\n+\n+  /**\n+   * Reset stats (used after deserialization)\n+   */\n+  setStats(stats: PhysicsStats): void {\n+    this.stats = { ...stats };\n+  }\n+\n+  /**\n+   * Get effective melt temperature for a structure type (with upgrades)\n+   */\n+  getEffectiveMeltTemp(structure: StructureType): number {\n+    const baseTemp = STRUCTURE_BASE_STATS[structure].meltTemp;\n+\n+    let upgradeType: UpgradeType | null = null;\n+    switch (structure) {\n+      case StructureType.FuelRod: upgradeType = UpgradeType.MeltTempFuelRod; break;\n+      case StructureType.Ventilator: upgradeType = UpgradeType.MeltTempVentilator; break;\n+      case StructureType.HeatExchanger: upgradeType = UpgradeType.MeltTempHeatExchanger; break;\n+      case StructureType.Insulator: upgradeType = UpgradeType.MeltTempInsulator; break;\n+      case StructureType.Turbine: upgradeType = UpgradeType.MeltTempTurbine; break;\n+      case StructureType.Substation: upgradeType = UpgradeType.MeltTempSubstation; break;\n+    }\n+\n+    if (upgradeType) {\n+      const level = this.getUpgradeLevel(upgradeType);\n+      const definition = UPGRADE_DEFINITIONS[upgradeType];\n+      return baseTemp + (level * definition.improvementPerLevel);\n+    }\n+\n+    return baseTemp;\n+  }\n+\n+  /**\n+   * Get effective conductivity for a cell (with upgrades)\n+   */\n+  getEffectiveConductivity(cell: Cell): number {\n+    const baseConductivity = STRUCTURE_BASE_STATS[cell.structure].conductivity;\n+\n+    if (cell.structure === StructureType.Turbine) {\n+      const level = this.getUpgradeLevel(UpgradeType.TurbineConductivity);\n+      const definition = UPGRADE_DEFINITIONS[UpgradeType.TurbineConductivity];\n+      return baseConductivity + (level * definition.improvementPerLevel);\n+    }\n+\n+    if (cell.structure === StructureType.Insulator) {\n+      const level = this.getUpgradeLevel(UpgradeType.InsulatorConductivity);\n+      if (level > 0) {\n+        return baseConductivity * Math.pow(0.5, level);\n+      }\n+    }\n+\n+    return baseConductivity;\n+  }\n+\n+  /**\n+   * Get effective heat dissipation for a cell (with upgrades)\n+   */\n+  getEffectiveHeatDissipation(cell: Cell): number {\n+    if (cell.structure !== StructureType.Ventilator && cell.structure !== StructureType.VoidCell) {\n+      return 0;\n+    }\n+\n+    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n+    let dissipation = baseStats.heatDissipation;\n+\n+    if (cell.structure === StructureType.Ventilator) {\n+      dissipation *= Math.pow(10, cell.tier - 1);\n+\n+      const level = this.getUpgradeLevel(UpgradeType.VentilatorDissipation);\n+      const definition = UPGRADE_DEFINITIONS[UpgradeType.VentilatorDissipation];\n+      dissipation += level * definition.improvementPerLevel;\n+    }\n+\n+    return dissipation;\n+  }\n+\n+  /**\n+   * Get effective power sale rate for a cell (with upgrades)\n+   */\n+  getEffectivePowerSaleRate(cell: Cell): number {\n+    if (cell.structure !== StructureType.Substation) return 0;\n+\n+    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n+    let saleRate = baseStats.powerSaleRate;\n+\n+    saleRate *= Math.pow(10, cell.tier - 1);\n+\n+    const level = this.getUpgradeLevel(UpgradeType.SubstationSaleRate);\n+    const definition = UPGRADE_DEFINITIONS[UpgradeType.SubstationSaleRate];\n+    saleRate += level * definition.improvementPerLevel;\n+\n+    return saleRate;\n+  }\n+\n+  /**\n+   * Process heat generation from fuel rods\n+   */\n+  processHeatGeneration(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+        if (cell.lifetime <= 0) continue;\n+\n+        const upgradeLevel = this.getUpgradeLevel(UpgradeType.FuelHeatOutput);\n+        let heatGeneration = getFuelHeatGeneration(cell.tier, upgradeLevel);\n+\n+        // Adjacency bonus\n+        const adjacentFuelRods = this.gridManager.countAdjacentFuelRods(x, y);\n+        const adjacencyMultiplier = 1 + (adjacentFuelRods * FUEL_ADJACENCY.BONUS_PER_ADJACENT);\n+        heatGeneration *= adjacencyMultiplier;\n+\n+        // Exotic fuel scaling\n+        if (cell.isExotic) {\n+          const tempMultiplier = Math.min(\n+            EXOTIC_FUEL.MAX_MULTIPLIER,\n+            EXOTIC_FUEL.BASE_MULTIPLIER + (cell.heat / 1000) * EXOTIC_FUEL.HEAT_SCALING\n+          );\n+          heatGeneration *= tempMultiplier;\n+        }\n+\n+        cell.heat += heatGeneration;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process fuel depletion\n+   */\n+  processFuelDepletion(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+        if (cell.lifetime <= 0) continue;\n+\n+        cell.lifetime--;\n+\n+        if (cell.lifetime <= 0) {\n+          this.stats.fuelRodsDepleted++;\n+          this.emitEvent({\n+            type: 'fuel_depleted',\n+            x,\n+            y,\n+            tier: cell.tier,\n+          });\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process heat transfer between cells\n+   */\n+  processHeatTransfer(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    const heatDeltas: number[][] = [];\n+    for (let y = 0; y < gridSize; y++) {\n+      heatDeltas.push(new Array(gridSize).fill(0));\n+    }\n+\n+    const transferRate = CORE_SETTINGS.BASE_HEAT_TRANSFER_RATE;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        const cellConductivity = this.getEffectiveConductivity(cell);\n+        const neighbors = this.gridManager.getNeighbors(x, y);\n+\n+        for (const neighbor of neighbors) {\n+          const neighborConductivity = this.getEffectiveConductivity(neighbor);\n+          const heatDiff = cell.heat - neighbor.heat;\n+\n+          if (heatDiff > 0) {\n+            const conductivity = Math.min(cellConductivity, neighborConductivity);\n+            const transfer = heatDiff * transferRate * conductivity;\n+            heatDeltas[y][x] -= transfer;\n+            heatDeltas[neighbor.y][neighbor.x] += transfer;\n+          }\n+        }\n+\n+        // Edge cells lose heat to environment\n+        const edgeCount = 4 - neighbors.length;\n+        if (edgeCount > 0 && cell.heat > CORE_SETTINGS.AMBIENT_TEMPERATURE) {\n+          const heatAboveAmbient = cell.heat - CORE_SETTINGS.AMBIENT_TEMPERATURE;\n+          const envTransfer = heatAboveAmbient * CORE_SETTINGS.ENVIRONMENT_HEAT_TRANSFER_RATE * edgeCount;\n+          heatDeltas[y][x] -= envTransfer;\n+        }\n+      }\n+    }\n+\n+    // Apply deltas\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        grid[y][x].heat = Math.max(0, grid[y][x].heat + heatDeltas[y][x]);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process heat dissipation (ventilators and void cells)\n+   */\n+  processHeatDissipation(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        const dissipation = this.getEffectiveHeatDissipation(cell);\n+        cell.heat = Math.max(0, cell.heat - dissipation);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process power generation (turbines)\n+   */\n+  processPowerGeneration(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure !== StructureType.Turbine) continue;\n+        if (cell.heat <= 0) continue;\n+\n+        const baseStats = STRUCTURE_BASE_STATS[StructureType.Turbine];\n+        const maxHeatConsumption = baseStats.maxHeatConsumption * Math.pow(10, cell.tier - 1);\n+        const powerGeneration = baseStats.powerGeneration;\n+\n+        const heatConsumed = Math.min(cell.heat, maxHeatConsumption);\n+        const powerGenerated = heatConsumed * powerGeneration;\n+\n+        cell.heat -= heatConsumed;\n+        cell.power += powerGenerated;\n+        this.stats.totalPowerGenerated += powerGenerated;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process power sale (substations)\n+   * Returns the amount of money earned\n+   */\n+  processPowerSale(): number {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let totalEarnings = 0;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        // Turbines transfer power to nearby substations\n+        if (cell.structure === StructureType.Turbine && cell.power > 0) {\n+          const neighbors = this.gridManager.getNeighbors(x, y);\n+          for (const neighbor of neighbors) {\n+            if (neighbor.structure === StructureType.Substation) {\n+              grid[neighbor.y][neighbor.x].power += cell.power;\n+              cell.power = 0;\n+              break;\n+            }\n+          }\n+        }\n+\n+        // Substations sell power\n+        if (cell.structure === StructureType.Substation && cell.power > 0) {\n+          const saleRate = this.getEffectivePowerSaleRate(cell);\n+          const powerToSell = Math.min(cell.power, saleRate);\n+          const earnings = powerToSell * ECONOMY.MONEY_PER_POWER;\n+\n+          totalEarnings += earnings;\n+          this.stats.totalMoneyEarned += earnings;\n+          cell.power -= powerToSell;\n+\n+          if (earnings > 0) {\n+            this.emitEvent({\n+              type: 'power_sold',\n+              x,\n+              y,\n+              amount: earnings,\n+            });\n+          }\n+        }\n+      }\n+    }\n+\n+    return totalEarnings;\n+  }\n+\n+  /**\n+   * Process overheating and meltdowns\n+   * Returns true if a meltdown occurred\n+   */\n+  processOverheating(): boolean {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let meltdown = false;\n+    const meltedCells: { x: number; y: number; structure: StructureType; tier: Tier }[] = [];\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure === StructureType.Empty) continue;\n+\n+        const meltTemp = this.getEffectiveMeltTemp(cell.structure);\n+        if (cell.heat > meltTemp) {\n+          if (cell.structure === StructureType.FuelRod) {\n+            meltdown = true;\n+          } else {\n+            meltedCells.push({ x, y, structure: cell.structure, tier: cell.tier });\n+          }\n+        }\n+      }\n+    }\n+\n+    // Melt non-fuel structures\n+    for (const { x, y, structure, tier } of meltedCells) {\n+      this.gridManager.resetCell(x, y);\n+      this.emitEvent({\n+        type: 'structure_melted',\n+        x,\n+        y,\n+        structure,\n+        tier,\n+      });\n+    }\n+\n+    if (meltdown) {\n+      this.gridManager.clearAll();\n+      this.emitEvent({ type: 'meltdown' });\n+    }\n+\n+    return meltdown;\n+  }\n+\n+  /**\n+   * Track high heat survival (for secret unlock)\n+   */\n+  trackHighHeatSurvival(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let hasHighHeatFuelRod = false;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+\n+        const meltTemp = this.getEffectiveMeltTemp(StructureType.FuelRod);\n+        if (cell.heat >= meltTemp * 0.9) {\n+          hasHighHeatFuelRod = true;\n+          break;\n+        }\n+      }\n+      if (hasHighHeatFuelRod) break;\n+    }\n+\n+    if (hasHighHeatFuelRod) {\n+      this.stats.ticksAtHighHeat++;\n+    }\n+  }\n+\n+  /**\n+   * Run a complete physics tick\n+   * Returns the money earned from power sales\n+   */\n+  tick(): { moneyEarned: number; meltdown: boolean } {\n+    this.processHeatGeneration();\n+    this.processFuelDepletion();\n+    this.processHeatTransfer();\n+    this.processHeatDissipation();\n+    this.processPowerGeneration();\n+    const moneyEarned = this.processPowerSale();\n+    const meltdown = this.processOverheating();\n+    this.trackHighHeatSurvival();\n+\n+    return { moneyEarned, meltdown };\n+  }\n+}\ndiff --git a/src/game/UpgradeManager.test.ts b/src/game/UpgradeManager.test.ts\nnew file mode 100644\nindex 0000000..a6d3f1a\n--- /dev/null\n+++ b/src/game/UpgradeManager.test.ts\n@@ -0,0 +1,318 @@\n+/**\n+ * Unit tests for UpgradeManager\n+ *\n+ * Tests upgrade purchasing, secret unlocking, and toggle states in isolation.\n+ */\n+\n+import { describe, it, expect, beforeEach } from 'vitest';\n+import { UpgradeManager, UpgradeEvent } from './UpgradeManager.js';\n+import { UpgradeType, SecretUpgradeType, UPGRADE_DEFINITIONS, SECRET_UPGRADE_DEFINITIONS } from './BalanceConfig.js';\n+\n+describe('UpgradeManager', () => {\n+  let upgradeManager: UpgradeManager;\n+\n+  beforeEach(() => {\n+    upgradeManager = new UpgradeManager();\n+  });\n+\n+  describe('initialization', () => {\n+    it('should start with all upgrades at level 0', () => {\n+      for (const type of Object.values(UpgradeType)) {\n+        expect(upgradeManager.getUpgradeLevel(type)).toBe(0);\n+      }\n+    });\n+\n+    it('should start with all secrets locked', () => {\n+      for (const type of Object.values(SecretUpgradeType)) {\n+        expect(upgradeManager.isSecretUnlocked(type)).toBe(false);\n+        expect(upgradeManager.isSecretPurchased(type)).toBe(false);\n+        expect(upgradeManager.isSecretEnabled(type)).toBe(false);\n+      }\n+    });\n+  });\n+\n+  describe('regular upgrades', () => {\n+    it('should return correct upgrade cost', () => {\n+      const cost = upgradeManager.getUpgradeCost(UpgradeType.FuelHeatOutput);\n+      expect(cost).toBeGreaterThan(0);\n+    });\n+\n+    it('should allow purchasing upgrades with enough money', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+      const cost = upgradeManager.getUpgradeCost(type);\n+\n+      expect(upgradeManager.canPurchaseUpgrade(type, cost)).toBe(true);\n+      expect(upgradeManager.canPurchaseUpgrade(type, cost - 1)).toBe(false);\n+    });\n+\n+    it('should increase level on purchase', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+      const cost = upgradeManager.getUpgradeCost(type);\n+\n+      const spent = upgradeManager.purchaseUpgrade(type, cost);\n+\n+      expect(spent).toBe(cost);\n+      expect(upgradeManager.getUpgradeLevel(type)).toBe(1);\n+    });\n+\n+    it('should return 0 if purchase fails', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+\n+      const spent = upgradeManager.purchaseUpgrade(type, 0);\n+\n+      expect(spent).toBe(0);\n+      expect(upgradeManager.getUpgradeLevel(type)).toBe(0);\n+    });\n+\n+    it('should increase cost after each purchase', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+      const initialCost = upgradeManager.getUpgradeCost(type);\n+\n+      upgradeManager.purchaseUpgrade(type, 1000000);\n+\n+      const newCost = upgradeManager.getUpgradeCost(type);\n+      expect(newCost).toBeGreaterThan(initialCost);\n+    });\n+\n+    it('should respect max level', () => {\n+      // TurbineConductivity has maxLevel: 10\n+      const type = UpgradeType.TurbineConductivity;\n+      const maxLevel = UPGRADE_DEFINITIONS[type].maxLevel;\n+\n+      // Purchase up to max level\n+      for (let i = 0; i < maxLevel; i++) {\n+        upgradeManager.purchaseUpgrade(type, 1000000000);\n+      }\n+\n+      expect(upgradeManager.getUpgradeLevel(type)).toBe(maxLevel);\n+      expect(upgradeManager.canPurchaseUpgrade(type, 1000000000)).toBe(false);\n+    });\n+\n+    it('should emit event on purchase', () => {\n+      const events: UpgradeEvent[] = [];\n+      upgradeManager.addEventListener(e => events.push(e));\n+\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+\n+      expect(events).toHaveLength(1);\n+      expect(events[0].type).toBe('upgrade_purchased');\n+      expect(events[0].upgradeType).toBe(UpgradeType.FuelHeatOutput);\n+    });\n+  });\n+\n+  describe('secret upgrades', () => {\n+    it('should return correct secret cost', () => {\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.Salvage);\n+      expect(cost).toBe(SECRET_UPGRADE_DEFINITIONS[SecretUpgradeType.Salvage].cost);\n+    });\n+\n+    it('should not allow purchasing locked secrets', () => {\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.Salvage, 1000000)).toBe(false);\n+    });\n+\n+    it('should not allow purchasing already purchased secrets', () => {\n+      // ExoticFuel requires 1 meltdown to unlock\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.ExoticFuel);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, cost);\n+\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.ExoticFuel, 1000000)).toBe(false);\n+    });\n+\n+    it('should unlock secrets based on stats', () => {\n+      // ExoticFuel requires 1 meltdown\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+\n+      const unlocked = upgradeManager.checkSecretUnlocks(stats);\n+\n+      expect(unlocked).toContain(SecretUpgradeType.ExoticFuel);\n+      expect(upgradeManager.isSecretUnlocked(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should emit event on secret unlock', () => {\n+      const events: UpgradeEvent[] = [];\n+      upgradeManager.addEventListener(e => events.push(e));\n+\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      expect(events.some(e => e.type === 'secret_unlocked')).toBe(true);\n+    });\n+\n+    it('should allow purchasing unlocked secrets with enough money', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.ExoticFuel);\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.ExoticFuel, cost)).toBe(true);\n+      expect(upgradeManager.canPurchaseSecret(SecretUpgradeType.ExoticFuel, cost - 1)).toBe(false);\n+    });\n+\n+    it('should mark secret as purchased after buying', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const cost = upgradeManager.getSecretCost(SecretUpgradeType.ExoticFuel);\n+      const spent = upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, cost);\n+\n+      expect(spent).toBe(cost);\n+      expect(upgradeManager.isSecretPurchased(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should emit event on secret purchase', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      const events: UpgradeEvent[] = [];\n+      upgradeManager.addEventListener(e => events.push(e));\n+\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      expect(events.some(e => e.type === 'secret_purchased')).toBe(true);\n+    });\n+  });\n+\n+  describe('toggleable secrets', () => {\n+    it('should auto-enable toggleable secrets on purchase', () => {\n+      // Exotic fuel is toggleable, requires 1 meltdown\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should allow toggling purchased toggleable secrets', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.ExoticFuel, false);\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(false);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.ExoticFuel, true);\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(true);\n+    });\n+\n+    it('should not toggle unpurchased secrets', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.ExoticFuel, true);\n+\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(false);\n+    });\n+\n+    it('should not toggle non-toggleable secrets', () => {\n+      // Salvage requires 100 demolishes and is not toggleable\n+      const stats = { meltdownCount: 0, filledCells: 0, totalMoneyEarned: 0, demolishCount: 100, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.Salvage, 1000000);\n+\n+      upgradeManager.toggleSecret(SecretUpgradeType.Salvage, true);\n+\n+      // Salvage is not toggleable, so enabled should remain false\n+      expect(upgradeManager.isSecretEnabled(SecretUpgradeType.Salvage)).toBe(false);\n+    });\n+  });\n+\n+  describe('reactor expansion', () => {\n+    it('should return correct expansion size for reactor expansions', () => {\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion1)).toBe(17);\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion2)).toBe(18);\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion3)).toBe(19);\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ReactorExpansion4)).toBe(20);\n+    });\n+\n+    it('should return null for non-expansion secrets', () => {\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.Salvage)).toBeNull();\n+      expect(upgradeManager.getExpansionSize(SecretUpgradeType.ExoticFuel)).toBeNull();\n+    });\n+  });\n+\n+  describe('serialization', () => {\n+    it('should get upgrade state for serialization', () => {\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+\n+      const state = upgradeManager.getUpgradeState();\n+\n+      expect(state.levels[UpgradeType.FuelHeatOutput]).toBe(2);\n+    });\n+\n+    it('should get secret state for serialization', () => {\n+      // ExoticFuel requires 1 meltdown\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+      upgradeManager.checkSecretUnlocks(stats);\n+      upgradeManager.purchaseSecret(SecretUpgradeType.ExoticFuel, 1000000);\n+\n+      const state = upgradeManager.getSecretState();\n+\n+      expect(state.unlocked[SecretUpgradeType.ExoticFuel]).toBe(true);\n+      expect(state.purchased[SecretUpgradeType.ExoticFuel]).toBe(true);\n+    });\n+\n+    it('should restore upgrade state from serialization', () => {\n+      const state = upgradeManager.getUpgradeState();\n+      state.levels[UpgradeType.FuelHeatOutput] = 5;\n+\n+      const newManager = new UpgradeManager();\n+      newManager.restoreUpgradeState(state);\n+\n+      expect(newManager.getUpgradeLevel(UpgradeType.FuelHeatOutput)).toBe(5);\n+    });\n+\n+    it('should restore secret state from serialization', () => {\n+      const state = upgradeManager.getSecretState();\n+      state.unlocked[SecretUpgradeType.Salvage] = true;\n+      state.purchased[SecretUpgradeType.Salvage] = true;\n+\n+      const newManager = new UpgradeManager();\n+      newManager.restoreSecretState(state);\n+\n+      expect(newManager.isSecretUnlocked(SecretUpgradeType.Salvage)).toBe(true);\n+      expect(newManager.isSecretPurchased(SecretUpgradeType.Salvage)).toBe(true);\n+    });\n+  });\n+\n+  describe('event listeners', () => {\n+    it('should allow adding and removing listeners', () => {\n+      const events: UpgradeEvent[] = [];\n+      const listener = (e: UpgradeEvent) => events.push(e);\n+\n+      upgradeManager.addEventListener(listener);\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+      expect(events).toHaveLength(1);\n+\n+      upgradeManager.removeEventListener(listener);\n+      upgradeManager.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1000000);\n+      expect(events).toHaveLength(1); // No new events\n+    });\n+  });\n+\n+  describe('multiple unlock conditions', () => {\n+    it('should unlock multiple secrets when conditions are met', () => {\n+      // Stats that should unlock both Salvage (100 demolishes) and ExoticFuel (1 meltdown) and Overclock (10000 money)\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 10000, demolishCount: 100, ticksAtHighHeat: 0 };\n+\n+      const unlocked = upgradeManager.checkSecretUnlocks(stats);\n+\n+      expect(unlocked).toContain(SecretUpgradeType.ExoticFuel);\n+      expect(unlocked).toContain(SecretUpgradeType.Salvage);\n+      expect(unlocked).toContain(SecretUpgradeType.Overclock);\n+    });\n+\n+    it('should not re-unlock already unlocked secrets', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+\n+      const firstUnlock = upgradeManager.checkSecretUnlocks(stats);\n+      expect(firstUnlock).toContain(SecretUpgradeType.ExoticFuel);\n+\n+      const secondUnlock = upgradeManager.checkSecretUnlocks(stats);\n+      expect(secondUnlock).not.toContain(SecretUpgradeType.ExoticFuel);\n+    });\n+  });\n+});\ndiff --git a/src/game/UpgradeManager.ts b/src/game/UpgradeManager.ts\nnew file mode 100644\nindex 0000000..34d4ec4\n--- /dev/null\n+++ b/src/game/UpgradeManager.ts\n@@ -0,0 +1,299 @@\n+/**\n+ * UpgradeManager - Handles regular upgrades and secret upgrades\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ * This class manages upgrade purchasing, secret unlock conditions, and toggle states.\n+ */\n+\n+import {\n+  UpgradeType,\n+  UPGRADE_DEFINITIONS,\n+  SecretUpgradeType,\n+  SECRET_UPGRADE_DEFINITIONS,\n+  getUpgradeCost,\n+  getSecretUnlockProgress,\n+} from './BalanceConfig.js';\n+\n+export interface UpgradeState {\n+  levels: Record<UpgradeType, number>;\n+}\n+\n+export interface SecretState {\n+  unlocked: Record<SecretUpgradeType, boolean>;\n+  purchased: Record<SecretUpgradeType, boolean>;\n+  enabled: Record<SecretUpgradeType, boolean>;\n+}\n+\n+export interface UpgradeEvent {\n+  type: 'upgrade_purchased' | 'secret_unlocked' | 'secret_purchased';\n+  upgradeType?: UpgradeType;\n+  secretType?: SecretUpgradeType;\n+}\n+\n+export type UpgradeEventListener = (event: UpgradeEvent) => void;\n+\n+export interface UnlockStats {\n+  meltdownCount: number;\n+  filledCells: number;\n+  totalMoneyEarned: number;\n+  demolishCount: number;\n+  ticksAtHighHeat: number;\n+}\n+\n+/**\n+ * UpgradeManager handles all upgrade-related logic including:\n+ * - Regular upgrade purchasing and level tracking\n+ * - Secret upgrade unlocking, purchasing, and toggling\n+ */\n+export class UpgradeManager {\n+  private upgrades: UpgradeState;\n+  private secrets: SecretState;\n+  private eventListeners: UpgradeEventListener[] = [];\n+\n+  constructor() {\n+    this.upgrades = this.createInitialUpgradeState();\n+    this.secrets = this.createInitialSecretState();\n+  }\n+\n+  private createInitialUpgradeState(): UpgradeState {\n+    const levels: Record<UpgradeType, number> = {} as Record<UpgradeType, number>;\n+    for (const type of Object.values(UpgradeType)) {\n+      levels[type] = 0;\n+    }\n+    return { levels };\n+  }\n+\n+  private createInitialSecretState(): SecretState {\n+    const unlocked: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+    const purchased: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+    const enabled: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+\n+    for (const type of Object.values(SecretUpgradeType)) {\n+      unlocked[type] = false;\n+      purchased[type] = false;\n+      enabled[type] = false;\n+    }\n+    return { unlocked, purchased, enabled };\n+  }\n+\n+  /**\n+   * Add an event listener for upgrade events\n+   */\n+  addEventListener(listener: UpgradeEventListener): void {\n+    this.eventListeners.push(listener);\n+  }\n+\n+  /**\n+   * Remove an event listener\n+   */\n+  removeEventListener(listener: UpgradeEventListener): void {\n+    const index = this.eventListeners.indexOf(listener);\n+    if (index !== -1) {\n+      this.eventListeners.splice(index, 1);\n+    }\n+  }\n+\n+  private emitEvent(event: UpgradeEvent): void {\n+    for (const listener of this.eventListeners) {\n+      listener(event);\n+    }\n+  }\n+\n+  // ==========================================================================\n+  // REGULAR UPGRADES\n+  // ==========================================================================\n+\n+  /**\n+   * Get the current level of an upgrade\n+   */\n+  getUpgradeLevel(type: UpgradeType): number {\n+    return this.upgrades.levels[type];\n+  }\n+\n+  /**\n+   * Get the cost for the next level of an upgrade\n+   */\n+  getUpgradeCost(type: UpgradeType): number {\n+    const currentLevel = this.upgrades.levels[type];\n+    return getUpgradeCost(type, currentLevel);\n+  }\n+\n+  /**\n+   * Check if an upgrade can be purchased\n+   */\n+  canPurchaseUpgrade(type: UpgradeType, currentMoney: number): boolean {\n+    const definition = UPGRADE_DEFINITIONS[type];\n+    const currentLevel = this.upgrades.levels[type];\n+\n+    if (definition.maxLevel > 0 && currentLevel >= definition.maxLevel) {\n+      return false;\n+    }\n+\n+    const cost = getUpgradeCost(type, currentLevel);\n+    return currentMoney >= cost;\n+  }\n+\n+  /**\n+   * Purchase an upgrade\n+   * Returns the cost if successful, 0 if failed\n+   */\n+  purchaseUpgrade(type: UpgradeType, currentMoney: number): number {\n+    if (!this.canPurchaseUpgrade(type, currentMoney)) return 0;\n+\n+    const cost = getUpgradeCost(type, this.upgrades.levels[type]);\n+    this.upgrades.levels[type]++;\n+\n+    this.emitEvent({ type: 'upgrade_purchased', upgradeType: type });\n+    return cost;\n+  }\n+\n+  // ==========================================================================\n+  // SECRET UPGRADES\n+  // ==========================================================================\n+\n+  /**\n+   * Check if a secret upgrade is unlocked\n+   */\n+  isSecretUnlocked(type: SecretUpgradeType): boolean {\n+    return this.secrets.unlocked[type];\n+  }\n+\n+  /**\n+   * Check if a secret upgrade has been purchased\n+   */\n+  isSecretPurchased(type: SecretUpgradeType): boolean {\n+    return this.secrets.purchased[type];\n+  }\n+\n+  /**\n+   * Check if a toggleable secret is enabled\n+   */\n+  isSecretEnabled(type: SecretUpgradeType): boolean {\n+    return this.secrets.enabled[type];\n+  }\n+\n+  /**\n+   * Get the cost of a secret upgrade\n+   */\n+  getSecretCost(type: SecretUpgradeType): number {\n+    return SECRET_UPGRADE_DEFINITIONS[type].cost;\n+  }\n+\n+  /**\n+   * Check if a secret can be purchased\n+   */\n+  canPurchaseSecret(type: SecretUpgradeType, currentMoney: number): boolean {\n+    if (!this.secrets.unlocked[type]) return false;\n+    if (this.secrets.purchased[type]) return false;\n+\n+    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n+    return currentMoney >= cost;\n+  }\n+\n+  /**\n+   * Purchase a secret upgrade\n+   * Returns the cost if successful, 0 if failed\n+   */\n+  purchaseSecret(type: SecretUpgradeType, currentMoney: number): number {\n+    if (!this.canPurchaseSecret(type, currentMoney)) return 0;\n+\n+    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n+    this.secrets.purchased[type] = true;\n+\n+    // Auto-enable toggleable secrets\n+    if (SECRET_UPGRADE_DEFINITIONS[type].isToggle) {\n+      this.secrets.enabled[type] = true;\n+    }\n+\n+    this.emitEvent({ type: 'secret_purchased', secretType: type });\n+    return cost;\n+  }\n+\n+  /**\n+   * Toggle a secret upgrade on/off\n+   */\n+  toggleSecret(type: SecretUpgradeType, enabled: boolean): void {\n+    if (!this.secrets.purchased[type]) return;\n+    if (!SECRET_UPGRADE_DEFINITIONS[type].isToggle) return;\n+\n+    this.secrets.enabled[type] = enabled;\n+  }\n+\n+  /**\n+   * Check and unlock secrets based on current game stats\n+   * Returns array of newly unlocked secrets\n+   */\n+  checkSecretUnlocks(stats: UnlockStats): SecretUpgradeType[] {\n+    const newlyUnlocked: SecretUpgradeType[] = [];\n+\n+    for (const type of Object.values(SecretUpgradeType)) {\n+      if (this.secrets.unlocked[type]) continue;\n+\n+      const progress = getSecretUnlockProgress(type, stats);\n+      if (progress.unlocked) {\n+        this.secrets.unlocked[type] = true;\n+        newlyUnlocked.push(type);\n+        this.emitEvent({ type: 'secret_unlocked', secretType: type });\n+      }\n+    }\n+\n+    return newlyUnlocked;\n+  }\n+\n+  /**\n+   * Get the grid size expansion for a reactor expansion secret\n+   */\n+  getExpansionSize(type: SecretUpgradeType): number | null {\n+    switch (type) {\n+      case SecretUpgradeType.ReactorExpansion1: return 17;\n+      case SecretUpgradeType.ReactorExpansion2: return 18;\n+      case SecretUpgradeType.ReactorExpansion3: return 19;\n+      case SecretUpgradeType.ReactorExpansion4: return 20;\n+      default: return null;\n+    }\n+  }\n+\n+  // ==========================================================================\n+  // SERIALIZATION\n+  // ==========================================================================\n+\n+  /**\n+   * Get the current upgrade state for serialization\n+   */\n+  getUpgradeState(): UpgradeState {\n+    return {\n+      levels: { ...this.upgrades.levels },\n+    };\n+  }\n+\n+  /**\n+   * Get the current secret state for serialization\n+   */\n+  getSecretState(): SecretState {\n+    return {\n+      unlocked: { ...this.secrets.unlocked },\n+      purchased: { ...this.secrets.purchased },\n+      enabled: { ...this.secrets.enabled },\n+    };\n+  }\n+\n+  /**\n+   * Restore upgrade state from serialized data\n+   */\n+  restoreUpgradeState(state: UpgradeState): void {\n+    this.upgrades = {\n+      levels: { ...state.levels },\n+    };\n+  }\n+\n+  /**\n+   * Restore secret state from serialized data\n+   */\n+  restoreSecretState(state: SecretState): void {\n+    this.secrets = {\n+      unlocked: { ...state.unlocked },\n+      purchased: { ...state.purchased },\n+      enabled: { ...state.enabled },\n+    };\n+  }\n+}",
          "actualWorkers": 1
        },
        "id": "chromium",
        "name": "chromium",
        "testDir": "/home/runner/work/claudetest123/claudetest123/e2e",
        "testIgnore": [],
        "testMatch": [
          "**/*.@(spec|test).?(c|m)[jt]s?(x)"
        ],
        "timeout": 30000
      }
    ],
    "quiet": false,
    "reporter": [
      [
        "html",
        {
          "outputFolder": "playwright-report"
        }
      ],
      [
        "list",
        null
      ],
      [
        "json",
        {
          "outputFile": "test-results/results.json"
        }
      ]
    ],
    "reportSlowTests": {
      "max": 5,
      "threshold": 300000
    },
    "runAgents": "none",
    "shard": null,
    "tags": [],
    "updateSnapshots": "missing",
    "updateSourceMethod": "patch",
    "version": "1.58.0",
    "workers": 1,
    "webServer": {
      "command": "npm run serve",
      "url": "http://localhost:3000",
      "reuseExistingServer": false,
      "timeout": 120000
    }
  },
  "suites": [
    {
      "title": "heat-game.spec.ts",
      "file": "heat-game.spec.ts",
      "column": 0,
      "line": 0,
      "specs": [],
      "suites": [
        {
          "title": "Heat Game E2E Tests",
          "file": "heat-game.spec.ts",
          "line": 40,
          "column": 6,
          "specs": [
            {
              "title": "should load the game and display initial state",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 495,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:22:33.016Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-2428b-e-and-display-initial-state-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-2428b-e-and-display-initial-state-chromium/attachments/browser-logs-252e98eebb6d2a6fd5612fd184955e74f7d8fa0e.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-1f7f90ca45f76c134f4d",
              "file": "heat-game.spec.ts",
              "line": 86,
              "column": 3
            },
            {
              "title": "should place a Fuel Rod on the grid",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 644,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:22:34.729Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-05fff-lace-a-Fuel-Rod-on-the-grid-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-05fff-lace-a-Fuel-Rod-on-the-grid-chromium/attachments/browser-logs-daa597c1e58cdd3735064670bc098a56f535a7d5.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-a31bde006f3c29450fad",
              "file": "heat-game.spec.ts",
              "line": 116,
              "column": 3
            },
            {
              "title": "should place multiple structures and observe heat dynamics",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1184,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:22:35.389Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-edba4-s-and-observe-heat-dynamics-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-edba4-s-and-observe-heat-dynamics-chromium/attachments/browser-logs-a9526112523c68aa24fe78334be3ec2af4a1ba62.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-2ed04ebe32d9c471053a",
              "file": "heat-game.spec.ts",
              "line": 148,
              "column": 3
            },
            {
              "title": "should demolish a structure with right-click",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 521,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:22:36.587Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-53724--structure-with-right-click-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-53724--structure-with-right-click-chromium/attachments/browser-logs-d97b4f4e87a5cc31e1b5dee61d33b7cf6ee7bb2f.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-ff211d87a2ad19067056",
              "file": "heat-game.spec.ts",
              "line": 185,
              "column": 3
            },
            {
              "title": "should build a power generation setup",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1702,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:22:37.122Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-206ae-ld-a-power-generation-setup-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-206ae-ld-a-power-generation-setup-chromium/attachments/browser-logs-6db27ca250b3a1a4083663dd5a90aeedb0e1a354.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-abe0096aa1a1c45a3b34",
              "file": "heat-game.spec.ts",
              "line": 216,
              "column": 3
            },
            {
              "title": "should show heat buildup with clustered fuel rods",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1590,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:22:38.836Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-1ce31-up-with-clustered-fuel-rods-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-1ce31-up-with-clustered-fuel-rods-chromium/attachments/browser-logs-4108f70a5376472a80710ba1c287f526e1cfc9b4.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-ac87d21624a439db98b8",
              "file": "heat-game.spec.ts",
              "line": 253,
              "column": 3
            },
            {
              "title": "should not allow building without sufficient money",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1452,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:22:40.438Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-ee0f6-ng-without-sufficient-money-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-ee0f6-ng-without-sufficient-money-chromium/attachments/browser-logs-67852c21b9cbe344288f7cfb81aa3e88ded21441.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-b096005e15a85f67c2a8",
              "file": "heat-game.spec.ts",
              "line": 291,
              "column": 3
            },
            {
              "title": "should handle rapid clicking on the grid",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1237,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:22:41.903Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-c664c--rapid-clicking-on-the-grid-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-c664c--rapid-clicking-on-the-grid-chromium/attachments/browser-logs-8830c25d0c901f07d14f24299509ec6ff3fc0a0b.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-1b3f7a34798ed668be9c",
              "file": "heat-game.spec.ts",
              "line": 333,
              "column": 3
            }
          ]
        }
      ]
    }
  ],
  "errors": [],
  "stats": {
    "startTime": "2026-01-31T12:22:25.329Z",
    "duration": 17889.088,
    "expected": 8,
    "skipped": 0,
    "unexpected": 0,
    "flaky": 0
  }
}