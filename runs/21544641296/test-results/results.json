{
  "config": {
    "configFile": "/home/runner/work/claudetest123/claudetest123/playwright.config.ts",
    "rootDir": "/home/runner/work/claudetest123/claudetest123/e2e",
    "forbidOnly": true,
    "fullyParallel": true,
    "globalSetup": null,
    "globalTeardown": null,
    "globalTimeout": 0,
    "grep": {},
    "grepInvert": null,
    "maxFailures": 0,
    "metadata": {
      "ci": {
        "commitHref": "https://github.com/bjuergens/claudetest123/commit/c6e0c9ee614dd994230d6b829c11b0b99cbbbc2b",
        "commitHash": "c6e0c9ee614dd994230d6b829c11b0b99cbbbc2b",
        "prHref": "https://github.com/bjuergens/claudetest123/pull/10",
        "prTitle": "Extract GridManager, PhysicsEngine, and UpgradeManager from HeatGame",
        "prBaseHash": "f29e01ec7cb04beabadc275fcf431907f165675e",
        "buildHref": "https://github.com/bjuergens/claudetest123/actions/runs/21544641296"
      },
      "gitCommit": {
        "shortHash": "c6e0c9e",
        "hash": "c6e0c9ee614dd994230d6b829c11b0b99cbbbc2b",
        "subject": "Merge cfb47803929dc2f495a7be3903aa6b6762e8ca87 into f29e01ec7cb04beabadc275fcf431907f165675e",
        "body": "Merge cfb47803929dc2f495a7be3903aa6b6762e8ca87 into f29e01ec7cb04beabadc275fcf431907f165675e\n",
        "author": {
          "name": "Björn Jürgens",
          "email": "4362465+bjuergens@users.noreply.github.com",
          "time": 1769863313000
        },
        "committer": {
          "name": "GitHub",
          "email": "noreply@github.com",
          "time": 1769863313000
        },
        "branch": "HEAD"
      },
      "gitDiff": "diff --git a/CLAUDE.md b/CLAUDE.md\nnew file mode 100644\nindex 0000000..0a6ee98\n--- /dev/null\n+++ b/CLAUDE.md\n@@ -0,0 +1,50 @@\n+# Project Conventions\n+\n+## Architecture\n+\n+```\n+HeatGame (orchestrator)\n+├── GridManager     - Grid state and neighbor calculations\n+├── PhysicsEngine   - Heat/power simulation\n+└── UpgradeManager  - Upgrades and secrets\n+```\n+\n+### Key Design Decisions\n+\n+1. **Shared Mutable State**: PhysicsEngine operates directly on GridManager's grid via `getGridRef()`. This assumes single-threaded execution.\n+\n+2. **Upgrade Callback**: PhysicsEngine queries upgrades via closure `(type) => upgradeManager.getUpgradeLevel(type)`. Don't purchase upgrades during physics tick.\n+\n+3. **Stats Ownership**:\n+   - Physics stats (totalPowerGenerated, ticksAtHighHeat, fuelRodsDepleted) → owned by PhysicsEngine\n+   - Game stats (meltdownCount, structuresBuilt, demolishCount) → owned by HeatGame\n+   - HeatGame syncs from PhysicsEngine after each tick\n+\n+## Testing Philosophy\n+\n+**Keep tests lean.** Only test:\n+- Data loss scenarios (serialization, grid expansion)\n+- Catastrophic behaviors (meltdowns)\n+- Complex interactions (upgrades affecting physics)\n+- Edge cases that would be hard to debug\n+\n+**Don't test:**\n+- Trivial getters/setters\n+- Type correctness (compiler handles this)\n+- Initialization defaults\n+- Event listener add/remove patterns\n+\n+## Commands\n+\n+```bash\n+npm test          # Run unit tests\n+npm run build     # TypeScript compile\n+npm run dev       # Watch mode + serve\n+```\n+\n+## Code Style\n+\n+- Use composition over inheritance\n+- Prefer explicit state sync over implicit coupling\n+- Events are for UI notification, not state management\n+- Single source of truth for each piece of state\ndiff --git a/src/game/GridManager.test.ts b/src/game/GridManager.test.ts\nnew file mode 100644\nindex 0000000..b7dac98\n--- /dev/null\n+++ b/src/game/GridManager.test.ts\n@@ -0,0 +1,93 @@\n+/**\n+ * GridManager Unit Tests\n+ *\n+ * Focus: Data integrity, grid expansion (data loss risk), neighbor calculations (core mechanic)\n+ */\n+\n+import { describe, it, expect, beforeEach } from 'vitest';\n+import { GridManager } from './GridManager.js';\n+import { StructureType } from './BalanceConfig.js';\n+\n+describe('GridManager', () => {\n+  let grid: GridManager;\n+\n+  beforeEach(() => {\n+    grid = new GridManager(16);\n+  });\n+\n+  describe('data integrity', () => {\n+    it('getCell returns copy, getCellRef returns mutable reference', () => {\n+      const copy = grid.getCell(5, 5)!;\n+      copy.heat = 999;\n+      expect(grid.getCell(5, 5)!.heat).toBe(0); // unchanged\n+\n+      const ref = grid.getCellRef(5, 5)!;\n+      ref.heat = 999;\n+      expect(grid.getCell(5, 5)!.heat).toBe(999); // changed\n+    });\n+\n+    it('expandGrid preserves existing cell data', () => {\n+      const cell = grid.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.heat = 500;\n+      cell.lifetime = 42;\n+\n+      grid.expandGrid(18, 20);\n+\n+      const preserved = grid.getCell(5, 5)!;\n+      expect(preserved.structure).toBe(StructureType.FuelRod);\n+      expect(preserved.heat).toBe(500);\n+      expect(preserved.lifetime).toBe(42);\n+      expect(grid.getSize()).toBe(18);\n+    });\n+\n+    it('restoreFromState correctly restores grid', () => {\n+      const state = grid.getSnapshot();\n+      state[5][5].structure = StructureType.Turbine;\n+      state[5][5].heat = 250;\n+\n+      const newGrid = new GridManager(10);\n+      newGrid.restoreFromState(state, 16);\n+\n+      expect(newGrid.getSize()).toBe(16);\n+      expect(newGrid.getCell(5, 5)!.structure).toBe(StructureType.Turbine);\n+      expect(newGrid.getCell(5, 5)!.heat).toBe(250);\n+    });\n+  });\n+\n+  describe('neighbor calculations', () => {\n+    it('returns correct neighbor count at center/edge/corner', () => {\n+      expect(grid.getNeighbors(8, 8)).toHaveLength(4);  // center\n+      expect(grid.getNeighbors(0, 8)).toHaveLength(3);  // edge\n+      expect(grid.getNeighbors(0, 0)).toHaveLength(2);  // corner\n+    });\n+\n+    it('countAdjacentFuelRods only counts active fuel rods', () => {\n+      // Active fuel rod\n+      const active = grid.getCellRef(5, 4)!;\n+      active.structure = StructureType.FuelRod;\n+      active.lifetime = 100;\n+\n+      // Depleted fuel rod\n+      const depleted = grid.getCellRef(5, 6)!;\n+      depleted.structure = StructureType.FuelRod;\n+      depleted.lifetime = 0;\n+\n+      expect(grid.countAdjacentFuelRods(5, 5)).toBe(1);\n+    });\n+  });\n+\n+  describe('bounds checking', () => {\n+    it('returns null for out-of-bounds access', () => {\n+      expect(grid.getCell(-1, 0)).toBeNull();\n+      expect(grid.getCell(16, 0)).toBeNull();\n+      expect(grid.getCellRef(-1, 0)).toBeNull();\n+    });\n+\n+    it('rejects invalid expansions', () => {\n+      expect(grid.expandGrid(25, 20)).toBe(false); // beyond max\n+      expect(grid.expandGrid(10, 20)).toBe(false); // shrinking\n+      expect(grid.getSize()).toBe(16);\n+    });\n+  });\n+});\ndiff --git a/src/game/GridManager.ts b/src/game/GridManager.ts\nnew file mode 100644\nindex 0000000..0e158a8\n--- /dev/null\n+++ b/src/game/GridManager.ts\n@@ -0,0 +1,221 @@\n+/**\n+ * GridManager - Handles grid creation, neighbor calculations, and cell operations\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ */\n+\n+import { StructureType, Tier } from './BalanceConfig.js';\n+\n+export interface Cell {\n+  x: number;\n+  y: number;\n+  structure: StructureType;\n+  tier: Tier;\n+  heat: number;\n+  power: number;\n+  /** Remaining lifetime in ticks (fuel rods only, 0 = infinite/depleted) */\n+  lifetime: number;\n+  /** Whether this is an exotic variant (fuel rods only) */\n+  isExotic: boolean;\n+}\n+\n+export class GridManager {\n+  private grid: Cell[][];\n+  private gridSize: number;\n+\n+  constructor(initialSize: number) {\n+    this.gridSize = initialSize;\n+    this.grid = this.createEmptyGrid(initialSize);\n+  }\n+\n+  /**\n+   * Create a new empty grid of the specified size\n+   */\n+  createEmptyGrid(size: number): Cell[][] {\n+    const grid: Cell[][] = [];\n+    for (let y = 0; y < size; y++) {\n+      const row: Cell[] = [];\n+      for (let x = 0; x < size; x++) {\n+        row.push(this.createEmptyCell(x, y));\n+      }\n+      grid.push(row);\n+    }\n+    return grid;\n+  }\n+\n+  /**\n+   * Create an empty cell at the specified coordinates\n+   */\n+  createEmptyCell(x: number, y: number): Cell {\n+    return {\n+      x,\n+      y,\n+      structure: StructureType.Empty,\n+      tier: Tier.T1,\n+      heat: 0,\n+      power: 0,\n+      lifetime: 0,\n+      isExotic: false,\n+    };\n+  }\n+\n+  /**\n+   * Get a copy of a cell at the specified coordinates\n+   * Returns null if coordinates are out of bounds\n+   */\n+  getCell(x: number, y: number): Cell | null {\n+    if (!this.isValidPosition(x, y)) {\n+      return null;\n+    }\n+    return { ...this.grid[y][x] };\n+  }\n+\n+  /**\n+   * Get a direct reference to a cell (for mutation)\n+   * Returns null if coordinates are out of bounds\n+   */\n+  getCellRef(x: number, y: number): Cell | null {\n+    if (!this.isValidPosition(x, y)) {\n+      return null;\n+    }\n+    return this.grid[y][x];\n+  }\n+\n+  /**\n+   * Check if coordinates are within grid bounds\n+   */\n+  isValidPosition(x: number, y: number): boolean {\n+    return x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize;\n+  }\n+\n+  /**\n+   * Get the current grid size\n+   */\n+  getSize(): number {\n+    return this.gridSize;\n+  }\n+\n+  /**\n+   * Get a snapshot (deep copy) of the entire grid\n+   */\n+  getSnapshot(): Cell[][] {\n+    return this.grid.map(row => row.map(cell => ({ ...cell })));\n+  }\n+\n+  /**\n+   * Get the internal grid reference (for physics engine)\n+   */\n+  getGridRef(): Cell[][] {\n+    return this.grid;\n+  }\n+\n+  /**\n+   * Get orthogonal neighbors (up, down, left, right) of a cell\n+   */\n+  getNeighbors(x: number, y: number): Cell[] {\n+    const neighbors: Cell[] = [];\n+    const directions = [\n+      { dx: 0, dy: -1 }, // up\n+      { dx: 0, dy: 1 },  // down\n+      { dx: -1, dy: 0 }, // left\n+      { dx: 1, dy: 0 },  // right\n+    ];\n+\n+    for (const { dx, dy } of directions) {\n+      const nx = x + dx;\n+      const ny = y + dy;\n+      if (this.isValidPosition(nx, ny)) {\n+        neighbors.push(this.grid[ny][nx]);\n+      }\n+    }\n+\n+    return neighbors;\n+  }\n+\n+  /**\n+   * Count active (non-depleted) fuel rods adjacent to a position\n+   */\n+  countAdjacentFuelRods(x: number, y: number): number {\n+    const neighbors = this.getNeighbors(x, y);\n+    return neighbors.filter(n => n.structure === StructureType.FuelRod && n.lifetime > 0).length;\n+  }\n+\n+  /**\n+   * Count filled (non-empty) cells in the grid\n+   */\n+  getFilledCellCount(): number {\n+    let count = 0;\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        if (this.grid[y][x].structure !== StructureType.Empty) {\n+          count++;\n+        }\n+      }\n+    }\n+    return count;\n+  }\n+\n+  /**\n+   * Expand the grid to a new size, preserving existing cells\n+   * Returns true if expansion was successful\n+   */\n+  expandGrid(newSize: number, maxSize: number): boolean {\n+    if (newSize <= this.gridSize) return false;\n+    if (newSize > maxSize) return false;\n+\n+    const oldGrid = this.grid;\n+    const oldSize = this.gridSize;\n+\n+    // Create new larger grid\n+    this.grid = this.createEmptyGrid(newSize);\n+    this.gridSize = newSize;\n+\n+    // Copy old grid data\n+    for (let y = 0; y < oldSize; y++) {\n+      for (let x = 0; x < oldSize; x++) {\n+        this.grid[y][x] = { ...oldGrid[y][x] };\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Reset a cell to empty state\n+   */\n+  resetCell(x: number, y: number): void {\n+    if (this.isValidPosition(x, y)) {\n+      this.grid[y][x] = this.createEmptyCell(x, y);\n+    }\n+  }\n+\n+  /**\n+   * Clear all cells in the grid (reset to empty)\n+   */\n+  clearAll(): void {\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        this.grid[y][x] = this.createEmptyCell(x, y);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Iterate over all cells, calling the callback for each\n+   */\n+  forEach(callback: (cell: Cell, x: number, y: number) => void): void {\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        callback(this.grid[y][x], x, y);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Restore grid state from serialized data\n+   */\n+  restoreFromState(grid: Cell[][], gridSize: number): void {\n+    this.gridSize = gridSize;\n+    this.grid = grid.map(row => row.map(cell => ({ ...cell })));\n+  }\n+}\ndiff --git a/src/game/HeatGame.ts b/src/game/HeatGame.ts\nindex 24971dc..eeca20d 100644\n--- a/src/game/HeatGame.ts\n+++ b/src/game/HeatGame.ts\n@@ -1,15 +1,10 @@\n /**\n  * Heat Management Game - Core Game Logic\n  *\n- * Refactored to support:\n- * - Tiered items (T1-T4)\n- * - Fuel rod lifetime and depletion\n- * - Adjacency heat bonus for fuel rods\n- * - Manual power generation (clicker)\n- * - Upgrade system (regular + secret)\n- * - Exotic fuel rods\n- * - Dynamic grid size (16x16 to 20x20)\n- * - Variable melt temperatures and conductivity\n+ * Refactored to use composed classes for better separation of concerns:\n+ * - GridManager: Grid creation and cell operations\n+ * - PhysicsEngine: Heat/power simulation\n+ * - UpgradeManager: Upgrade and secret management\n  */\n \n import {\n@@ -18,46 +13,28 @@ import {\n   Tier,\n   StructureType,\n   STRUCTURE_BASE_STATS,\n-  FUEL_ADJACENCY,\n-  ECONOMY,\n   UpgradeType,\n-  UPGRADE_DEFINITIONS,\n   SecretUpgradeType,\n   SECRET_UPGRADE_DEFINITIONS,\n-  EXOTIC_FUEL,\n   getStructureCost,\n   getFuelLifetime,\n-  getFuelHeatGeneration,\n-  getUpgradeCost,\n-  getSecretUnlockProgress,\n } from './BalanceConfig.js';\n \n+import { GridManager, Cell } from './GridManager.js';\n+import { PhysicsEngine, PhysicsEvent } from './PhysicsEngine.js';\n+import { UpgradeManager, UpgradeEvent } from './UpgradeManager.js';\n+\n // Re-export types for backward compatibility\n export { StructureType, Tier, UpgradeType, SecretUpgradeType };\n-\n-export interface Cell {\n-  x: number;\n-  y: number;\n-  structure: StructureType;\n-  tier: Tier;\n-  heat: number;\n-  power: number;\n-  /** Remaining lifetime in ticks (fuel rods only, 0 = infinite/depleted) */\n-  lifetime: number;\n-  /** Whether this is an exotic variant (fuel rods only) */\n-  isExotic: boolean;\n-}\n+export { Cell };\n \n export interface UpgradeState {\n   levels: Record<UpgradeType, number>;\n }\n \n export interface SecretState {\n-  /** Whether the unlock condition has been met */\n   unlocked: Record<SecretUpgradeType, boolean>;\n-  /** Whether the upgrade has been purchased */\n   purchased: Record<SecretUpgradeType, boolean>;\n-  /** Toggle state for toggleable secrets */\n   enabled: Record<SecretUpgradeType, boolean>;\n }\n \n@@ -107,87 +84,101 @@ export interface GameEvent {\n \n export type GameEventListener = (event: GameEvent) => void;\n \n-// Helper to create initial upgrade state\n-function createInitialUpgradeState(): UpgradeState {\n-  const levels: Record<UpgradeType, number> = {} as Record<UpgradeType, number>;\n-  for (const type of Object.values(UpgradeType)) {\n-    levels[type] = 0;\n-  }\n-  return { levels };\n-}\n-\n-// Helper to create initial secret state\n-function createInitialSecretState(): SecretState {\n-  const unlocked: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n-  const purchased: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n-  const enabled: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n-\n-  for (const type of Object.values(SecretUpgradeType)) {\n-    unlocked[type] = false;\n-    purchased[type] = false;\n-    enabled[type] = false;\n-  }\n-  return { unlocked, purchased, enabled };\n-}\n-\n+/**\n+ * HeatGame - Main game orchestrator\n+ *\n+ * Composes GridManager, PhysicsEngine, and UpgradeManager to coordinate\n+ * game logic while delegating specific responsibilities to each component.\n+ */\n export class HeatGame {\n-  private state: GameState;\n+  private gridManager: GridManager;\n+  private physicsEngine: PhysicsEngine;\n+  private upgradeManager: UpgradeManager;\n+\n+  private money: number;\n+  private stats: GameStats;\n   private eventListeners: GameEventListener[] = [];\n \n   constructor(initialMoney: number = CORE_SETTINGS.STARTING_MONEY) {\n-    this.state = this.createInitialState(initialMoney);\n-  }\n+    // Initialize composed components\n+    this.gridManager = new GridManager(CORE_SETTINGS.INITIAL_GRID_SIZE);\n+    this.upgradeManager = new UpgradeManager();\n+    this.physicsEngine = new PhysicsEngine(\n+      this.gridManager,\n+      (type: UpgradeType) => this.upgradeManager.getUpgradeLevel(type)\n+    );\n+\n+    this.money = initialMoney;\n+    this.stats = this.createInitialStats();\n \n-  private createInitialState(initialMoney: number): GameState {\n-    const gridSize = CORE_SETTINGS.INITIAL_GRID_SIZE;\n-    const grid = this.createEmptyGrid(gridSize);\n+    // Wire up event forwarding from sub-components\n+    this.setupEventForwarding();\n+  }\n \n+  private createInitialStats(): GameStats {\n     return {\n-      grid,\n-      gridSize,\n-      money: initialMoney,\n-      stats: {\n-        totalPowerGenerated: 0,\n-        totalMoneyEarned: 0,\n-        meltdownCount: 0,\n-        tickCount: 0,\n-        demolishCount: 0,\n-        ticksAtHighHeat: 0,\n-        manualClicks: 0,\n-        structuresBuilt: 0,\n-        fuelRodsDepleted: 0,\n-      },\n-      upgrades: createInitialUpgradeState(),\n-      secrets: createInitialSecretState(),\n+      totalPowerGenerated: 0,\n+      totalMoneyEarned: 0,\n+      meltdownCount: 0,\n+      tickCount: 0,\n+      demolishCount: 0,\n+      ticksAtHighHeat: 0,\n+      manualClicks: 0,\n+      structuresBuilt: 0,\n+      fuelRodsDepleted: 0,\n     };\n   }\n \n-  private createEmptyGrid(size: number): Cell[][] {\n-    const grid: Cell[][] = [];\n-    for (let y = 0; y < size; y++) {\n-      const row: Cell[] = [];\n-      for (let x = 0; x < size; x++) {\n-        row.push(this.createEmptyCell(x, y));\n+  private setupEventForwarding(): void {\n+    // Forward physics events\n+    // Note: Stats are tracked in PhysicsEngine, we only forward events here\n+    this.physicsEngine.addEventListener((event: PhysicsEvent) => {\n+      if (event.type === 'fuel_depleted') {\n+        // Don't increment here - PhysicsEngine already tracks this stat\n+        this.emitEvent({\n+          type: 'fuel_depleted',\n+          x: event.x,\n+          y: event.y,\n+          tier: event.tier,\n+        });\n+      } else if (event.type === 'power_sold') {\n+        this.emitEvent({\n+          type: 'power_sold',\n+          x: event.x,\n+          y: event.y,\n+          amount: event.amount,\n+        });\n+      } else if (event.type === 'structure_melted') {\n+        this.emitEvent({\n+          type: 'structure_melted',\n+          x: event.x,\n+          y: event.y,\n+          structure: event.structure,\n+          tier: event.tier,\n+        });\n+      } else if (event.type === 'meltdown') {\n+        this.stats.meltdownCount++;\n+        this.emitEvent({ type: 'meltdown' });\n+        this.checkSecretUnlocks();\n       }\n-      grid.push(row);\n-    }\n-    return grid;\n-  }\n+    });\n \n-  private createEmptyCell(x: number, y: number): Cell {\n-    return {\n-      x,\n-      y,\n-      structure: StructureType.Empty,\n-      tier: Tier.T1,\n-      heat: 0,\n-      power: 0,\n-      lifetime: 0,\n-      isExotic: false,\n-    };\n+    // Forward upgrade events\n+    this.upgradeManager.addEventListener((event: UpgradeEvent) => {\n+      if (event.type === 'upgrade_purchased') {\n+        this.emitEvent({ type: 'upgrade_purchased', upgradeType: event.upgradeType });\n+      } else if (event.type === 'secret_unlocked') {\n+        this.emitEvent({ type: 'secret_unlocked', secretType: event.secretType });\n+      } else if (event.type === 'secret_purchased') {\n+        this.emitEvent({ type: 'secret_purchased', secretType: event.secretType });\n+      }\n+    });\n   }\n \n-  // Event system\n+  // ==========================================================================\n+  // EVENT SYSTEM\n+  // ==========================================================================\n+\n   addEventListener(listener: GameEventListener): void {\n     this.eventListeners.push(listener);\n   }\n@@ -206,74 +197,63 @@ export class HeatGame {\n   }\n \n   // ==========================================================================\n-  // GETTERS\n+  // GETTERS (delegate to sub-components)\n   // ==========================================================================\n \n   getCell(x: number, y: number): Cell | null {\n-    if (x < 0 || x >= this.state.gridSize || y < 0 || y >= this.state.gridSize) {\n-      return null;\n-    }\n-    return { ...this.state.grid[y][x] };\n+    return this.gridManager.getCell(x, y);\n   }\n \n   getGridSize(): number {\n-    return this.state.gridSize;\n+    return this.gridManager.getSize();\n   }\n \n   getMoney(): number {\n-    return this.state.money;\n+    return this.money;\n   }\n \n   getTickCount(): number {\n-    return this.state.stats.tickCount;\n+    return this.stats.tickCount;\n   }\n \n   getMeltdownCount(): number {\n-    return this.state.stats.meltdownCount;\n+    return this.stats.meltdownCount;\n   }\n \n   getTotalPowerGenerated(): number {\n-    return this.state.stats.totalPowerGenerated;\n+    return this.stats.totalPowerGenerated;\n   }\n \n   getTotalMoneyEarned(): number {\n-    return this.state.stats.totalMoneyEarned;\n+    return this.stats.totalMoneyEarned;\n   }\n \n   getStats(): GameStats {\n-    return { ...this.state.stats };\n+    return { ...this.stats };\n   }\n \n   getUpgradeLevel(type: UpgradeType): number {\n-    return this.state.upgrades.levels[type];\n+    return this.upgradeManager.getUpgradeLevel(type);\n   }\n \n   isSecretUnlocked(type: SecretUpgradeType): boolean {\n-    return this.state.secrets.unlocked[type];\n+    return this.upgradeManager.isSecretUnlocked(type);\n   }\n \n   isSecretPurchased(type: SecretUpgradeType): boolean {\n-    return this.state.secrets.purchased[type];\n+    return this.upgradeManager.isSecretPurchased(type);\n   }\n \n   isSecretEnabled(type: SecretUpgradeType): boolean {\n-    return this.state.secrets.enabled[type];\n+    return this.upgradeManager.isSecretEnabled(type);\n   }\n \n   getGridSnapshot(): Cell[][] {\n-    return this.state.grid.map(row => row.map(cell => ({ ...cell })));\n+    return this.gridManager.getSnapshot();\n   }\n \n   getFilledCellCount(): number {\n-    let count = 0;\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        if (this.state.grid[y][x].structure !== StructureType.Empty) {\n-          count++;\n-        }\n-      }\n-    }\n-    return count;\n+    return this.gridManager.getFilledCellCount();\n   }\n \n   // ==========================================================================\n@@ -281,13 +261,13 @@ export class HeatGame {\n   // ==========================================================================\n \n   manualGenerate(): number {\n-    const upgradeLevel = this.state.upgrades.levels[UpgradeType.ManualClickPower];\n+    const upgradeLevel = this.upgradeManager.getUpgradeLevel(UpgradeType.ManualClickPower);\n     const moneyEarned = MANUAL_GENERATION.BASE_MONEY_PER_CLICK +\n       (upgradeLevel * MANUAL_GENERATION.MONEY_PER_LEVEL);\n \n-    this.state.money += moneyEarned;\n-    this.state.stats.totalMoneyEarned += moneyEarned;\n-    this.state.stats.manualClicks++;\n+    this.money += moneyEarned;\n+    this.stats.totalMoneyEarned += moneyEarned;\n+    this.stats.manualClicks++;\n \n     this.emitEvent({ type: 'manual_click', amount: moneyEarned });\n     return moneyEarned;\n@@ -302,20 +282,21 @@ export class HeatGame {\n   }\n \n   canBuild(x: number, y: number, structure: StructureType, tier: Tier = Tier.T1): boolean {\n-    const cell = this.getCell(x, y);\n+    const cell = this.gridManager.getCell(x, y);\n     if (!cell) return false;\n     if (cell.structure !== StructureType.Empty) return false;\n \n     // Check if structure is secret and not unlocked\n     const baseStats = STRUCTURE_BASE_STATS[structure];\n     if (baseStats.isSecret) {\n-      if (structure === StructureType.VoidCell && !this.state.secrets.purchased[SecretUpgradeType.VoidCellUnlock]) {\n+      if (structure === StructureType.VoidCell &&\n+          !this.upgradeManager.isSecretPurchased(SecretUpgradeType.VoidCellUnlock)) {\n         return false;\n       }\n     }\n \n     const cost = getStructureCost(structure, tier);\n-    return this.state.money >= cost;\n+    return this.money >= cost;\n   }\n \n   build(x: number, y: number, structure: StructureType, tier: Tier = Tier.T1, isExotic: boolean = false): boolean {\n@@ -323,16 +304,16 @@ export class HeatGame {\n \n     // Exotic fuel requires the secret to be purchased and enabled\n     if (isExotic && structure === StructureType.FuelRod) {\n-      if (!this.state.secrets.purchased[SecretUpgradeType.ExoticFuel] ||\n-          !this.state.secrets.enabled[SecretUpgradeType.ExoticFuel]) {\n+      if (!this.upgradeManager.isSecretPurchased(SecretUpgradeType.ExoticFuel) ||\n+          !this.upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)) {\n         isExotic = false;\n       }\n     }\n \n     const cost = getStructureCost(structure, tier);\n-    this.state.money -= cost;\n+    this.money -= cost;\n \n-    const cell = this.state.grid[y][x];\n+    const cell = this.gridManager.getCellRef(x, y)!;\n     cell.structure = structure;\n     cell.tier = tier;\n     cell.heat = 0;\n@@ -341,13 +322,13 @@ export class HeatGame {\n \n     // Set lifetime for fuel rods\n     if (structure === StructureType.FuelRod) {\n-      const upgradeLevel = this.state.upgrades.levels[UpgradeType.FuelLifetime];\n+      const upgradeLevel = this.upgradeManager.getUpgradeLevel(UpgradeType.FuelLifetime);\n       cell.lifetime = getFuelLifetime(tier, upgradeLevel);\n     } else {\n       cell.lifetime = 0;\n     }\n \n-    this.state.stats.structuresBuilt++;\n+    this.stats.structuresBuilt++;\n \n     this.emitEvent({\n       type: 'structure_built',\n@@ -357,28 +338,25 @@ export class HeatGame {\n       tier,\n     });\n \n-    // Check for secret unlocks\n     this.checkSecretUnlocks();\n-\n     return true;\n   }\n \n   demolish(x: number, y: number): boolean {\n-    const cell = this.getCell(x, y);\n+    const cell = this.gridManager.getCell(x, y);\n     if (!cell || cell.structure === StructureType.Empty) return false;\n \n-    const oldStructure = this.state.grid[y][x].structure;\n-    const oldTier = this.state.grid[y][x].tier;\n+    const oldStructure = cell.structure;\n+    const oldTier = cell.tier;\n \n     // Refund if salvage is unlocked\n-    if (this.state.secrets.purchased[SecretUpgradeType.Salvage]) {\n+    if (this.upgradeManager.isSecretPurchased(SecretUpgradeType.Salvage)) {\n       const refund = Math.floor(getStructureCost(oldStructure, oldTier) * 0.5);\n-      this.state.money += refund;\n+      this.money += refund;\n     }\n \n-    // Reset cell\n-    this.state.grid[y][x] = this.createEmptyCell(x, y);\n-    this.state.stats.demolishCount++;\n+    this.gridManager.resetCell(x, y);\n+    this.stats.demolishCount++;\n \n     this.emitEvent({\n       type: 'structure_destroyed',\n@@ -388,558 +366,157 @@ export class HeatGame {\n       tier: oldTier,\n     });\n \n-    // Check for salvage unlock\n     this.checkSecretUnlocks();\n-\n     return true;\n   }\n \n   // ==========================================================================\n-  // UPGRADES\n+  // UPGRADES (delegate to UpgradeManager)\n   // ==========================================================================\n \n   getUpgradeCost(type: UpgradeType): number {\n-    const currentLevel = this.state.upgrades.levels[type];\n-    return getUpgradeCost(type, currentLevel);\n+    return this.upgradeManager.getUpgradeCost(type);\n   }\n \n   canPurchaseUpgrade(type: UpgradeType): boolean {\n-    const definition = UPGRADE_DEFINITIONS[type];\n-    const currentLevel = this.state.upgrades.levels[type];\n-\n-    // Check max level\n-    if (definition.maxLevel > 0 && currentLevel >= definition.maxLevel) {\n-      return false;\n-    }\n-\n-    const cost = getUpgradeCost(type, currentLevel);\n-    return this.state.money >= cost;\n+    return this.upgradeManager.canPurchaseUpgrade(type, this.money);\n   }\n \n   purchaseUpgrade(type: UpgradeType): boolean {\n-    if (!this.canPurchaseUpgrade(type)) return false;\n-\n-    const cost = getUpgradeCost(type, this.state.upgrades.levels[type]);\n-    this.state.money -= cost;\n-    this.state.upgrades.levels[type]++;\n-\n-    this.emitEvent({ type: 'upgrade_purchased', upgradeType: type });\n-    return true;\n+    const cost = this.upgradeManager.purchaseUpgrade(type, this.money);\n+    if (cost > 0) {\n+      this.money -= cost;\n+      return true;\n+    }\n+    return false;\n   }\n \n   // ==========================================================================\n-  // SECRET UPGRADES\n+  // SECRET UPGRADES (delegate to UpgradeManager)\n   // ==========================================================================\n \n   getSecretCost(type: SecretUpgradeType): number {\n-    return SECRET_UPGRADE_DEFINITIONS[type].cost;\n+    return this.upgradeManager.getSecretCost(type);\n   }\n \n   canPurchaseSecret(type: SecretUpgradeType): boolean {\n-    if (!this.state.secrets.unlocked[type]) return false;\n-    if (this.state.secrets.purchased[type]) return false;\n-\n-    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n-    return this.state.money >= cost;\n+    return this.upgradeManager.canPurchaseSecret(type, this.money);\n   }\n \n   purchaseSecret(type: SecretUpgradeType): boolean {\n-    if (!this.canPurchaseSecret(type)) return false;\n-\n-    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n-    this.state.money -= cost;\n-    this.state.secrets.purchased[type] = true;\n-\n-    // Auto-enable toggleable secrets\n-    if (SECRET_UPGRADE_DEFINITIONS[type].isToggle) {\n-      this.state.secrets.enabled[type] = true;\n-    }\n+    const cost = this.upgradeManager.purchaseSecret(type, this.money);\n+    if (cost > 0) {\n+      this.money -= cost;\n+\n+      // Handle reactor expansion\n+      const expansionSize = this.upgradeManager.getExpansionSize(type);\n+      if (expansionSize !== null) {\n+        this.expandGrid(expansionSize);\n+      }\n \n-    // Handle reactor expansion\n-    if (type === SecretUpgradeType.ReactorExpansion1) {\n-      this.expandGrid(17);\n-    } else if (type === SecretUpgradeType.ReactorExpansion2) {\n-      this.expandGrid(18);\n-    } else if (type === SecretUpgradeType.ReactorExpansion3) {\n-      this.expandGrid(19);\n-    } else if (type === SecretUpgradeType.ReactorExpansion4) {\n-      this.expandGrid(20);\n+      return true;\n     }\n-\n-    this.emitEvent({ type: 'secret_purchased', secretType: type });\n-    return true;\n+    return false;\n   }\n \n   toggleSecret(type: SecretUpgradeType, enabled: boolean): void {\n-    if (!this.state.secrets.purchased[type]) return;\n-    if (!SECRET_UPGRADE_DEFINITIONS[type].isToggle) return;\n-\n-    this.state.secrets.enabled[type] = enabled;\n+    this.upgradeManager.toggleSecret(type, enabled);\n   }\n \n   private expandGrid(newSize: number): void {\n-    if (newSize <= this.state.gridSize) return;\n-    if (newSize > CORE_SETTINGS.MAX_GRID_SIZE) return;\n-\n-    const oldGrid = this.state.grid;\n-    const oldSize = this.state.gridSize;\n-\n-    // Create new larger grid\n-    this.state.grid = this.createEmptyGrid(newSize);\n-    this.state.gridSize = newSize;\n-\n-    // Copy old grid data\n-    for (let y = 0; y < oldSize; y++) {\n-      for (let x = 0; x < oldSize; x++) {\n-        this.state.grid[y][x] = { ...oldGrid[y][x] };\n-      }\n+    if (this.gridManager.expandGrid(newSize, CORE_SETTINGS.MAX_GRID_SIZE)) {\n+      this.emitEvent({ type: 'grid_expanded', newGridSize: newSize });\n     }\n-\n-    this.emitEvent({ type: 'grid_expanded', newGridSize: newSize });\n   }\n \n   private checkSecretUnlocks(): void {\n     const stats = {\n-      meltdownCount: this.state.stats.meltdownCount,\n-      filledCells: this.getFilledCellCount(),\n-      totalMoneyEarned: this.state.stats.totalMoneyEarned,\n-      demolishCount: this.state.stats.demolishCount,\n-      ticksAtHighHeat: this.state.stats.ticksAtHighHeat,\n+      meltdownCount: this.stats.meltdownCount,\n+      filledCells: this.gridManager.getFilledCellCount(),\n+      totalMoneyEarned: this.stats.totalMoneyEarned,\n+      demolishCount: this.stats.demolishCount,\n+      ticksAtHighHeat: this.stats.ticksAtHighHeat,\n     };\n \n-    for (const type of Object.values(SecretUpgradeType)) {\n-      if (this.state.secrets.unlocked[type]) continue;\n-\n-      const progress = getSecretUnlockProgress(type, stats);\n-      if (progress.unlocked) {\n-        this.state.secrets.unlocked[type] = true;\n-        this.emitEvent({ type: 'secret_unlocked', secretType: type });\n-      }\n-    }\n-  }\n-\n-  // ==========================================================================\n-  // NEIGHBORS\n-  // ==========================================================================\n-\n-  private getNeighbors(x: number, y: number): Cell[] {\n-    const neighbors: Cell[] = [];\n-    const directions = [\n-      { dx: 0, dy: -1 }, // up\n-      { dx: 0, dy: 1 },  // down\n-      { dx: -1, dy: 0 }, // left\n-      { dx: 1, dy: 0 },  // right\n-    ];\n-\n-    for (const { dx, dy } of directions) {\n-      const nx = x + dx;\n-      const ny = y + dy;\n-      if (nx >= 0 && nx < this.state.gridSize && ny >= 0 && ny < this.state.gridSize) {\n-        neighbors.push(this.state.grid[ny][nx]);\n-      }\n-    }\n-\n-    return neighbors;\n-  }\n-\n-  private countAdjacentFuelRods(x: number, y: number): number {\n-    const neighbors = this.getNeighbors(x, y);\n-    return neighbors.filter(n => n.structure === StructureType.FuelRod && n.lifetime > 0).length;\n-  }\n-\n-  // ==========================================================================\n-  // EFFECTIVE STATS (with upgrades)\n-  // ==========================================================================\n-\n-  private getEffectiveMeltTemp(structure: StructureType): number {\n-    const baseTemp = STRUCTURE_BASE_STATS[structure].meltTemp;\n-\n-    // Get the appropriate melt temp upgrade\n-    let upgradeType: UpgradeType | null = null;\n-    switch (structure) {\n-      case StructureType.FuelRod: upgradeType = UpgradeType.MeltTempFuelRod; break;\n-      case StructureType.Ventilator: upgradeType = UpgradeType.MeltTempVentilator; break;\n-      case StructureType.HeatExchanger: upgradeType = UpgradeType.MeltTempHeatExchanger; break;\n-      case StructureType.Insulator: upgradeType = UpgradeType.MeltTempInsulator; break;\n-      case StructureType.Turbine: upgradeType = UpgradeType.MeltTempTurbine; break;\n-      case StructureType.Substation: upgradeType = UpgradeType.MeltTempSubstation; break;\n-    }\n-\n-    if (upgradeType) {\n-      const level = this.state.upgrades.levels[upgradeType];\n-      const definition = UPGRADE_DEFINITIONS[upgradeType];\n-      return baseTemp + (level * definition.improvementPerLevel);\n-    }\n-\n-    return baseTemp;\n-  }\n-\n-  private getEffectiveConductivity(cell: Cell): number {\n-    const baseConductivity = STRUCTURE_BASE_STATS[cell.structure].conductivity;\n-\n-    if (cell.structure === StructureType.Turbine) {\n-      const level = this.state.upgrades.levels[UpgradeType.TurbineConductivity];\n-      const definition = UPGRADE_DEFINITIONS[UpgradeType.TurbineConductivity];\n-      return baseConductivity + (level * definition.improvementPerLevel);\n-    }\n-\n-    if (cell.structure === StructureType.Insulator) {\n-      const level = this.state.upgrades.levels[UpgradeType.InsulatorConductivity];\n-      if (level > 0) {\n-        // Multiplicative reduction\n-        return baseConductivity * Math.pow(0.5, level);\n-      }\n-    }\n-\n-    return baseConductivity;\n-  }\n-\n-  private getEffectiveHeatDissipation(cell: Cell): number {\n-    if (cell.structure !== StructureType.Ventilator && cell.structure !== StructureType.VoidCell) {\n-      return 0;\n-    }\n-\n-    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n-    let dissipation = baseStats.heatDissipation;\n-\n-    // Scale with tier for ventilators\n-    if (cell.structure === StructureType.Ventilator) {\n-      dissipation *= Math.pow(10, cell.tier - 1);\n-\n-      // Add upgrade bonus\n-      const level = this.state.upgrades.levels[UpgradeType.VentilatorDissipation];\n-      const definition = UPGRADE_DEFINITIONS[UpgradeType.VentilatorDissipation];\n-      dissipation += level * definition.improvementPerLevel;\n-    }\n-\n-    return dissipation;\n-  }\n-\n-  private getEffectivePowerSaleRate(cell: Cell): number {\n-    if (cell.structure !== StructureType.Substation) return 0;\n-\n-    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n-    let saleRate = baseStats.powerSaleRate;\n-\n-    // Scale with tier\n-    saleRate *= Math.pow(10, cell.tier - 1);\n-\n-    // Add upgrade bonus\n-    const level = this.state.upgrades.levels[UpgradeType.SubstationSaleRate];\n-    const definition = UPGRADE_DEFINITIONS[UpgradeType.SubstationSaleRate];\n-    saleRate += level * definition.improvementPerLevel;\n-\n-    return saleRate;\n+    this.upgradeManager.checkSecretUnlocks(stats);\n   }\n \n   // ==========================================================================\n-  // GAME TICK\n+  // GAME TICK (delegate to PhysicsEngine)\n   // ==========================================================================\n \n   tick(): void {\n-    this.state.stats.tickCount++;\n+    this.stats.tickCount++;\n \n-    // Phase 1: Heat generation (fuel rods with adjacency bonus)\n-    this.processHeatGeneration();\n+    // Run physics simulation\n+    const result = this.physicsEngine.tick();\n \n-    // Phase 2: Fuel depletion\n-    this.processFuelDepletion();\n+    // Sync stats from physics engine (single source of truth for physics-related stats)\n+    const physicsStats = this.physicsEngine.getStats();\n+    this.stats.totalPowerGenerated = physicsStats.totalPowerGenerated;\n+    this.stats.ticksAtHighHeat = physicsStats.ticksAtHighHeat;\n+    this.stats.fuelRodsDepleted = physicsStats.fuelRodsDepleted;\n \n-    // Phase 3: Heat transfer between cells\n-    this.processHeatTransfer();\n+    // Add money earned from power sales\n+    this.money += result.moneyEarned;\n+    this.stats.totalMoneyEarned += result.moneyEarned;\n \n-    // Phase 4: Heat dissipation (ventilators)\n-    this.processHeatDissipation();\n-\n-    // Phase 5: Power generation (turbines)\n-    this.processPowerGeneration();\n-\n-    // Phase 6: Power collection and sale (substations)\n-    this.processPowerSale();\n-\n-    // Phase 7: Check for overheating and meltdowns\n-    this.processOverheating();\n-\n-    // Phase 8: Track high heat survival\n-    this.trackHighHeatSurvival();\n-\n-    // Phase 9: Check secret unlocks\n+    // Check secret unlocks\n     this.checkSecretUnlocks();\n   }\n \n-  private processHeatGeneration(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-\n-        if (cell.structure !== StructureType.FuelRod) continue;\n-        if (cell.lifetime <= 0) continue; // Depleted fuel generates no heat\n-\n-        // Get base heat generation for this tier\n-        const upgradeLevel = this.state.upgrades.levels[UpgradeType.FuelHeatOutput];\n-        let heatGeneration = getFuelHeatGeneration(cell.tier, upgradeLevel);\n-\n-        // Adjacency bonus (4-way orthogonal)\n-        const adjacentFuelRods = this.countAdjacentFuelRods(x, y);\n-        const adjacencyMultiplier = 1 + (adjacentFuelRods * FUEL_ADJACENCY.BONUS_PER_ADJACENT);\n-        heatGeneration *= adjacencyMultiplier;\n-\n-        // Exotic fuel: heat scales with current temperature\n-        if (cell.isExotic) {\n-          const tempMultiplier = Math.min(\n-            EXOTIC_FUEL.MAX_MULTIPLIER,\n-            EXOTIC_FUEL.BASE_MULTIPLIER + (cell.heat / 1000) * EXOTIC_FUEL.HEAT_SCALING\n-          );\n-          heatGeneration *= tempMultiplier;\n-        }\n-\n-        cell.heat += heatGeneration;\n-      }\n-    }\n-  }\n-\n-  private processFuelDepletion(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-\n-        if (cell.structure !== StructureType.FuelRod) continue;\n-        if (cell.lifetime <= 0) continue;\n-\n-        cell.lifetime--;\n-\n-        if (cell.lifetime <= 0) {\n-          this.state.stats.fuelRodsDepleted++;\n-          this.emitEvent({\n-            type: 'fuel_depleted',\n-            x,\n-            y,\n-            tier: cell.tier,\n-          });\n-        }\n-      }\n-    }\n-  }\n-\n-  private processHeatTransfer(): void {\n-    const heatDeltas: number[][] = [];\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      heatDeltas.push(new Array(this.state.gridSize).fill(0));\n-    }\n-\n-    const transferRate = CORE_SETTINGS.BASE_HEAT_TRANSFER_RATE;\n-\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        const cellConductivity = this.getEffectiveConductivity(cell);\n-        const neighbors = this.getNeighbors(x, y);\n-\n-        for (const neighbor of neighbors) {\n-          const neighborConductivity = this.getEffectiveConductivity(neighbor);\n-          const heatDiff = cell.heat - neighbor.heat;\n-\n-          // Heat flows from hot to cold\n-          if (heatDiff > 0) {\n-            const conductivity = Math.min(cellConductivity, neighborConductivity);\n-            const transfer = heatDiff * transferRate * conductivity;\n-            heatDeltas[y][x] -= transfer;\n-            heatDeltas[neighbor.y][neighbor.x] += transfer;\n-          }\n-        }\n-\n-        // Edge cells lose heat to environment\n-        const edgeCount = 4 - neighbors.length;\n-        if (edgeCount > 0 && cell.heat > CORE_SETTINGS.AMBIENT_TEMPERATURE) {\n-          const heatAboveAmbient = cell.heat - CORE_SETTINGS.AMBIENT_TEMPERATURE;\n-          const envTransfer = heatAboveAmbient * CORE_SETTINGS.ENVIRONMENT_HEAT_TRANSFER_RATE * edgeCount;\n-          heatDeltas[y][x] -= envTransfer;\n-        }\n-      }\n-    }\n-\n-    // Apply deltas\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        this.state.grid[y][x].heat = Math.max(0, this.state.grid[y][x].heat + heatDeltas[y][x]);\n-      }\n-    }\n-  }\n-\n-  private processHeatDissipation(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        const dissipation = this.getEffectiveHeatDissipation(cell);\n-        cell.heat = Math.max(0, cell.heat - dissipation);\n-      }\n-    }\n-  }\n-\n-  private processPowerGeneration(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        if (cell.structure !== StructureType.Turbine) continue;\n-        if (cell.heat <= 0) continue;\n-\n-        const baseStats = STRUCTURE_BASE_STATS[StructureType.Turbine];\n-        const maxHeatConsumption = baseStats.maxHeatConsumption * Math.pow(10, cell.tier - 1);\n-        const powerGeneration = baseStats.powerGeneration;\n-\n-        const heatConsumed = Math.min(cell.heat, maxHeatConsumption);\n-        const powerGenerated = heatConsumed * powerGeneration;\n-\n-        cell.heat -= heatConsumed;\n-        cell.power += powerGenerated;\n-        this.state.stats.totalPowerGenerated += powerGenerated;\n-      }\n-    }\n-  }\n-\n-  private processPowerSale(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-\n-        // Turbines transfer power to nearby substations\n-        if (cell.structure === StructureType.Turbine && cell.power > 0) {\n-          const neighbors = this.getNeighbors(x, y);\n-          for (const neighbor of neighbors) {\n-            if (neighbor.structure === StructureType.Substation) {\n-              this.state.grid[neighbor.y][neighbor.x].power += cell.power;\n-              cell.power = 0;\n-              break;\n-            }\n-          }\n-        }\n-\n-        // Substations sell power\n-        if (cell.structure === StructureType.Substation && cell.power > 0) {\n-          const saleRate = this.getEffectivePowerSaleRate(cell);\n-          const powerToSell = Math.min(cell.power, saleRate);\n-          const earnings = powerToSell * ECONOMY.MONEY_PER_POWER;\n-\n-          this.state.money += earnings;\n-          this.state.stats.totalMoneyEarned += earnings;\n-          cell.power -= powerToSell;\n-\n-          if (earnings > 0) {\n-            this.emitEvent({\n-              type: 'power_sold',\n-              x,\n-              y,\n-              amount: earnings,\n-            });\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  private processOverheating(): void {\n-    let meltdown = false;\n-    const meltedCells: { x: number; y: number; structure: StructureType; tier: Tier }[] = [];\n-\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        if (cell.structure === StructureType.Empty) continue;\n-\n-        const meltTemp = this.getEffectiveMeltTemp(cell.structure);\n-        if (cell.heat > meltTemp) {\n-          if (cell.structure === StructureType.FuelRod) {\n-            // Fuel rod meltdown - catastrophic failure\n-            meltdown = true;\n-          } else {\n-            // Regular structure melts\n-            meltedCells.push({ x, y, structure: cell.structure, tier: cell.tier });\n-          }\n-        }\n-      }\n-    }\n-\n-    // Melt non-fuel structures\n-    for (const { x, y, structure, tier } of meltedCells) {\n-      this.state.grid[y][x] = this.createEmptyCell(x, y);\n-      this.emitEvent({\n-        type: 'structure_melted',\n-        x,\n-        y,\n-        structure,\n-        tier,\n-      });\n-    }\n-\n-    if (meltdown) {\n-      this.triggerMeltdown();\n-    }\n-  }\n-\n-  private triggerMeltdown(): void {\n-    this.state.stats.meltdownCount++;\n-\n-    // Destroy all structures but keep money\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        this.state.grid[y][x] = this.createEmptyCell(x, y);\n-      }\n-    }\n-\n-    this.emitEvent({ type: 'meltdown' });\n-\n-    // Check for exotic fuel unlock\n-    this.checkSecretUnlocks();\n-  }\n-\n-  private trackHighHeatSurvival(): void {\n-    // Check if any fuel rod is at >90% of its melt temp\n-    let hasHighHeatFuelRod = false;\n-\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        if (cell.structure !== StructureType.FuelRod) continue;\n-\n-        const meltTemp = this.getEffectiveMeltTemp(StructureType.FuelRod);\n-        if (cell.heat >= meltTemp * 0.9) {\n-          hasHighHeatFuelRod = true;\n-          break;\n-        }\n-      }\n-      if (hasHighHeatFuelRod) break;\n-    }\n-\n-    if (hasHighHeatFuelRod) {\n-      this.state.stats.ticksAtHighHeat++;\n-    }\n-  }\n-\n   // ==========================================================================\n   // SERIALIZATION\n   // ==========================================================================\n \n   serialize(): string {\n-    return JSON.stringify(this.state);\n+    const state: GameState = {\n+      grid: this.gridManager.getSnapshot(),\n+      gridSize: this.gridManager.getSize(),\n+      money: this.money,\n+      stats: { ...this.stats },\n+      upgrades: this.upgradeManager.getUpgradeState(),\n+      secrets: this.upgradeManager.getSecretState(),\n+    };\n+    return JSON.stringify(state);\n   }\n \n   static deserialize(data: string): HeatGame {\n     const state = JSON.parse(data) as GameState;\n     const game = new HeatGame(0);\n-    game.state = state;\n+\n+    // Restore grid\n+    game.gridManager.restoreFromState(state.grid, state.gridSize);\n+\n+    // Restore money and stats\n+    game.money = state.money;\n+    game.stats = { ...state.stats };\n+\n+    // Restore upgrades\n+    game.upgradeManager.restoreUpgradeState(state.upgrades);\n+    game.upgradeManager.restoreSecretState(state.secrets);\n+\n+    // Sync physics engine stats\n+    game.physicsEngine.setStats({\n+      totalPowerGenerated: state.stats.totalPowerGenerated,\n+      totalMoneyEarned: state.stats.totalMoneyEarned,\n+      fuelRodsDepleted: state.stats.fuelRodsDepleted,\n+      ticksAtHighHeat: state.stats.ticksAtHighHeat,\n+    });\n+\n     return game;\n   }\n \n   // ==========================================================================\n-  // BACKWARD COMPATIBILITY (for tests)\n+  // BACKWARD COMPATIBILITY\n   // ==========================================================================\n \n   /** @deprecated Use getGridSize() instead */\n   get GRID_SIZE(): number {\n-    return this.state.gridSize;\n+    return this.gridManager.getSize();\n   }\n }\n \n-// Re-export GRID_SIZE for backward compatibility\n+// Re-export for backward compatibility\n export { CORE_SETTINGS };\n export const GRID_SIZE = CORE_SETTINGS.INITIAL_GRID_SIZE;\ndiff --git a/src/game/PhysicsEngine.test.ts b/src/game/PhysicsEngine.test.ts\nnew file mode 100644\nindex 0000000..b1487d7\n--- /dev/null\n+++ b/src/game/PhysicsEngine.test.ts\n@@ -0,0 +1,152 @@\n+/**\n+ * PhysicsEngine Unit Tests\n+ *\n+ * Focus: Core physics mechanics, meltdown behavior (catastrophic), upgrade interactions\n+ */\n+\n+import { describe, it, expect, beforeEach } from 'vitest';\n+import { GridManager } from './GridManager.js';\n+import { PhysicsEngine } from './PhysicsEngine.js';\n+import { StructureType, Tier, UpgradeType, STRUCTURE_BASE_STATS } from './BalanceConfig.js';\n+\n+describe('PhysicsEngine', () => {\n+  let grid: GridManager;\n+  let physics: PhysicsEngine;\n+  let upgradeLevels: Map<UpgradeType, number>;\n+\n+  beforeEach(() => {\n+    grid = new GridManager(16);\n+    upgradeLevels = new Map();\n+    physics = new PhysicsEngine(grid, (type) => upgradeLevels.get(type) ?? 0);\n+  });\n+\n+  describe('heat mechanics', () => {\n+    it('fuel rods generate heat only when active', () => {\n+      const active = grid.getCellRef(3, 3)!;\n+      active.structure = StructureType.FuelRod;\n+      active.lifetime = 100;\n+\n+      const depleted = grid.getCellRef(8, 8)!;\n+      depleted.structure = StructureType.FuelRod;\n+      depleted.lifetime = 0;\n+\n+      physics.processHeatGeneration();\n+\n+      expect(grid.getCell(3, 3)!.heat).toBeGreaterThan(0);\n+      expect(grid.getCell(8, 8)!.heat).toBe(0);\n+    });\n+\n+    it('adjacent fuel rods boost heat generation', () => {\n+      const center = grid.getCellRef(5, 5)!;\n+      center.structure = StructureType.FuelRod;\n+      center.lifetime = 100;\n+\n+      physics.processHeatGeneration();\n+      const baseHeat = grid.getCell(5, 5)!.heat;\n+\n+      // Reset and add neighbor\n+      grid.getCellRef(5, 5)!.heat = 0;\n+      const neighbor = grid.getCellRef(5, 4)!;\n+      neighbor.structure = StructureType.FuelRod;\n+      neighbor.lifetime = 100;\n+\n+      physics.processHeatGeneration();\n+      expect(grid.getCell(5, 5)!.heat).toBeGreaterThan(baseHeat);\n+    });\n+\n+    it('heat transfers from hot to cold cells', () => {\n+      grid.getCellRef(5, 5)!.heat = 1000;\n+      grid.getCellRef(5, 6)!.heat = 0;\n+\n+      physics.processHeatTransfer();\n+\n+      expect(grid.getCell(5, 5)!.heat).toBeLessThan(1000);\n+      expect(grid.getCell(5, 6)!.heat).toBeGreaterThan(0);\n+    });\n+\n+    it('insulators block heat transfer', () => {\n+      const insulator = grid.getCellRef(5, 5)!;\n+      insulator.structure = StructureType.Insulator;\n+      insulator.heat = 1000;\n+\n+      physics.processHeatTransfer();\n+      const insulatorHeatAfter = grid.getCell(5, 5)!.heat;\n+\n+      // Compare with empty cell\n+      grid.getCellRef(5, 5)!.structure = StructureType.Empty;\n+      grid.getCellRef(5, 5)!.heat = 1000;\n+      physics.processHeatTransfer();\n+\n+      expect(insulatorHeatAfter).toBeGreaterThan(grid.getCell(5, 5)!.heat);\n+    });\n+  });\n+\n+  describe('meltdown behavior', () => {\n+    it('fuel rod overheating triggers meltdown and clears grid', () => {\n+      // Place some structures\n+      grid.getCellRef(3, 3)!.structure = StructureType.Turbine;\n+      grid.getCellRef(8, 8)!.structure = StructureType.Ventilator;\n+\n+      // Overheat fuel rod\n+      const fuel = grid.getCellRef(5, 5)!;\n+      fuel.structure = StructureType.FuelRod;\n+      fuel.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp + 100;\n+\n+      const meltdown = physics.processOverheating();\n+\n+      expect(meltdown).toBe(true);\n+      expect(grid.getFilledCellCount()).toBe(0);\n+    });\n+\n+    it('non-fuel structures melt individually without meltdown', () => {\n+      const turbine = grid.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.heat = STRUCTURE_BASE_STATS[StructureType.Turbine].meltTemp + 100;\n+\n+      const meltdown = physics.processOverheating();\n+\n+      expect(meltdown).toBe(false);\n+      expect(grid.getCell(5, 5)!.structure).toBe(StructureType.Empty);\n+    });\n+  });\n+\n+  describe('power flow', () => {\n+    it('complete power chain: fuel -> turbine -> substation -> money', () => {\n+      const fuel = grid.getCellRef(5, 5)!;\n+      fuel.structure = StructureType.FuelRod;\n+      fuel.lifetime = 100;\n+\n+      const turbine = grid.getCellRef(5, 6)!;\n+      turbine.structure = StructureType.Turbine;\n+\n+      const substation = grid.getCellRef(5, 7)!;\n+      substation.structure = StructureType.Substation;\n+\n+      const result = physics.tick();\n+\n+      expect(result.moneyEarned).toBeGreaterThan(0);\n+      expect(result.meltdown).toBe(false);\n+    });\n+  });\n+\n+  describe('upgrade effects', () => {\n+    it('melt temp upgrades increase tolerance', () => {\n+      const base = physics.getEffectiveMeltTemp(StructureType.FuelRod);\n+\n+      upgradeLevels.set(UpgradeType.MeltTempFuelRod, 3);\n+\n+      expect(physics.getEffectiveMeltTemp(StructureType.FuelRod)).toBeGreaterThan(base);\n+    });\n+\n+    it('insulator upgrades reduce conductivity', () => {\n+      const insulator = grid.getCellRef(5, 5)!;\n+      insulator.structure = StructureType.Insulator;\n+\n+      const base = physics.getEffectiveConductivity(insulator);\n+\n+      upgradeLevels.set(UpgradeType.InsulatorConductivity, 2);\n+\n+      expect(physics.getEffectiveConductivity(insulator)).toBeLessThan(base);\n+    });\n+  });\n+});\ndiff --git a/src/game/PhysicsEngine.ts b/src/game/PhysicsEngine.ts\nnew file mode 100644\nindex 0000000..ef4c504\n--- /dev/null\n+++ b/src/game/PhysicsEngine.ts\n@@ -0,0 +1,483 @@\n+/**\n+ * PhysicsEngine - Handles heat generation, transfer, dissipation, and power generation\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ * This class is responsible for all physics simulation logic.\n+ */\n+\n+import {\n+  CORE_SETTINGS,\n+  StructureType,\n+  Tier,\n+  STRUCTURE_BASE_STATS,\n+  FUEL_ADJACENCY,\n+  ECONOMY,\n+  UpgradeType,\n+  UPGRADE_DEFINITIONS,\n+  EXOTIC_FUEL,\n+  getFuelHeatGeneration,\n+} from './BalanceConfig.js';\n+import { Cell, GridManager } from './GridManager.js';\n+\n+export interface PhysicsEvent {\n+  type: 'fuel_depleted' | 'power_sold' | 'structure_melted' | 'meltdown';\n+  x?: number;\n+  y?: number;\n+  tier?: Tier;\n+  structure?: StructureType;\n+  amount?: number;\n+}\n+\n+export type PhysicsEventListener = (event: PhysicsEvent) => void;\n+\n+export interface UpgradeLevels {\n+  [key: string]: number;\n+}\n+\n+export interface PhysicsStats {\n+  totalPowerGenerated: number;\n+  totalMoneyEarned: number;\n+  fuelRodsDepleted: number;\n+  ticksAtHighHeat: number;\n+}\n+\n+/**\n+ * PhysicsEngine handles all physics simulation for the heat game.\n+ * It operates on a GridManager and uses upgrade levels for calculations.\n+ */\n+export class PhysicsEngine {\n+  private eventListeners: PhysicsEventListener[] = [];\n+  private stats: PhysicsStats = {\n+    totalPowerGenerated: 0,\n+    totalMoneyEarned: 0,\n+    fuelRodsDepleted: 0,\n+    ticksAtHighHeat: 0,\n+  };\n+\n+  constructor(\n+    private gridManager: GridManager,\n+    private getUpgradeLevel: (type: UpgradeType) => number\n+  ) {}\n+\n+  /**\n+   * Add an event listener for physics events\n+   */\n+  addEventListener(listener: PhysicsEventListener): void {\n+    this.eventListeners.push(listener);\n+  }\n+\n+  /**\n+   * Remove an event listener\n+   */\n+  removeEventListener(listener: PhysicsEventListener): void {\n+    const index = this.eventListeners.indexOf(listener);\n+    if (index !== -1) {\n+      this.eventListeners.splice(index, 1);\n+    }\n+  }\n+\n+  private emitEvent(event: PhysicsEvent): void {\n+    for (const listener of this.eventListeners) {\n+      listener(event);\n+    }\n+  }\n+\n+  /**\n+   * Get the current physics stats\n+   */\n+  getStats(): PhysicsStats {\n+    return { ...this.stats };\n+  }\n+\n+  /**\n+   * Reset stats (used after deserialization)\n+   */\n+  setStats(stats: PhysicsStats): void {\n+    this.stats = { ...stats };\n+  }\n+\n+  /**\n+   * Get effective melt temperature for a structure type (with upgrades)\n+   */\n+  getEffectiveMeltTemp(structure: StructureType): number {\n+    const baseTemp = STRUCTURE_BASE_STATS[structure].meltTemp;\n+\n+    let upgradeType: UpgradeType | null = null;\n+    switch (structure) {\n+      case StructureType.FuelRod: upgradeType = UpgradeType.MeltTempFuelRod; break;\n+      case StructureType.Ventilator: upgradeType = UpgradeType.MeltTempVentilator; break;\n+      case StructureType.HeatExchanger: upgradeType = UpgradeType.MeltTempHeatExchanger; break;\n+      case StructureType.Insulator: upgradeType = UpgradeType.MeltTempInsulator; break;\n+      case StructureType.Turbine: upgradeType = UpgradeType.MeltTempTurbine; break;\n+      case StructureType.Substation: upgradeType = UpgradeType.MeltTempSubstation; break;\n+    }\n+\n+    if (upgradeType) {\n+      const level = this.getUpgradeLevel(upgradeType);\n+      const definition = UPGRADE_DEFINITIONS[upgradeType];\n+      return baseTemp + (level * definition.improvementPerLevel);\n+    }\n+\n+    return baseTemp;\n+  }\n+\n+  /**\n+   * Get effective conductivity for a cell (with upgrades)\n+   */\n+  getEffectiveConductivity(cell: Cell): number {\n+    const baseConductivity = STRUCTURE_BASE_STATS[cell.structure].conductivity;\n+\n+    if (cell.structure === StructureType.Turbine) {\n+      const level = this.getUpgradeLevel(UpgradeType.TurbineConductivity);\n+      const definition = UPGRADE_DEFINITIONS[UpgradeType.TurbineConductivity];\n+      return baseConductivity + (level * definition.improvementPerLevel);\n+    }\n+\n+    if (cell.structure === StructureType.Insulator) {\n+      const level = this.getUpgradeLevel(UpgradeType.InsulatorConductivity);\n+      if (level > 0) {\n+        return baseConductivity * Math.pow(0.5, level);\n+      }\n+    }\n+\n+    return baseConductivity;\n+  }\n+\n+  /**\n+   * Get effective heat dissipation for a cell (with upgrades)\n+   */\n+  getEffectiveHeatDissipation(cell: Cell): number {\n+    if (cell.structure !== StructureType.Ventilator && cell.structure !== StructureType.VoidCell) {\n+      return 0;\n+    }\n+\n+    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n+    let dissipation = baseStats.heatDissipation;\n+\n+    if (cell.structure === StructureType.Ventilator) {\n+      dissipation *= Math.pow(10, cell.tier - 1);\n+\n+      const level = this.getUpgradeLevel(UpgradeType.VentilatorDissipation);\n+      const definition = UPGRADE_DEFINITIONS[UpgradeType.VentilatorDissipation];\n+      dissipation += level * definition.improvementPerLevel;\n+    }\n+\n+    return dissipation;\n+  }\n+\n+  /**\n+   * Get effective power sale rate for a cell (with upgrades)\n+   */\n+  getEffectivePowerSaleRate(cell: Cell): number {\n+    if (cell.structure !== StructureType.Substation) return 0;\n+\n+    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n+    let saleRate = baseStats.powerSaleRate;\n+\n+    saleRate *= Math.pow(10, cell.tier - 1);\n+\n+    const level = this.getUpgradeLevel(UpgradeType.SubstationSaleRate);\n+    const definition = UPGRADE_DEFINITIONS[UpgradeType.SubstationSaleRate];\n+    saleRate += level * definition.improvementPerLevel;\n+\n+    return saleRate;\n+  }\n+\n+  /**\n+   * Process heat generation from fuel rods\n+   */\n+  processHeatGeneration(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+        if (cell.lifetime <= 0) continue;\n+\n+        const upgradeLevel = this.getUpgradeLevel(UpgradeType.FuelHeatOutput);\n+        let heatGeneration = getFuelHeatGeneration(cell.tier, upgradeLevel);\n+\n+        // Adjacency bonus\n+        const adjacentFuelRods = this.gridManager.countAdjacentFuelRods(x, y);\n+        const adjacencyMultiplier = 1 + (adjacentFuelRods * FUEL_ADJACENCY.BONUS_PER_ADJACENT);\n+        heatGeneration *= adjacencyMultiplier;\n+\n+        // Exotic fuel scaling\n+        if (cell.isExotic) {\n+          const tempMultiplier = Math.min(\n+            EXOTIC_FUEL.MAX_MULTIPLIER,\n+            EXOTIC_FUEL.BASE_MULTIPLIER + (cell.heat / 1000) * EXOTIC_FUEL.HEAT_SCALING\n+          );\n+          heatGeneration *= tempMultiplier;\n+        }\n+\n+        cell.heat += heatGeneration;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process fuel depletion\n+   */\n+  processFuelDepletion(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+        if (cell.lifetime <= 0) continue;\n+\n+        cell.lifetime--;\n+\n+        if (cell.lifetime <= 0) {\n+          this.stats.fuelRodsDepleted++;\n+          this.emitEvent({\n+            type: 'fuel_depleted',\n+            x,\n+            y,\n+            tier: cell.tier,\n+          });\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process heat transfer between cells\n+   */\n+  processHeatTransfer(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    const heatDeltas: number[][] = [];\n+    for (let y = 0; y < gridSize; y++) {\n+      heatDeltas.push(new Array(gridSize).fill(0));\n+    }\n+\n+    const transferRate = CORE_SETTINGS.BASE_HEAT_TRANSFER_RATE;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        const cellConductivity = this.getEffectiveConductivity(cell);\n+        const neighbors = this.gridManager.getNeighbors(x, y);\n+\n+        for (const neighbor of neighbors) {\n+          const neighborConductivity = this.getEffectiveConductivity(neighbor);\n+          const heatDiff = cell.heat - neighbor.heat;\n+\n+          if (heatDiff > 0) {\n+            const conductivity = Math.min(cellConductivity, neighborConductivity);\n+            const transfer = heatDiff * transferRate * conductivity;\n+            heatDeltas[y][x] -= transfer;\n+            heatDeltas[neighbor.y][neighbor.x] += transfer;\n+          }\n+        }\n+\n+        // Edge cells lose heat to environment\n+        const edgeCount = 4 - neighbors.length;\n+        if (edgeCount > 0 && cell.heat > CORE_SETTINGS.AMBIENT_TEMPERATURE) {\n+          const heatAboveAmbient = cell.heat - CORE_SETTINGS.AMBIENT_TEMPERATURE;\n+          const envTransfer = heatAboveAmbient * CORE_SETTINGS.ENVIRONMENT_HEAT_TRANSFER_RATE * edgeCount;\n+          heatDeltas[y][x] -= envTransfer;\n+        }\n+      }\n+    }\n+\n+    // Apply deltas\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        grid[y][x].heat = Math.max(0, grid[y][x].heat + heatDeltas[y][x]);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process heat dissipation (ventilators and void cells)\n+   */\n+  processHeatDissipation(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        const dissipation = this.getEffectiveHeatDissipation(cell);\n+        cell.heat = Math.max(0, cell.heat - dissipation);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process power generation (turbines)\n+   */\n+  processPowerGeneration(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure !== StructureType.Turbine) continue;\n+        if (cell.heat <= 0) continue;\n+\n+        const baseStats = STRUCTURE_BASE_STATS[StructureType.Turbine];\n+        const maxHeatConsumption = baseStats.maxHeatConsumption * Math.pow(10, cell.tier - 1);\n+        const powerGeneration = baseStats.powerGeneration;\n+\n+        const heatConsumed = Math.min(cell.heat, maxHeatConsumption);\n+        const powerGenerated = heatConsumed * powerGeneration;\n+\n+        cell.heat -= heatConsumed;\n+        cell.power += powerGenerated;\n+        this.stats.totalPowerGenerated += powerGenerated;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process power sale (substations)\n+   * Returns the amount of money earned\n+   */\n+  processPowerSale(): number {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let totalEarnings = 0;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        // Turbines transfer power to nearby substations\n+        if (cell.structure === StructureType.Turbine && cell.power > 0) {\n+          const neighbors = this.gridManager.getNeighbors(x, y);\n+          for (const neighbor of neighbors) {\n+            if (neighbor.structure === StructureType.Substation) {\n+              grid[neighbor.y][neighbor.x].power += cell.power;\n+              cell.power = 0;\n+              break;\n+            }\n+          }\n+        }\n+\n+        // Substations sell power\n+        if (cell.structure === StructureType.Substation && cell.power > 0) {\n+          const saleRate = this.getEffectivePowerSaleRate(cell);\n+          const powerToSell = Math.min(cell.power, saleRate);\n+          const earnings = powerToSell * ECONOMY.MONEY_PER_POWER;\n+\n+          totalEarnings += earnings;\n+          this.stats.totalMoneyEarned += earnings;\n+          cell.power -= powerToSell;\n+\n+          if (earnings > 0) {\n+            this.emitEvent({\n+              type: 'power_sold',\n+              x,\n+              y,\n+              amount: earnings,\n+            });\n+          }\n+        }\n+      }\n+    }\n+\n+    return totalEarnings;\n+  }\n+\n+  /**\n+   * Process overheating and meltdowns\n+   * Returns true if a meltdown occurred\n+   */\n+  processOverheating(): boolean {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let meltdown = false;\n+    const meltedCells: { x: number; y: number; structure: StructureType; tier: Tier }[] = [];\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure === StructureType.Empty) continue;\n+\n+        const meltTemp = this.getEffectiveMeltTemp(cell.structure);\n+        if (cell.heat > meltTemp) {\n+          if (cell.structure === StructureType.FuelRod) {\n+            meltdown = true;\n+          } else {\n+            meltedCells.push({ x, y, structure: cell.structure, tier: cell.tier });\n+          }\n+        }\n+      }\n+    }\n+\n+    // Melt non-fuel structures\n+    for (const { x, y, structure, tier } of meltedCells) {\n+      this.gridManager.resetCell(x, y);\n+      this.emitEvent({\n+        type: 'structure_melted',\n+        x,\n+        y,\n+        structure,\n+        tier,\n+      });\n+    }\n+\n+    if (meltdown) {\n+      this.gridManager.clearAll();\n+      this.emitEvent({ type: 'meltdown' });\n+    }\n+\n+    return meltdown;\n+  }\n+\n+  /**\n+   * Track high heat survival (for secret unlock)\n+   */\n+  trackHighHeatSurvival(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let hasHighHeatFuelRod = false;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+\n+        const meltTemp = this.getEffectiveMeltTemp(StructureType.FuelRod);\n+        if (cell.heat >= meltTemp * 0.9) {\n+          hasHighHeatFuelRod = true;\n+          break;\n+        }\n+      }\n+      if (hasHighHeatFuelRod) break;\n+    }\n+\n+    if (hasHighHeatFuelRod) {\n+      this.stats.ticksAtHighHeat++;\n+    }\n+  }\n+\n+  /**\n+   * Run a complete physics tick\n+   * Returns the money earned from power sales\n+   */\n+  tick(): { moneyEarned: number; meltdown: boolean } {\n+    this.processHeatGeneration();\n+    this.processFuelDepletion();\n+    this.processHeatTransfer();\n+    this.processHeatDissipation();\n+    this.processPowerGeneration();\n+    const moneyEarned = this.processPowerSale();\n+    const meltdown = this.processOverheating();\n+    this.trackHighHeatSurvival();\n+\n+    return { moneyEarned, meltdown };\n+  }\n+}\ndiff --git a/src/game/UpgradeManager.test.ts b/src/game/UpgradeManager.test.ts\nnew file mode 100644\nindex 0000000..2b215ce\n--- /dev/null\n+++ b/src/game/UpgradeManager.test.ts\n@@ -0,0 +1,115 @@\n+/**\n+ * UpgradeManager Unit Tests\n+ *\n+ * Focus: Serialization (data loss risk), max level enforcement, unlock conditions\n+ */\n+\n+import { describe, it, expect, beforeEach } from 'vitest';\n+import { UpgradeManager } from './UpgradeManager.js';\n+import { UpgradeType, SecretUpgradeType, UPGRADE_DEFINITIONS } from './BalanceConfig.js';\n+\n+describe('UpgradeManager', () => {\n+  let upgrades: UpgradeManager;\n+\n+  beforeEach(() => {\n+    upgrades = new UpgradeManager();\n+  });\n+\n+  describe('upgrade purchasing', () => {\n+    it('increases level and cost after purchase', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+      const initialCost = upgrades.getUpgradeCost(type);\n+\n+      upgrades.purchaseUpgrade(type, initialCost);\n+\n+      expect(upgrades.getUpgradeLevel(type)).toBe(1);\n+      expect(upgrades.getUpgradeCost(type)).toBeGreaterThan(initialCost);\n+    });\n+\n+    it('respects max level', () => {\n+      const type = UpgradeType.TurbineConductivity;\n+      const maxLevel = UPGRADE_DEFINITIONS[type].maxLevel;\n+\n+      // Purchase to max\n+      for (let i = 0; i < maxLevel; i++) {\n+        upgrades.purchaseUpgrade(type, 1e9);\n+      }\n+\n+      expect(upgrades.getUpgradeLevel(type)).toBe(maxLevel);\n+      expect(upgrades.canPurchaseUpgrade(type, 1e9)).toBe(false);\n+    });\n+\n+    it('fails without enough money', () => {\n+      const cost = upgrades.purchaseUpgrade(UpgradeType.FuelHeatOutput, 0);\n+      expect(cost).toBe(0);\n+      expect(upgrades.getUpgradeLevel(UpgradeType.FuelHeatOutput)).toBe(0);\n+    });\n+  });\n+\n+  describe('secret unlocks', () => {\n+    it('unlocks secrets when conditions are met', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 10000, demolishCount: 100, ticksAtHighHeat: 0 };\n+\n+      const unlocked = upgrades.checkSecretUnlocks(stats);\n+\n+      expect(unlocked).toContain(SecretUpgradeType.ExoticFuel);   // 1 meltdown\n+      expect(unlocked).toContain(SecretUpgradeType.Salvage);       // 100 demolishes\n+      expect(unlocked).toContain(SecretUpgradeType.Overclock);     // 10000 money\n+    });\n+\n+    it('does not re-unlock already unlocked secrets', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+\n+      const first = upgrades.checkSecretUnlocks(stats);\n+      const second = upgrades.checkSecretUnlocks(stats);\n+\n+      expect(first).toContain(SecretUpgradeType.ExoticFuel);\n+      expect(second).not.toContain(SecretUpgradeType.ExoticFuel);\n+    });\n+\n+    it('toggleable secrets auto-enable on purchase', () => {\n+      upgrades.checkSecretUnlocks({ meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 });\n+      upgrades.purchaseSecret(SecretUpgradeType.ExoticFuel, 1e6);\n+\n+      expect(upgrades.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(true);\n+\n+      upgrades.toggleSecret(SecretUpgradeType.ExoticFuel, false);\n+      expect(upgrades.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(false);\n+    });\n+  });\n+\n+  describe('serialization', () => {\n+    it('upgrade state survives round-trip', () => {\n+      upgrades.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1e6);\n+      upgrades.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1e6);\n+\n+      const state = upgrades.getUpgradeState();\n+      const restored = new UpgradeManager();\n+      restored.restoreUpgradeState(state);\n+\n+      expect(restored.getUpgradeLevel(UpgradeType.FuelHeatOutput)).toBe(2);\n+    });\n+\n+    it('secret state survives round-trip', () => {\n+      upgrades.checkSecretUnlocks({ meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 });\n+      upgrades.purchaseSecret(SecretUpgradeType.ExoticFuel, 1e6);\n+      upgrades.toggleSecret(SecretUpgradeType.ExoticFuel, false);\n+\n+      const state = upgrades.getSecretState();\n+      const restored = new UpgradeManager();\n+      restored.restoreSecretState(state);\n+\n+      expect(restored.isSecretUnlocked(SecretUpgradeType.ExoticFuel)).toBe(true);\n+      expect(restored.isSecretPurchased(SecretUpgradeType.ExoticFuel)).toBe(true);\n+      expect(restored.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(false);\n+    });\n+  });\n+\n+  describe('reactor expansion', () => {\n+    it('returns correct expansion sizes', () => {\n+      expect(upgrades.getExpansionSize(SecretUpgradeType.ReactorExpansion1)).toBe(17);\n+      expect(upgrades.getExpansionSize(SecretUpgradeType.ReactorExpansion4)).toBe(20);\n+      expect(upgrades.getExpansionSize(SecretUpgradeType.Salvage)).toBeNull();\n+    });\n+  });\n+});\ndiff --git a/src/game/UpgradeManager.ts b/src/game/UpgradeManager.ts\nnew file mode 100644\nindex 0000000..34d4ec4\n--- /dev/null\n+++ b/src/game/UpgradeManager.ts\n@@ -0,0 +1,299 @@\n+/**\n+ * UpgradeManager - Handles regular upgrades and secret upgrades\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ * This class manages upgrade purchasing, secret unlock conditions, and toggle states.\n+ */\n+\n+import {\n+  UpgradeType,\n+  UPGRADE_DEFINITIONS,\n+  SecretUpgradeType,\n+  SECRET_UPGRADE_DEFINITIONS,\n+  getUpgradeCost,\n+  getSecretUnlockProgress,\n+} from './BalanceConfig.js';\n+\n+export interface UpgradeState {\n+  levels: Record<UpgradeType, number>;\n+}\n+\n+export interface SecretState {\n+  unlocked: Record<SecretUpgradeType, boolean>;\n+  purchased: Record<SecretUpgradeType, boolean>;\n+  enabled: Record<SecretUpgradeType, boolean>;\n+}\n+\n+export interface UpgradeEvent {\n+  type: 'upgrade_purchased' | 'secret_unlocked' | 'secret_purchased';\n+  upgradeType?: UpgradeType;\n+  secretType?: SecretUpgradeType;\n+}\n+\n+export type UpgradeEventListener = (event: UpgradeEvent) => void;\n+\n+export interface UnlockStats {\n+  meltdownCount: number;\n+  filledCells: number;\n+  totalMoneyEarned: number;\n+  demolishCount: number;\n+  ticksAtHighHeat: number;\n+}\n+\n+/**\n+ * UpgradeManager handles all upgrade-related logic including:\n+ * - Regular upgrade purchasing and level tracking\n+ * - Secret upgrade unlocking, purchasing, and toggling\n+ */\n+export class UpgradeManager {\n+  private upgrades: UpgradeState;\n+  private secrets: SecretState;\n+  private eventListeners: UpgradeEventListener[] = [];\n+\n+  constructor() {\n+    this.upgrades = this.createInitialUpgradeState();\n+    this.secrets = this.createInitialSecretState();\n+  }\n+\n+  private createInitialUpgradeState(): UpgradeState {\n+    const levels: Record<UpgradeType, number> = {} as Record<UpgradeType, number>;\n+    for (const type of Object.values(UpgradeType)) {\n+      levels[type] = 0;\n+    }\n+    return { levels };\n+  }\n+\n+  private createInitialSecretState(): SecretState {\n+    const unlocked: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+    const purchased: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+    const enabled: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+\n+    for (const type of Object.values(SecretUpgradeType)) {\n+      unlocked[type] = false;\n+      purchased[type] = false;\n+      enabled[type] = false;\n+    }\n+    return { unlocked, purchased, enabled };\n+  }\n+\n+  /**\n+   * Add an event listener for upgrade events\n+   */\n+  addEventListener(listener: UpgradeEventListener): void {\n+    this.eventListeners.push(listener);\n+  }\n+\n+  /**\n+   * Remove an event listener\n+   */\n+  removeEventListener(listener: UpgradeEventListener): void {\n+    const index = this.eventListeners.indexOf(listener);\n+    if (index !== -1) {\n+      this.eventListeners.splice(index, 1);\n+    }\n+  }\n+\n+  private emitEvent(event: UpgradeEvent): void {\n+    for (const listener of this.eventListeners) {\n+      listener(event);\n+    }\n+  }\n+\n+  // ==========================================================================\n+  // REGULAR UPGRADES\n+  // ==========================================================================\n+\n+  /**\n+   * Get the current level of an upgrade\n+   */\n+  getUpgradeLevel(type: UpgradeType): number {\n+    return this.upgrades.levels[type];\n+  }\n+\n+  /**\n+   * Get the cost for the next level of an upgrade\n+   */\n+  getUpgradeCost(type: UpgradeType): number {\n+    const currentLevel = this.upgrades.levels[type];\n+    return getUpgradeCost(type, currentLevel);\n+  }\n+\n+  /**\n+   * Check if an upgrade can be purchased\n+   */\n+  canPurchaseUpgrade(type: UpgradeType, currentMoney: number): boolean {\n+    const definition = UPGRADE_DEFINITIONS[type];\n+    const currentLevel = this.upgrades.levels[type];\n+\n+    if (definition.maxLevel > 0 && currentLevel >= definition.maxLevel) {\n+      return false;\n+    }\n+\n+    const cost = getUpgradeCost(type, currentLevel);\n+    return currentMoney >= cost;\n+  }\n+\n+  /**\n+   * Purchase an upgrade\n+   * Returns the cost if successful, 0 if failed\n+   */\n+  purchaseUpgrade(type: UpgradeType, currentMoney: number): number {\n+    if (!this.canPurchaseUpgrade(type, currentMoney)) return 0;\n+\n+    const cost = getUpgradeCost(type, this.upgrades.levels[type]);\n+    this.upgrades.levels[type]++;\n+\n+    this.emitEvent({ type: 'upgrade_purchased', upgradeType: type });\n+    return cost;\n+  }\n+\n+  // ==========================================================================\n+  // SECRET UPGRADES\n+  // ==========================================================================\n+\n+  /**\n+   * Check if a secret upgrade is unlocked\n+   */\n+  isSecretUnlocked(type: SecretUpgradeType): boolean {\n+    return this.secrets.unlocked[type];\n+  }\n+\n+  /**\n+   * Check if a secret upgrade has been purchased\n+   */\n+  isSecretPurchased(type: SecretUpgradeType): boolean {\n+    return this.secrets.purchased[type];\n+  }\n+\n+  /**\n+   * Check if a toggleable secret is enabled\n+   */\n+  isSecretEnabled(type: SecretUpgradeType): boolean {\n+    return this.secrets.enabled[type];\n+  }\n+\n+  /**\n+   * Get the cost of a secret upgrade\n+   */\n+  getSecretCost(type: SecretUpgradeType): number {\n+    return SECRET_UPGRADE_DEFINITIONS[type].cost;\n+  }\n+\n+  /**\n+   * Check if a secret can be purchased\n+   */\n+  canPurchaseSecret(type: SecretUpgradeType, currentMoney: number): boolean {\n+    if (!this.secrets.unlocked[type]) return false;\n+    if (this.secrets.purchased[type]) return false;\n+\n+    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n+    return currentMoney >= cost;\n+  }\n+\n+  /**\n+   * Purchase a secret upgrade\n+   * Returns the cost if successful, 0 if failed\n+   */\n+  purchaseSecret(type: SecretUpgradeType, currentMoney: number): number {\n+    if (!this.canPurchaseSecret(type, currentMoney)) return 0;\n+\n+    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n+    this.secrets.purchased[type] = true;\n+\n+    // Auto-enable toggleable secrets\n+    if (SECRET_UPGRADE_DEFINITIONS[type].isToggle) {\n+      this.secrets.enabled[type] = true;\n+    }\n+\n+    this.emitEvent({ type: 'secret_purchased', secretType: type });\n+    return cost;\n+  }\n+\n+  /**\n+   * Toggle a secret upgrade on/off\n+   */\n+  toggleSecret(type: SecretUpgradeType, enabled: boolean): void {\n+    if (!this.secrets.purchased[type]) return;\n+    if (!SECRET_UPGRADE_DEFINITIONS[type].isToggle) return;\n+\n+    this.secrets.enabled[type] = enabled;\n+  }\n+\n+  /**\n+   * Check and unlock secrets based on current game stats\n+   * Returns array of newly unlocked secrets\n+   */\n+  checkSecretUnlocks(stats: UnlockStats): SecretUpgradeType[] {\n+    const newlyUnlocked: SecretUpgradeType[] = [];\n+\n+    for (const type of Object.values(SecretUpgradeType)) {\n+      if (this.secrets.unlocked[type]) continue;\n+\n+      const progress = getSecretUnlockProgress(type, stats);\n+      if (progress.unlocked) {\n+        this.secrets.unlocked[type] = true;\n+        newlyUnlocked.push(type);\n+        this.emitEvent({ type: 'secret_unlocked', secretType: type });\n+      }\n+    }\n+\n+    return newlyUnlocked;\n+  }\n+\n+  /**\n+   * Get the grid size expansion for a reactor expansion secret\n+   */\n+  getExpansionSize(type: SecretUpgradeType): number | null {\n+    switch (type) {\n+      case SecretUpgradeType.ReactorExpansion1: return 17;\n+      case SecretUpgradeType.ReactorExpansion2: return 18;\n+      case SecretUpgradeType.ReactorExpansion3: return 19;\n+      case SecretUpgradeType.ReactorExpansion4: return 20;\n+      default: return null;\n+    }\n+  }\n+\n+  // ==========================================================================\n+  // SERIALIZATION\n+  // ==========================================================================\n+\n+  /**\n+   * Get the current upgrade state for serialization\n+   */\n+  getUpgradeState(): UpgradeState {\n+    return {\n+      levels: { ...this.upgrades.levels },\n+    };\n+  }\n+\n+  /**\n+   * Get the current secret state for serialization\n+   */\n+  getSecretState(): SecretState {\n+    return {\n+      unlocked: { ...this.secrets.unlocked },\n+      purchased: { ...this.secrets.purchased },\n+      enabled: { ...this.secrets.enabled },\n+    };\n+  }\n+\n+  /**\n+   * Restore upgrade state from serialized data\n+   */\n+  restoreUpgradeState(state: UpgradeState): void {\n+    this.upgrades = {\n+      levels: { ...state.levels },\n+    };\n+  }\n+\n+  /**\n+   * Restore secret state from serialized data\n+   */\n+  restoreSecretState(state: SecretState): void {\n+    this.secrets = {\n+      unlocked: { ...state.unlocked },\n+      purchased: { ...state.purchased },\n+      enabled: { ...state.enabled },\n+    };\n+  }\n+}",
      "actualWorkers": 1
    },
    "preserveOutput": "always",
    "projects": [
      {
        "outputDir": "/home/runner/work/claudetest123/claudetest123/test-results",
        "repeatEach": 1,
        "retries": 2,
        "metadata": {
          "ci": {
            "commitHref": "https://github.com/bjuergens/claudetest123/commit/c6e0c9ee614dd994230d6b829c11b0b99cbbbc2b",
            "commitHash": "c6e0c9ee614dd994230d6b829c11b0b99cbbbc2b",
            "prHref": "https://github.com/bjuergens/claudetest123/pull/10",
            "prTitle": "Extract GridManager, PhysicsEngine, and UpgradeManager from HeatGame",
            "prBaseHash": "f29e01ec7cb04beabadc275fcf431907f165675e",
            "buildHref": "https://github.com/bjuergens/claudetest123/actions/runs/21544641296"
          },
          "gitCommit": {
            "shortHash": "c6e0c9e",
            "hash": "c6e0c9ee614dd994230d6b829c11b0b99cbbbc2b",
            "subject": "Merge cfb47803929dc2f495a7be3903aa6b6762e8ca87 into f29e01ec7cb04beabadc275fcf431907f165675e",
            "body": "Merge cfb47803929dc2f495a7be3903aa6b6762e8ca87 into f29e01ec7cb04beabadc275fcf431907f165675e\n",
            "author": {
              "name": "Björn Jürgens",
              "email": "4362465+bjuergens@users.noreply.github.com",
              "time": 1769863313000
            },
            "committer": {
              "name": "GitHub",
              "email": "noreply@github.com",
              "time": 1769863313000
            },
            "branch": "HEAD"
          },
          "gitDiff": "diff --git a/CLAUDE.md b/CLAUDE.md\nnew file mode 100644\nindex 0000000..0a6ee98\n--- /dev/null\n+++ b/CLAUDE.md\n@@ -0,0 +1,50 @@\n+# Project Conventions\n+\n+## Architecture\n+\n+```\n+HeatGame (orchestrator)\n+├── GridManager     - Grid state and neighbor calculations\n+├── PhysicsEngine   - Heat/power simulation\n+└── UpgradeManager  - Upgrades and secrets\n+```\n+\n+### Key Design Decisions\n+\n+1. **Shared Mutable State**: PhysicsEngine operates directly on GridManager's grid via `getGridRef()`. This assumes single-threaded execution.\n+\n+2. **Upgrade Callback**: PhysicsEngine queries upgrades via closure `(type) => upgradeManager.getUpgradeLevel(type)`. Don't purchase upgrades during physics tick.\n+\n+3. **Stats Ownership**:\n+   - Physics stats (totalPowerGenerated, ticksAtHighHeat, fuelRodsDepleted) → owned by PhysicsEngine\n+   - Game stats (meltdownCount, structuresBuilt, demolishCount) → owned by HeatGame\n+   - HeatGame syncs from PhysicsEngine after each tick\n+\n+## Testing Philosophy\n+\n+**Keep tests lean.** Only test:\n+- Data loss scenarios (serialization, grid expansion)\n+- Catastrophic behaviors (meltdowns)\n+- Complex interactions (upgrades affecting physics)\n+- Edge cases that would be hard to debug\n+\n+**Don't test:**\n+- Trivial getters/setters\n+- Type correctness (compiler handles this)\n+- Initialization defaults\n+- Event listener add/remove patterns\n+\n+## Commands\n+\n+```bash\n+npm test          # Run unit tests\n+npm run build     # TypeScript compile\n+npm run dev       # Watch mode + serve\n+```\n+\n+## Code Style\n+\n+- Use composition over inheritance\n+- Prefer explicit state sync over implicit coupling\n+- Events are for UI notification, not state management\n+- Single source of truth for each piece of state\ndiff --git a/src/game/GridManager.test.ts b/src/game/GridManager.test.ts\nnew file mode 100644\nindex 0000000..b7dac98\n--- /dev/null\n+++ b/src/game/GridManager.test.ts\n@@ -0,0 +1,93 @@\n+/**\n+ * GridManager Unit Tests\n+ *\n+ * Focus: Data integrity, grid expansion (data loss risk), neighbor calculations (core mechanic)\n+ */\n+\n+import { describe, it, expect, beforeEach } from 'vitest';\n+import { GridManager } from './GridManager.js';\n+import { StructureType } from './BalanceConfig.js';\n+\n+describe('GridManager', () => {\n+  let grid: GridManager;\n+\n+  beforeEach(() => {\n+    grid = new GridManager(16);\n+  });\n+\n+  describe('data integrity', () => {\n+    it('getCell returns copy, getCellRef returns mutable reference', () => {\n+      const copy = grid.getCell(5, 5)!;\n+      copy.heat = 999;\n+      expect(grid.getCell(5, 5)!.heat).toBe(0); // unchanged\n+\n+      const ref = grid.getCellRef(5, 5)!;\n+      ref.heat = 999;\n+      expect(grid.getCell(5, 5)!.heat).toBe(999); // changed\n+    });\n+\n+    it('expandGrid preserves existing cell data', () => {\n+      const cell = grid.getCellRef(5, 5)!;\n+      cell.structure = StructureType.FuelRod;\n+      cell.heat = 500;\n+      cell.lifetime = 42;\n+\n+      grid.expandGrid(18, 20);\n+\n+      const preserved = grid.getCell(5, 5)!;\n+      expect(preserved.structure).toBe(StructureType.FuelRod);\n+      expect(preserved.heat).toBe(500);\n+      expect(preserved.lifetime).toBe(42);\n+      expect(grid.getSize()).toBe(18);\n+    });\n+\n+    it('restoreFromState correctly restores grid', () => {\n+      const state = grid.getSnapshot();\n+      state[5][5].structure = StructureType.Turbine;\n+      state[5][5].heat = 250;\n+\n+      const newGrid = new GridManager(10);\n+      newGrid.restoreFromState(state, 16);\n+\n+      expect(newGrid.getSize()).toBe(16);\n+      expect(newGrid.getCell(5, 5)!.structure).toBe(StructureType.Turbine);\n+      expect(newGrid.getCell(5, 5)!.heat).toBe(250);\n+    });\n+  });\n+\n+  describe('neighbor calculations', () => {\n+    it('returns correct neighbor count at center/edge/corner', () => {\n+      expect(grid.getNeighbors(8, 8)).toHaveLength(4);  // center\n+      expect(grid.getNeighbors(0, 8)).toHaveLength(3);  // edge\n+      expect(grid.getNeighbors(0, 0)).toHaveLength(2);  // corner\n+    });\n+\n+    it('countAdjacentFuelRods only counts active fuel rods', () => {\n+      // Active fuel rod\n+      const active = grid.getCellRef(5, 4)!;\n+      active.structure = StructureType.FuelRod;\n+      active.lifetime = 100;\n+\n+      // Depleted fuel rod\n+      const depleted = grid.getCellRef(5, 6)!;\n+      depleted.structure = StructureType.FuelRod;\n+      depleted.lifetime = 0;\n+\n+      expect(grid.countAdjacentFuelRods(5, 5)).toBe(1);\n+    });\n+  });\n+\n+  describe('bounds checking', () => {\n+    it('returns null for out-of-bounds access', () => {\n+      expect(grid.getCell(-1, 0)).toBeNull();\n+      expect(grid.getCell(16, 0)).toBeNull();\n+      expect(grid.getCellRef(-1, 0)).toBeNull();\n+    });\n+\n+    it('rejects invalid expansions', () => {\n+      expect(grid.expandGrid(25, 20)).toBe(false); // beyond max\n+      expect(grid.expandGrid(10, 20)).toBe(false); // shrinking\n+      expect(grid.getSize()).toBe(16);\n+    });\n+  });\n+});\ndiff --git a/src/game/GridManager.ts b/src/game/GridManager.ts\nnew file mode 100644\nindex 0000000..0e158a8\n--- /dev/null\n+++ b/src/game/GridManager.ts\n@@ -0,0 +1,221 @@\n+/**\n+ * GridManager - Handles grid creation, neighbor calculations, and cell operations\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ */\n+\n+import { StructureType, Tier } from './BalanceConfig.js';\n+\n+export interface Cell {\n+  x: number;\n+  y: number;\n+  structure: StructureType;\n+  tier: Tier;\n+  heat: number;\n+  power: number;\n+  /** Remaining lifetime in ticks (fuel rods only, 0 = infinite/depleted) */\n+  lifetime: number;\n+  /** Whether this is an exotic variant (fuel rods only) */\n+  isExotic: boolean;\n+}\n+\n+export class GridManager {\n+  private grid: Cell[][];\n+  private gridSize: number;\n+\n+  constructor(initialSize: number) {\n+    this.gridSize = initialSize;\n+    this.grid = this.createEmptyGrid(initialSize);\n+  }\n+\n+  /**\n+   * Create a new empty grid of the specified size\n+   */\n+  createEmptyGrid(size: number): Cell[][] {\n+    const grid: Cell[][] = [];\n+    for (let y = 0; y < size; y++) {\n+      const row: Cell[] = [];\n+      for (let x = 0; x < size; x++) {\n+        row.push(this.createEmptyCell(x, y));\n+      }\n+      grid.push(row);\n+    }\n+    return grid;\n+  }\n+\n+  /**\n+   * Create an empty cell at the specified coordinates\n+   */\n+  createEmptyCell(x: number, y: number): Cell {\n+    return {\n+      x,\n+      y,\n+      structure: StructureType.Empty,\n+      tier: Tier.T1,\n+      heat: 0,\n+      power: 0,\n+      lifetime: 0,\n+      isExotic: false,\n+    };\n+  }\n+\n+  /**\n+   * Get a copy of a cell at the specified coordinates\n+   * Returns null if coordinates are out of bounds\n+   */\n+  getCell(x: number, y: number): Cell | null {\n+    if (!this.isValidPosition(x, y)) {\n+      return null;\n+    }\n+    return { ...this.grid[y][x] };\n+  }\n+\n+  /**\n+   * Get a direct reference to a cell (for mutation)\n+   * Returns null if coordinates are out of bounds\n+   */\n+  getCellRef(x: number, y: number): Cell | null {\n+    if (!this.isValidPosition(x, y)) {\n+      return null;\n+    }\n+    return this.grid[y][x];\n+  }\n+\n+  /**\n+   * Check if coordinates are within grid bounds\n+   */\n+  isValidPosition(x: number, y: number): boolean {\n+    return x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize;\n+  }\n+\n+  /**\n+   * Get the current grid size\n+   */\n+  getSize(): number {\n+    return this.gridSize;\n+  }\n+\n+  /**\n+   * Get a snapshot (deep copy) of the entire grid\n+   */\n+  getSnapshot(): Cell[][] {\n+    return this.grid.map(row => row.map(cell => ({ ...cell })));\n+  }\n+\n+  /**\n+   * Get the internal grid reference (for physics engine)\n+   */\n+  getGridRef(): Cell[][] {\n+    return this.grid;\n+  }\n+\n+  /**\n+   * Get orthogonal neighbors (up, down, left, right) of a cell\n+   */\n+  getNeighbors(x: number, y: number): Cell[] {\n+    const neighbors: Cell[] = [];\n+    const directions = [\n+      { dx: 0, dy: -1 }, // up\n+      { dx: 0, dy: 1 },  // down\n+      { dx: -1, dy: 0 }, // left\n+      { dx: 1, dy: 0 },  // right\n+    ];\n+\n+    for (const { dx, dy } of directions) {\n+      const nx = x + dx;\n+      const ny = y + dy;\n+      if (this.isValidPosition(nx, ny)) {\n+        neighbors.push(this.grid[ny][nx]);\n+      }\n+    }\n+\n+    return neighbors;\n+  }\n+\n+  /**\n+   * Count active (non-depleted) fuel rods adjacent to a position\n+   */\n+  countAdjacentFuelRods(x: number, y: number): number {\n+    const neighbors = this.getNeighbors(x, y);\n+    return neighbors.filter(n => n.structure === StructureType.FuelRod && n.lifetime > 0).length;\n+  }\n+\n+  /**\n+   * Count filled (non-empty) cells in the grid\n+   */\n+  getFilledCellCount(): number {\n+    let count = 0;\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        if (this.grid[y][x].structure !== StructureType.Empty) {\n+          count++;\n+        }\n+      }\n+    }\n+    return count;\n+  }\n+\n+  /**\n+   * Expand the grid to a new size, preserving existing cells\n+   * Returns true if expansion was successful\n+   */\n+  expandGrid(newSize: number, maxSize: number): boolean {\n+    if (newSize <= this.gridSize) return false;\n+    if (newSize > maxSize) return false;\n+\n+    const oldGrid = this.grid;\n+    const oldSize = this.gridSize;\n+\n+    // Create new larger grid\n+    this.grid = this.createEmptyGrid(newSize);\n+    this.gridSize = newSize;\n+\n+    // Copy old grid data\n+    for (let y = 0; y < oldSize; y++) {\n+      for (let x = 0; x < oldSize; x++) {\n+        this.grid[y][x] = { ...oldGrid[y][x] };\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Reset a cell to empty state\n+   */\n+  resetCell(x: number, y: number): void {\n+    if (this.isValidPosition(x, y)) {\n+      this.grid[y][x] = this.createEmptyCell(x, y);\n+    }\n+  }\n+\n+  /**\n+   * Clear all cells in the grid (reset to empty)\n+   */\n+  clearAll(): void {\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        this.grid[y][x] = this.createEmptyCell(x, y);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Iterate over all cells, calling the callback for each\n+   */\n+  forEach(callback: (cell: Cell, x: number, y: number) => void): void {\n+    for (let y = 0; y < this.gridSize; y++) {\n+      for (let x = 0; x < this.gridSize; x++) {\n+        callback(this.grid[y][x], x, y);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Restore grid state from serialized data\n+   */\n+  restoreFromState(grid: Cell[][], gridSize: number): void {\n+    this.gridSize = gridSize;\n+    this.grid = grid.map(row => row.map(cell => ({ ...cell })));\n+  }\n+}\ndiff --git a/src/game/HeatGame.ts b/src/game/HeatGame.ts\nindex 24971dc..eeca20d 100644\n--- a/src/game/HeatGame.ts\n+++ b/src/game/HeatGame.ts\n@@ -1,15 +1,10 @@\n /**\n  * Heat Management Game - Core Game Logic\n  *\n- * Refactored to support:\n- * - Tiered items (T1-T4)\n- * - Fuel rod lifetime and depletion\n- * - Adjacency heat bonus for fuel rods\n- * - Manual power generation (clicker)\n- * - Upgrade system (regular + secret)\n- * - Exotic fuel rods\n- * - Dynamic grid size (16x16 to 20x20)\n- * - Variable melt temperatures and conductivity\n+ * Refactored to use composed classes for better separation of concerns:\n+ * - GridManager: Grid creation and cell operations\n+ * - PhysicsEngine: Heat/power simulation\n+ * - UpgradeManager: Upgrade and secret management\n  */\n \n import {\n@@ -18,46 +13,28 @@ import {\n   Tier,\n   StructureType,\n   STRUCTURE_BASE_STATS,\n-  FUEL_ADJACENCY,\n-  ECONOMY,\n   UpgradeType,\n-  UPGRADE_DEFINITIONS,\n   SecretUpgradeType,\n   SECRET_UPGRADE_DEFINITIONS,\n-  EXOTIC_FUEL,\n   getStructureCost,\n   getFuelLifetime,\n-  getFuelHeatGeneration,\n-  getUpgradeCost,\n-  getSecretUnlockProgress,\n } from './BalanceConfig.js';\n \n+import { GridManager, Cell } from './GridManager.js';\n+import { PhysicsEngine, PhysicsEvent } from './PhysicsEngine.js';\n+import { UpgradeManager, UpgradeEvent } from './UpgradeManager.js';\n+\n // Re-export types for backward compatibility\n export { StructureType, Tier, UpgradeType, SecretUpgradeType };\n-\n-export interface Cell {\n-  x: number;\n-  y: number;\n-  structure: StructureType;\n-  tier: Tier;\n-  heat: number;\n-  power: number;\n-  /** Remaining lifetime in ticks (fuel rods only, 0 = infinite/depleted) */\n-  lifetime: number;\n-  /** Whether this is an exotic variant (fuel rods only) */\n-  isExotic: boolean;\n-}\n+export { Cell };\n \n export interface UpgradeState {\n   levels: Record<UpgradeType, number>;\n }\n \n export interface SecretState {\n-  /** Whether the unlock condition has been met */\n   unlocked: Record<SecretUpgradeType, boolean>;\n-  /** Whether the upgrade has been purchased */\n   purchased: Record<SecretUpgradeType, boolean>;\n-  /** Toggle state for toggleable secrets */\n   enabled: Record<SecretUpgradeType, boolean>;\n }\n \n@@ -107,87 +84,101 @@ export interface GameEvent {\n \n export type GameEventListener = (event: GameEvent) => void;\n \n-// Helper to create initial upgrade state\n-function createInitialUpgradeState(): UpgradeState {\n-  const levels: Record<UpgradeType, number> = {} as Record<UpgradeType, number>;\n-  for (const type of Object.values(UpgradeType)) {\n-    levels[type] = 0;\n-  }\n-  return { levels };\n-}\n-\n-// Helper to create initial secret state\n-function createInitialSecretState(): SecretState {\n-  const unlocked: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n-  const purchased: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n-  const enabled: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n-\n-  for (const type of Object.values(SecretUpgradeType)) {\n-    unlocked[type] = false;\n-    purchased[type] = false;\n-    enabled[type] = false;\n-  }\n-  return { unlocked, purchased, enabled };\n-}\n-\n+/**\n+ * HeatGame - Main game orchestrator\n+ *\n+ * Composes GridManager, PhysicsEngine, and UpgradeManager to coordinate\n+ * game logic while delegating specific responsibilities to each component.\n+ */\n export class HeatGame {\n-  private state: GameState;\n+  private gridManager: GridManager;\n+  private physicsEngine: PhysicsEngine;\n+  private upgradeManager: UpgradeManager;\n+\n+  private money: number;\n+  private stats: GameStats;\n   private eventListeners: GameEventListener[] = [];\n \n   constructor(initialMoney: number = CORE_SETTINGS.STARTING_MONEY) {\n-    this.state = this.createInitialState(initialMoney);\n-  }\n+    // Initialize composed components\n+    this.gridManager = new GridManager(CORE_SETTINGS.INITIAL_GRID_SIZE);\n+    this.upgradeManager = new UpgradeManager();\n+    this.physicsEngine = new PhysicsEngine(\n+      this.gridManager,\n+      (type: UpgradeType) => this.upgradeManager.getUpgradeLevel(type)\n+    );\n+\n+    this.money = initialMoney;\n+    this.stats = this.createInitialStats();\n \n-  private createInitialState(initialMoney: number): GameState {\n-    const gridSize = CORE_SETTINGS.INITIAL_GRID_SIZE;\n-    const grid = this.createEmptyGrid(gridSize);\n+    // Wire up event forwarding from sub-components\n+    this.setupEventForwarding();\n+  }\n \n+  private createInitialStats(): GameStats {\n     return {\n-      grid,\n-      gridSize,\n-      money: initialMoney,\n-      stats: {\n-        totalPowerGenerated: 0,\n-        totalMoneyEarned: 0,\n-        meltdownCount: 0,\n-        tickCount: 0,\n-        demolishCount: 0,\n-        ticksAtHighHeat: 0,\n-        manualClicks: 0,\n-        structuresBuilt: 0,\n-        fuelRodsDepleted: 0,\n-      },\n-      upgrades: createInitialUpgradeState(),\n-      secrets: createInitialSecretState(),\n+      totalPowerGenerated: 0,\n+      totalMoneyEarned: 0,\n+      meltdownCount: 0,\n+      tickCount: 0,\n+      demolishCount: 0,\n+      ticksAtHighHeat: 0,\n+      manualClicks: 0,\n+      structuresBuilt: 0,\n+      fuelRodsDepleted: 0,\n     };\n   }\n \n-  private createEmptyGrid(size: number): Cell[][] {\n-    const grid: Cell[][] = [];\n-    for (let y = 0; y < size; y++) {\n-      const row: Cell[] = [];\n-      for (let x = 0; x < size; x++) {\n-        row.push(this.createEmptyCell(x, y));\n+  private setupEventForwarding(): void {\n+    // Forward physics events\n+    // Note: Stats are tracked in PhysicsEngine, we only forward events here\n+    this.physicsEngine.addEventListener((event: PhysicsEvent) => {\n+      if (event.type === 'fuel_depleted') {\n+        // Don't increment here - PhysicsEngine already tracks this stat\n+        this.emitEvent({\n+          type: 'fuel_depleted',\n+          x: event.x,\n+          y: event.y,\n+          tier: event.tier,\n+        });\n+      } else if (event.type === 'power_sold') {\n+        this.emitEvent({\n+          type: 'power_sold',\n+          x: event.x,\n+          y: event.y,\n+          amount: event.amount,\n+        });\n+      } else if (event.type === 'structure_melted') {\n+        this.emitEvent({\n+          type: 'structure_melted',\n+          x: event.x,\n+          y: event.y,\n+          structure: event.structure,\n+          tier: event.tier,\n+        });\n+      } else if (event.type === 'meltdown') {\n+        this.stats.meltdownCount++;\n+        this.emitEvent({ type: 'meltdown' });\n+        this.checkSecretUnlocks();\n       }\n-      grid.push(row);\n-    }\n-    return grid;\n-  }\n+    });\n \n-  private createEmptyCell(x: number, y: number): Cell {\n-    return {\n-      x,\n-      y,\n-      structure: StructureType.Empty,\n-      tier: Tier.T1,\n-      heat: 0,\n-      power: 0,\n-      lifetime: 0,\n-      isExotic: false,\n-    };\n+    // Forward upgrade events\n+    this.upgradeManager.addEventListener((event: UpgradeEvent) => {\n+      if (event.type === 'upgrade_purchased') {\n+        this.emitEvent({ type: 'upgrade_purchased', upgradeType: event.upgradeType });\n+      } else if (event.type === 'secret_unlocked') {\n+        this.emitEvent({ type: 'secret_unlocked', secretType: event.secretType });\n+      } else if (event.type === 'secret_purchased') {\n+        this.emitEvent({ type: 'secret_purchased', secretType: event.secretType });\n+      }\n+    });\n   }\n \n-  // Event system\n+  // ==========================================================================\n+  // EVENT SYSTEM\n+  // ==========================================================================\n+\n   addEventListener(listener: GameEventListener): void {\n     this.eventListeners.push(listener);\n   }\n@@ -206,74 +197,63 @@ export class HeatGame {\n   }\n \n   // ==========================================================================\n-  // GETTERS\n+  // GETTERS (delegate to sub-components)\n   // ==========================================================================\n \n   getCell(x: number, y: number): Cell | null {\n-    if (x < 0 || x >= this.state.gridSize || y < 0 || y >= this.state.gridSize) {\n-      return null;\n-    }\n-    return { ...this.state.grid[y][x] };\n+    return this.gridManager.getCell(x, y);\n   }\n \n   getGridSize(): number {\n-    return this.state.gridSize;\n+    return this.gridManager.getSize();\n   }\n \n   getMoney(): number {\n-    return this.state.money;\n+    return this.money;\n   }\n \n   getTickCount(): number {\n-    return this.state.stats.tickCount;\n+    return this.stats.tickCount;\n   }\n \n   getMeltdownCount(): number {\n-    return this.state.stats.meltdownCount;\n+    return this.stats.meltdownCount;\n   }\n \n   getTotalPowerGenerated(): number {\n-    return this.state.stats.totalPowerGenerated;\n+    return this.stats.totalPowerGenerated;\n   }\n \n   getTotalMoneyEarned(): number {\n-    return this.state.stats.totalMoneyEarned;\n+    return this.stats.totalMoneyEarned;\n   }\n \n   getStats(): GameStats {\n-    return { ...this.state.stats };\n+    return { ...this.stats };\n   }\n \n   getUpgradeLevel(type: UpgradeType): number {\n-    return this.state.upgrades.levels[type];\n+    return this.upgradeManager.getUpgradeLevel(type);\n   }\n \n   isSecretUnlocked(type: SecretUpgradeType): boolean {\n-    return this.state.secrets.unlocked[type];\n+    return this.upgradeManager.isSecretUnlocked(type);\n   }\n \n   isSecretPurchased(type: SecretUpgradeType): boolean {\n-    return this.state.secrets.purchased[type];\n+    return this.upgradeManager.isSecretPurchased(type);\n   }\n \n   isSecretEnabled(type: SecretUpgradeType): boolean {\n-    return this.state.secrets.enabled[type];\n+    return this.upgradeManager.isSecretEnabled(type);\n   }\n \n   getGridSnapshot(): Cell[][] {\n-    return this.state.grid.map(row => row.map(cell => ({ ...cell })));\n+    return this.gridManager.getSnapshot();\n   }\n \n   getFilledCellCount(): number {\n-    let count = 0;\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        if (this.state.grid[y][x].structure !== StructureType.Empty) {\n-          count++;\n-        }\n-      }\n-    }\n-    return count;\n+    return this.gridManager.getFilledCellCount();\n   }\n \n   // ==========================================================================\n@@ -281,13 +261,13 @@ export class HeatGame {\n   // ==========================================================================\n \n   manualGenerate(): number {\n-    const upgradeLevel = this.state.upgrades.levels[UpgradeType.ManualClickPower];\n+    const upgradeLevel = this.upgradeManager.getUpgradeLevel(UpgradeType.ManualClickPower);\n     const moneyEarned = MANUAL_GENERATION.BASE_MONEY_PER_CLICK +\n       (upgradeLevel * MANUAL_GENERATION.MONEY_PER_LEVEL);\n \n-    this.state.money += moneyEarned;\n-    this.state.stats.totalMoneyEarned += moneyEarned;\n-    this.state.stats.manualClicks++;\n+    this.money += moneyEarned;\n+    this.stats.totalMoneyEarned += moneyEarned;\n+    this.stats.manualClicks++;\n \n     this.emitEvent({ type: 'manual_click', amount: moneyEarned });\n     return moneyEarned;\n@@ -302,20 +282,21 @@ export class HeatGame {\n   }\n \n   canBuild(x: number, y: number, structure: StructureType, tier: Tier = Tier.T1): boolean {\n-    const cell = this.getCell(x, y);\n+    const cell = this.gridManager.getCell(x, y);\n     if (!cell) return false;\n     if (cell.structure !== StructureType.Empty) return false;\n \n     // Check if structure is secret and not unlocked\n     const baseStats = STRUCTURE_BASE_STATS[structure];\n     if (baseStats.isSecret) {\n-      if (structure === StructureType.VoidCell && !this.state.secrets.purchased[SecretUpgradeType.VoidCellUnlock]) {\n+      if (structure === StructureType.VoidCell &&\n+          !this.upgradeManager.isSecretPurchased(SecretUpgradeType.VoidCellUnlock)) {\n         return false;\n       }\n     }\n \n     const cost = getStructureCost(structure, tier);\n-    return this.state.money >= cost;\n+    return this.money >= cost;\n   }\n \n   build(x: number, y: number, structure: StructureType, tier: Tier = Tier.T1, isExotic: boolean = false): boolean {\n@@ -323,16 +304,16 @@ export class HeatGame {\n \n     // Exotic fuel requires the secret to be purchased and enabled\n     if (isExotic && structure === StructureType.FuelRod) {\n-      if (!this.state.secrets.purchased[SecretUpgradeType.ExoticFuel] ||\n-          !this.state.secrets.enabled[SecretUpgradeType.ExoticFuel]) {\n+      if (!this.upgradeManager.isSecretPurchased(SecretUpgradeType.ExoticFuel) ||\n+          !this.upgradeManager.isSecretEnabled(SecretUpgradeType.ExoticFuel)) {\n         isExotic = false;\n       }\n     }\n \n     const cost = getStructureCost(structure, tier);\n-    this.state.money -= cost;\n+    this.money -= cost;\n \n-    const cell = this.state.grid[y][x];\n+    const cell = this.gridManager.getCellRef(x, y)!;\n     cell.structure = structure;\n     cell.tier = tier;\n     cell.heat = 0;\n@@ -341,13 +322,13 @@ export class HeatGame {\n \n     // Set lifetime for fuel rods\n     if (structure === StructureType.FuelRod) {\n-      const upgradeLevel = this.state.upgrades.levels[UpgradeType.FuelLifetime];\n+      const upgradeLevel = this.upgradeManager.getUpgradeLevel(UpgradeType.FuelLifetime);\n       cell.lifetime = getFuelLifetime(tier, upgradeLevel);\n     } else {\n       cell.lifetime = 0;\n     }\n \n-    this.state.stats.structuresBuilt++;\n+    this.stats.structuresBuilt++;\n \n     this.emitEvent({\n       type: 'structure_built',\n@@ -357,28 +338,25 @@ export class HeatGame {\n       tier,\n     });\n \n-    // Check for secret unlocks\n     this.checkSecretUnlocks();\n-\n     return true;\n   }\n \n   demolish(x: number, y: number): boolean {\n-    const cell = this.getCell(x, y);\n+    const cell = this.gridManager.getCell(x, y);\n     if (!cell || cell.structure === StructureType.Empty) return false;\n \n-    const oldStructure = this.state.grid[y][x].structure;\n-    const oldTier = this.state.grid[y][x].tier;\n+    const oldStructure = cell.structure;\n+    const oldTier = cell.tier;\n \n     // Refund if salvage is unlocked\n-    if (this.state.secrets.purchased[SecretUpgradeType.Salvage]) {\n+    if (this.upgradeManager.isSecretPurchased(SecretUpgradeType.Salvage)) {\n       const refund = Math.floor(getStructureCost(oldStructure, oldTier) * 0.5);\n-      this.state.money += refund;\n+      this.money += refund;\n     }\n \n-    // Reset cell\n-    this.state.grid[y][x] = this.createEmptyCell(x, y);\n-    this.state.stats.demolishCount++;\n+    this.gridManager.resetCell(x, y);\n+    this.stats.demolishCount++;\n \n     this.emitEvent({\n       type: 'structure_destroyed',\n@@ -388,558 +366,157 @@ export class HeatGame {\n       tier: oldTier,\n     });\n \n-    // Check for salvage unlock\n     this.checkSecretUnlocks();\n-\n     return true;\n   }\n \n   // ==========================================================================\n-  // UPGRADES\n+  // UPGRADES (delegate to UpgradeManager)\n   // ==========================================================================\n \n   getUpgradeCost(type: UpgradeType): number {\n-    const currentLevel = this.state.upgrades.levels[type];\n-    return getUpgradeCost(type, currentLevel);\n+    return this.upgradeManager.getUpgradeCost(type);\n   }\n \n   canPurchaseUpgrade(type: UpgradeType): boolean {\n-    const definition = UPGRADE_DEFINITIONS[type];\n-    const currentLevel = this.state.upgrades.levels[type];\n-\n-    // Check max level\n-    if (definition.maxLevel > 0 && currentLevel >= definition.maxLevel) {\n-      return false;\n-    }\n-\n-    const cost = getUpgradeCost(type, currentLevel);\n-    return this.state.money >= cost;\n+    return this.upgradeManager.canPurchaseUpgrade(type, this.money);\n   }\n \n   purchaseUpgrade(type: UpgradeType): boolean {\n-    if (!this.canPurchaseUpgrade(type)) return false;\n-\n-    const cost = getUpgradeCost(type, this.state.upgrades.levels[type]);\n-    this.state.money -= cost;\n-    this.state.upgrades.levels[type]++;\n-\n-    this.emitEvent({ type: 'upgrade_purchased', upgradeType: type });\n-    return true;\n+    const cost = this.upgradeManager.purchaseUpgrade(type, this.money);\n+    if (cost > 0) {\n+      this.money -= cost;\n+      return true;\n+    }\n+    return false;\n   }\n \n   // ==========================================================================\n-  // SECRET UPGRADES\n+  // SECRET UPGRADES (delegate to UpgradeManager)\n   // ==========================================================================\n \n   getSecretCost(type: SecretUpgradeType): number {\n-    return SECRET_UPGRADE_DEFINITIONS[type].cost;\n+    return this.upgradeManager.getSecretCost(type);\n   }\n \n   canPurchaseSecret(type: SecretUpgradeType): boolean {\n-    if (!this.state.secrets.unlocked[type]) return false;\n-    if (this.state.secrets.purchased[type]) return false;\n-\n-    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n-    return this.state.money >= cost;\n+    return this.upgradeManager.canPurchaseSecret(type, this.money);\n   }\n \n   purchaseSecret(type: SecretUpgradeType): boolean {\n-    if (!this.canPurchaseSecret(type)) return false;\n-\n-    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n-    this.state.money -= cost;\n-    this.state.secrets.purchased[type] = true;\n-\n-    // Auto-enable toggleable secrets\n-    if (SECRET_UPGRADE_DEFINITIONS[type].isToggle) {\n-      this.state.secrets.enabled[type] = true;\n-    }\n+    const cost = this.upgradeManager.purchaseSecret(type, this.money);\n+    if (cost > 0) {\n+      this.money -= cost;\n+\n+      // Handle reactor expansion\n+      const expansionSize = this.upgradeManager.getExpansionSize(type);\n+      if (expansionSize !== null) {\n+        this.expandGrid(expansionSize);\n+      }\n \n-    // Handle reactor expansion\n-    if (type === SecretUpgradeType.ReactorExpansion1) {\n-      this.expandGrid(17);\n-    } else if (type === SecretUpgradeType.ReactorExpansion2) {\n-      this.expandGrid(18);\n-    } else if (type === SecretUpgradeType.ReactorExpansion3) {\n-      this.expandGrid(19);\n-    } else if (type === SecretUpgradeType.ReactorExpansion4) {\n-      this.expandGrid(20);\n+      return true;\n     }\n-\n-    this.emitEvent({ type: 'secret_purchased', secretType: type });\n-    return true;\n+    return false;\n   }\n \n   toggleSecret(type: SecretUpgradeType, enabled: boolean): void {\n-    if (!this.state.secrets.purchased[type]) return;\n-    if (!SECRET_UPGRADE_DEFINITIONS[type].isToggle) return;\n-\n-    this.state.secrets.enabled[type] = enabled;\n+    this.upgradeManager.toggleSecret(type, enabled);\n   }\n \n   private expandGrid(newSize: number): void {\n-    if (newSize <= this.state.gridSize) return;\n-    if (newSize > CORE_SETTINGS.MAX_GRID_SIZE) return;\n-\n-    const oldGrid = this.state.grid;\n-    const oldSize = this.state.gridSize;\n-\n-    // Create new larger grid\n-    this.state.grid = this.createEmptyGrid(newSize);\n-    this.state.gridSize = newSize;\n-\n-    // Copy old grid data\n-    for (let y = 0; y < oldSize; y++) {\n-      for (let x = 0; x < oldSize; x++) {\n-        this.state.grid[y][x] = { ...oldGrid[y][x] };\n-      }\n+    if (this.gridManager.expandGrid(newSize, CORE_SETTINGS.MAX_GRID_SIZE)) {\n+      this.emitEvent({ type: 'grid_expanded', newGridSize: newSize });\n     }\n-\n-    this.emitEvent({ type: 'grid_expanded', newGridSize: newSize });\n   }\n \n   private checkSecretUnlocks(): void {\n     const stats = {\n-      meltdownCount: this.state.stats.meltdownCount,\n-      filledCells: this.getFilledCellCount(),\n-      totalMoneyEarned: this.state.stats.totalMoneyEarned,\n-      demolishCount: this.state.stats.demolishCount,\n-      ticksAtHighHeat: this.state.stats.ticksAtHighHeat,\n+      meltdownCount: this.stats.meltdownCount,\n+      filledCells: this.gridManager.getFilledCellCount(),\n+      totalMoneyEarned: this.stats.totalMoneyEarned,\n+      demolishCount: this.stats.demolishCount,\n+      ticksAtHighHeat: this.stats.ticksAtHighHeat,\n     };\n \n-    for (const type of Object.values(SecretUpgradeType)) {\n-      if (this.state.secrets.unlocked[type]) continue;\n-\n-      const progress = getSecretUnlockProgress(type, stats);\n-      if (progress.unlocked) {\n-        this.state.secrets.unlocked[type] = true;\n-        this.emitEvent({ type: 'secret_unlocked', secretType: type });\n-      }\n-    }\n-  }\n-\n-  // ==========================================================================\n-  // NEIGHBORS\n-  // ==========================================================================\n-\n-  private getNeighbors(x: number, y: number): Cell[] {\n-    const neighbors: Cell[] = [];\n-    const directions = [\n-      { dx: 0, dy: -1 }, // up\n-      { dx: 0, dy: 1 },  // down\n-      { dx: -1, dy: 0 }, // left\n-      { dx: 1, dy: 0 },  // right\n-    ];\n-\n-    for (const { dx, dy } of directions) {\n-      const nx = x + dx;\n-      const ny = y + dy;\n-      if (nx >= 0 && nx < this.state.gridSize && ny >= 0 && ny < this.state.gridSize) {\n-        neighbors.push(this.state.grid[ny][nx]);\n-      }\n-    }\n-\n-    return neighbors;\n-  }\n-\n-  private countAdjacentFuelRods(x: number, y: number): number {\n-    const neighbors = this.getNeighbors(x, y);\n-    return neighbors.filter(n => n.structure === StructureType.FuelRod && n.lifetime > 0).length;\n-  }\n-\n-  // ==========================================================================\n-  // EFFECTIVE STATS (with upgrades)\n-  // ==========================================================================\n-\n-  private getEffectiveMeltTemp(structure: StructureType): number {\n-    const baseTemp = STRUCTURE_BASE_STATS[structure].meltTemp;\n-\n-    // Get the appropriate melt temp upgrade\n-    let upgradeType: UpgradeType | null = null;\n-    switch (structure) {\n-      case StructureType.FuelRod: upgradeType = UpgradeType.MeltTempFuelRod; break;\n-      case StructureType.Ventilator: upgradeType = UpgradeType.MeltTempVentilator; break;\n-      case StructureType.HeatExchanger: upgradeType = UpgradeType.MeltTempHeatExchanger; break;\n-      case StructureType.Insulator: upgradeType = UpgradeType.MeltTempInsulator; break;\n-      case StructureType.Turbine: upgradeType = UpgradeType.MeltTempTurbine; break;\n-      case StructureType.Substation: upgradeType = UpgradeType.MeltTempSubstation; break;\n-    }\n-\n-    if (upgradeType) {\n-      const level = this.state.upgrades.levels[upgradeType];\n-      const definition = UPGRADE_DEFINITIONS[upgradeType];\n-      return baseTemp + (level * definition.improvementPerLevel);\n-    }\n-\n-    return baseTemp;\n-  }\n-\n-  private getEffectiveConductivity(cell: Cell): number {\n-    const baseConductivity = STRUCTURE_BASE_STATS[cell.structure].conductivity;\n-\n-    if (cell.structure === StructureType.Turbine) {\n-      const level = this.state.upgrades.levels[UpgradeType.TurbineConductivity];\n-      const definition = UPGRADE_DEFINITIONS[UpgradeType.TurbineConductivity];\n-      return baseConductivity + (level * definition.improvementPerLevel);\n-    }\n-\n-    if (cell.structure === StructureType.Insulator) {\n-      const level = this.state.upgrades.levels[UpgradeType.InsulatorConductivity];\n-      if (level > 0) {\n-        // Multiplicative reduction\n-        return baseConductivity * Math.pow(0.5, level);\n-      }\n-    }\n-\n-    return baseConductivity;\n-  }\n-\n-  private getEffectiveHeatDissipation(cell: Cell): number {\n-    if (cell.structure !== StructureType.Ventilator && cell.structure !== StructureType.VoidCell) {\n-      return 0;\n-    }\n-\n-    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n-    let dissipation = baseStats.heatDissipation;\n-\n-    // Scale with tier for ventilators\n-    if (cell.structure === StructureType.Ventilator) {\n-      dissipation *= Math.pow(10, cell.tier - 1);\n-\n-      // Add upgrade bonus\n-      const level = this.state.upgrades.levels[UpgradeType.VentilatorDissipation];\n-      const definition = UPGRADE_DEFINITIONS[UpgradeType.VentilatorDissipation];\n-      dissipation += level * definition.improvementPerLevel;\n-    }\n-\n-    return dissipation;\n-  }\n-\n-  private getEffectivePowerSaleRate(cell: Cell): number {\n-    if (cell.structure !== StructureType.Substation) return 0;\n-\n-    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n-    let saleRate = baseStats.powerSaleRate;\n-\n-    // Scale with tier\n-    saleRate *= Math.pow(10, cell.tier - 1);\n-\n-    // Add upgrade bonus\n-    const level = this.state.upgrades.levels[UpgradeType.SubstationSaleRate];\n-    const definition = UPGRADE_DEFINITIONS[UpgradeType.SubstationSaleRate];\n-    saleRate += level * definition.improvementPerLevel;\n-\n-    return saleRate;\n+    this.upgradeManager.checkSecretUnlocks(stats);\n   }\n \n   // ==========================================================================\n-  // GAME TICK\n+  // GAME TICK (delegate to PhysicsEngine)\n   // ==========================================================================\n \n   tick(): void {\n-    this.state.stats.tickCount++;\n+    this.stats.tickCount++;\n \n-    // Phase 1: Heat generation (fuel rods with adjacency bonus)\n-    this.processHeatGeneration();\n+    // Run physics simulation\n+    const result = this.physicsEngine.tick();\n \n-    // Phase 2: Fuel depletion\n-    this.processFuelDepletion();\n+    // Sync stats from physics engine (single source of truth for physics-related stats)\n+    const physicsStats = this.physicsEngine.getStats();\n+    this.stats.totalPowerGenerated = physicsStats.totalPowerGenerated;\n+    this.stats.ticksAtHighHeat = physicsStats.ticksAtHighHeat;\n+    this.stats.fuelRodsDepleted = physicsStats.fuelRodsDepleted;\n \n-    // Phase 3: Heat transfer between cells\n-    this.processHeatTransfer();\n+    // Add money earned from power sales\n+    this.money += result.moneyEarned;\n+    this.stats.totalMoneyEarned += result.moneyEarned;\n \n-    // Phase 4: Heat dissipation (ventilators)\n-    this.processHeatDissipation();\n-\n-    // Phase 5: Power generation (turbines)\n-    this.processPowerGeneration();\n-\n-    // Phase 6: Power collection and sale (substations)\n-    this.processPowerSale();\n-\n-    // Phase 7: Check for overheating and meltdowns\n-    this.processOverheating();\n-\n-    // Phase 8: Track high heat survival\n-    this.trackHighHeatSurvival();\n-\n-    // Phase 9: Check secret unlocks\n+    // Check secret unlocks\n     this.checkSecretUnlocks();\n   }\n \n-  private processHeatGeneration(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-\n-        if (cell.structure !== StructureType.FuelRod) continue;\n-        if (cell.lifetime <= 0) continue; // Depleted fuel generates no heat\n-\n-        // Get base heat generation for this tier\n-        const upgradeLevel = this.state.upgrades.levels[UpgradeType.FuelHeatOutput];\n-        let heatGeneration = getFuelHeatGeneration(cell.tier, upgradeLevel);\n-\n-        // Adjacency bonus (4-way orthogonal)\n-        const adjacentFuelRods = this.countAdjacentFuelRods(x, y);\n-        const adjacencyMultiplier = 1 + (adjacentFuelRods * FUEL_ADJACENCY.BONUS_PER_ADJACENT);\n-        heatGeneration *= adjacencyMultiplier;\n-\n-        // Exotic fuel: heat scales with current temperature\n-        if (cell.isExotic) {\n-          const tempMultiplier = Math.min(\n-            EXOTIC_FUEL.MAX_MULTIPLIER,\n-            EXOTIC_FUEL.BASE_MULTIPLIER + (cell.heat / 1000) * EXOTIC_FUEL.HEAT_SCALING\n-          );\n-          heatGeneration *= tempMultiplier;\n-        }\n-\n-        cell.heat += heatGeneration;\n-      }\n-    }\n-  }\n-\n-  private processFuelDepletion(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-\n-        if (cell.structure !== StructureType.FuelRod) continue;\n-        if (cell.lifetime <= 0) continue;\n-\n-        cell.lifetime--;\n-\n-        if (cell.lifetime <= 0) {\n-          this.state.stats.fuelRodsDepleted++;\n-          this.emitEvent({\n-            type: 'fuel_depleted',\n-            x,\n-            y,\n-            tier: cell.tier,\n-          });\n-        }\n-      }\n-    }\n-  }\n-\n-  private processHeatTransfer(): void {\n-    const heatDeltas: number[][] = [];\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      heatDeltas.push(new Array(this.state.gridSize).fill(0));\n-    }\n-\n-    const transferRate = CORE_SETTINGS.BASE_HEAT_TRANSFER_RATE;\n-\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        const cellConductivity = this.getEffectiveConductivity(cell);\n-        const neighbors = this.getNeighbors(x, y);\n-\n-        for (const neighbor of neighbors) {\n-          const neighborConductivity = this.getEffectiveConductivity(neighbor);\n-          const heatDiff = cell.heat - neighbor.heat;\n-\n-          // Heat flows from hot to cold\n-          if (heatDiff > 0) {\n-            const conductivity = Math.min(cellConductivity, neighborConductivity);\n-            const transfer = heatDiff * transferRate * conductivity;\n-            heatDeltas[y][x] -= transfer;\n-            heatDeltas[neighbor.y][neighbor.x] += transfer;\n-          }\n-        }\n-\n-        // Edge cells lose heat to environment\n-        const edgeCount = 4 - neighbors.length;\n-        if (edgeCount > 0 && cell.heat > CORE_SETTINGS.AMBIENT_TEMPERATURE) {\n-          const heatAboveAmbient = cell.heat - CORE_SETTINGS.AMBIENT_TEMPERATURE;\n-          const envTransfer = heatAboveAmbient * CORE_SETTINGS.ENVIRONMENT_HEAT_TRANSFER_RATE * edgeCount;\n-          heatDeltas[y][x] -= envTransfer;\n-        }\n-      }\n-    }\n-\n-    // Apply deltas\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        this.state.grid[y][x].heat = Math.max(0, this.state.grid[y][x].heat + heatDeltas[y][x]);\n-      }\n-    }\n-  }\n-\n-  private processHeatDissipation(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        const dissipation = this.getEffectiveHeatDissipation(cell);\n-        cell.heat = Math.max(0, cell.heat - dissipation);\n-      }\n-    }\n-  }\n-\n-  private processPowerGeneration(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        if (cell.structure !== StructureType.Turbine) continue;\n-        if (cell.heat <= 0) continue;\n-\n-        const baseStats = STRUCTURE_BASE_STATS[StructureType.Turbine];\n-        const maxHeatConsumption = baseStats.maxHeatConsumption * Math.pow(10, cell.tier - 1);\n-        const powerGeneration = baseStats.powerGeneration;\n-\n-        const heatConsumed = Math.min(cell.heat, maxHeatConsumption);\n-        const powerGenerated = heatConsumed * powerGeneration;\n-\n-        cell.heat -= heatConsumed;\n-        cell.power += powerGenerated;\n-        this.state.stats.totalPowerGenerated += powerGenerated;\n-      }\n-    }\n-  }\n-\n-  private processPowerSale(): void {\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-\n-        // Turbines transfer power to nearby substations\n-        if (cell.structure === StructureType.Turbine && cell.power > 0) {\n-          const neighbors = this.getNeighbors(x, y);\n-          for (const neighbor of neighbors) {\n-            if (neighbor.structure === StructureType.Substation) {\n-              this.state.grid[neighbor.y][neighbor.x].power += cell.power;\n-              cell.power = 0;\n-              break;\n-            }\n-          }\n-        }\n-\n-        // Substations sell power\n-        if (cell.structure === StructureType.Substation && cell.power > 0) {\n-          const saleRate = this.getEffectivePowerSaleRate(cell);\n-          const powerToSell = Math.min(cell.power, saleRate);\n-          const earnings = powerToSell * ECONOMY.MONEY_PER_POWER;\n-\n-          this.state.money += earnings;\n-          this.state.stats.totalMoneyEarned += earnings;\n-          cell.power -= powerToSell;\n-\n-          if (earnings > 0) {\n-            this.emitEvent({\n-              type: 'power_sold',\n-              x,\n-              y,\n-              amount: earnings,\n-            });\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  private processOverheating(): void {\n-    let meltdown = false;\n-    const meltedCells: { x: number; y: number; structure: StructureType; tier: Tier }[] = [];\n-\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        if (cell.structure === StructureType.Empty) continue;\n-\n-        const meltTemp = this.getEffectiveMeltTemp(cell.structure);\n-        if (cell.heat > meltTemp) {\n-          if (cell.structure === StructureType.FuelRod) {\n-            // Fuel rod meltdown - catastrophic failure\n-            meltdown = true;\n-          } else {\n-            // Regular structure melts\n-            meltedCells.push({ x, y, structure: cell.structure, tier: cell.tier });\n-          }\n-        }\n-      }\n-    }\n-\n-    // Melt non-fuel structures\n-    for (const { x, y, structure, tier } of meltedCells) {\n-      this.state.grid[y][x] = this.createEmptyCell(x, y);\n-      this.emitEvent({\n-        type: 'structure_melted',\n-        x,\n-        y,\n-        structure,\n-        tier,\n-      });\n-    }\n-\n-    if (meltdown) {\n-      this.triggerMeltdown();\n-    }\n-  }\n-\n-  private triggerMeltdown(): void {\n-    this.state.stats.meltdownCount++;\n-\n-    // Destroy all structures but keep money\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        this.state.grid[y][x] = this.createEmptyCell(x, y);\n-      }\n-    }\n-\n-    this.emitEvent({ type: 'meltdown' });\n-\n-    // Check for exotic fuel unlock\n-    this.checkSecretUnlocks();\n-  }\n-\n-  private trackHighHeatSurvival(): void {\n-    // Check if any fuel rod is at >90% of its melt temp\n-    let hasHighHeatFuelRod = false;\n-\n-    for (let y = 0; y < this.state.gridSize; y++) {\n-      for (let x = 0; x < this.state.gridSize; x++) {\n-        const cell = this.state.grid[y][x];\n-        if (cell.structure !== StructureType.FuelRod) continue;\n-\n-        const meltTemp = this.getEffectiveMeltTemp(StructureType.FuelRod);\n-        if (cell.heat >= meltTemp * 0.9) {\n-          hasHighHeatFuelRod = true;\n-          break;\n-        }\n-      }\n-      if (hasHighHeatFuelRod) break;\n-    }\n-\n-    if (hasHighHeatFuelRod) {\n-      this.state.stats.ticksAtHighHeat++;\n-    }\n-  }\n-\n   // ==========================================================================\n   // SERIALIZATION\n   // ==========================================================================\n \n   serialize(): string {\n-    return JSON.stringify(this.state);\n+    const state: GameState = {\n+      grid: this.gridManager.getSnapshot(),\n+      gridSize: this.gridManager.getSize(),\n+      money: this.money,\n+      stats: { ...this.stats },\n+      upgrades: this.upgradeManager.getUpgradeState(),\n+      secrets: this.upgradeManager.getSecretState(),\n+    };\n+    return JSON.stringify(state);\n   }\n \n   static deserialize(data: string): HeatGame {\n     const state = JSON.parse(data) as GameState;\n     const game = new HeatGame(0);\n-    game.state = state;\n+\n+    // Restore grid\n+    game.gridManager.restoreFromState(state.grid, state.gridSize);\n+\n+    // Restore money and stats\n+    game.money = state.money;\n+    game.stats = { ...state.stats };\n+\n+    // Restore upgrades\n+    game.upgradeManager.restoreUpgradeState(state.upgrades);\n+    game.upgradeManager.restoreSecretState(state.secrets);\n+\n+    // Sync physics engine stats\n+    game.physicsEngine.setStats({\n+      totalPowerGenerated: state.stats.totalPowerGenerated,\n+      totalMoneyEarned: state.stats.totalMoneyEarned,\n+      fuelRodsDepleted: state.stats.fuelRodsDepleted,\n+      ticksAtHighHeat: state.stats.ticksAtHighHeat,\n+    });\n+\n     return game;\n   }\n \n   // ==========================================================================\n-  // BACKWARD COMPATIBILITY (for tests)\n+  // BACKWARD COMPATIBILITY\n   // ==========================================================================\n \n   /** @deprecated Use getGridSize() instead */\n   get GRID_SIZE(): number {\n-    return this.state.gridSize;\n+    return this.gridManager.getSize();\n   }\n }\n \n-// Re-export GRID_SIZE for backward compatibility\n+// Re-export for backward compatibility\n export { CORE_SETTINGS };\n export const GRID_SIZE = CORE_SETTINGS.INITIAL_GRID_SIZE;\ndiff --git a/src/game/PhysicsEngine.test.ts b/src/game/PhysicsEngine.test.ts\nnew file mode 100644\nindex 0000000..b1487d7\n--- /dev/null\n+++ b/src/game/PhysicsEngine.test.ts\n@@ -0,0 +1,152 @@\n+/**\n+ * PhysicsEngine Unit Tests\n+ *\n+ * Focus: Core physics mechanics, meltdown behavior (catastrophic), upgrade interactions\n+ */\n+\n+import { describe, it, expect, beforeEach } from 'vitest';\n+import { GridManager } from './GridManager.js';\n+import { PhysicsEngine } from './PhysicsEngine.js';\n+import { StructureType, Tier, UpgradeType, STRUCTURE_BASE_STATS } from './BalanceConfig.js';\n+\n+describe('PhysicsEngine', () => {\n+  let grid: GridManager;\n+  let physics: PhysicsEngine;\n+  let upgradeLevels: Map<UpgradeType, number>;\n+\n+  beforeEach(() => {\n+    grid = new GridManager(16);\n+    upgradeLevels = new Map();\n+    physics = new PhysicsEngine(grid, (type) => upgradeLevels.get(type) ?? 0);\n+  });\n+\n+  describe('heat mechanics', () => {\n+    it('fuel rods generate heat only when active', () => {\n+      const active = grid.getCellRef(3, 3)!;\n+      active.structure = StructureType.FuelRod;\n+      active.lifetime = 100;\n+\n+      const depleted = grid.getCellRef(8, 8)!;\n+      depleted.structure = StructureType.FuelRod;\n+      depleted.lifetime = 0;\n+\n+      physics.processHeatGeneration();\n+\n+      expect(grid.getCell(3, 3)!.heat).toBeGreaterThan(0);\n+      expect(grid.getCell(8, 8)!.heat).toBe(0);\n+    });\n+\n+    it('adjacent fuel rods boost heat generation', () => {\n+      const center = grid.getCellRef(5, 5)!;\n+      center.structure = StructureType.FuelRod;\n+      center.lifetime = 100;\n+\n+      physics.processHeatGeneration();\n+      const baseHeat = grid.getCell(5, 5)!.heat;\n+\n+      // Reset and add neighbor\n+      grid.getCellRef(5, 5)!.heat = 0;\n+      const neighbor = grid.getCellRef(5, 4)!;\n+      neighbor.structure = StructureType.FuelRod;\n+      neighbor.lifetime = 100;\n+\n+      physics.processHeatGeneration();\n+      expect(grid.getCell(5, 5)!.heat).toBeGreaterThan(baseHeat);\n+    });\n+\n+    it('heat transfers from hot to cold cells', () => {\n+      grid.getCellRef(5, 5)!.heat = 1000;\n+      grid.getCellRef(5, 6)!.heat = 0;\n+\n+      physics.processHeatTransfer();\n+\n+      expect(grid.getCell(5, 5)!.heat).toBeLessThan(1000);\n+      expect(grid.getCell(5, 6)!.heat).toBeGreaterThan(0);\n+    });\n+\n+    it('insulators block heat transfer', () => {\n+      const insulator = grid.getCellRef(5, 5)!;\n+      insulator.structure = StructureType.Insulator;\n+      insulator.heat = 1000;\n+\n+      physics.processHeatTransfer();\n+      const insulatorHeatAfter = grid.getCell(5, 5)!.heat;\n+\n+      // Compare with empty cell\n+      grid.getCellRef(5, 5)!.structure = StructureType.Empty;\n+      grid.getCellRef(5, 5)!.heat = 1000;\n+      physics.processHeatTransfer();\n+\n+      expect(insulatorHeatAfter).toBeGreaterThan(grid.getCell(5, 5)!.heat);\n+    });\n+  });\n+\n+  describe('meltdown behavior', () => {\n+    it('fuel rod overheating triggers meltdown and clears grid', () => {\n+      // Place some structures\n+      grid.getCellRef(3, 3)!.structure = StructureType.Turbine;\n+      grid.getCellRef(8, 8)!.structure = StructureType.Ventilator;\n+\n+      // Overheat fuel rod\n+      const fuel = grid.getCellRef(5, 5)!;\n+      fuel.structure = StructureType.FuelRod;\n+      fuel.heat = STRUCTURE_BASE_STATS[StructureType.FuelRod].meltTemp + 100;\n+\n+      const meltdown = physics.processOverheating();\n+\n+      expect(meltdown).toBe(true);\n+      expect(grid.getFilledCellCount()).toBe(0);\n+    });\n+\n+    it('non-fuel structures melt individually without meltdown', () => {\n+      const turbine = grid.getCellRef(5, 5)!;\n+      turbine.structure = StructureType.Turbine;\n+      turbine.heat = STRUCTURE_BASE_STATS[StructureType.Turbine].meltTemp + 100;\n+\n+      const meltdown = physics.processOverheating();\n+\n+      expect(meltdown).toBe(false);\n+      expect(grid.getCell(5, 5)!.structure).toBe(StructureType.Empty);\n+    });\n+  });\n+\n+  describe('power flow', () => {\n+    it('complete power chain: fuel -> turbine -> substation -> money', () => {\n+      const fuel = grid.getCellRef(5, 5)!;\n+      fuel.structure = StructureType.FuelRod;\n+      fuel.lifetime = 100;\n+\n+      const turbine = grid.getCellRef(5, 6)!;\n+      turbine.structure = StructureType.Turbine;\n+\n+      const substation = grid.getCellRef(5, 7)!;\n+      substation.structure = StructureType.Substation;\n+\n+      const result = physics.tick();\n+\n+      expect(result.moneyEarned).toBeGreaterThan(0);\n+      expect(result.meltdown).toBe(false);\n+    });\n+  });\n+\n+  describe('upgrade effects', () => {\n+    it('melt temp upgrades increase tolerance', () => {\n+      const base = physics.getEffectiveMeltTemp(StructureType.FuelRod);\n+\n+      upgradeLevels.set(UpgradeType.MeltTempFuelRod, 3);\n+\n+      expect(physics.getEffectiveMeltTemp(StructureType.FuelRod)).toBeGreaterThan(base);\n+    });\n+\n+    it('insulator upgrades reduce conductivity', () => {\n+      const insulator = grid.getCellRef(5, 5)!;\n+      insulator.structure = StructureType.Insulator;\n+\n+      const base = physics.getEffectiveConductivity(insulator);\n+\n+      upgradeLevels.set(UpgradeType.InsulatorConductivity, 2);\n+\n+      expect(physics.getEffectiveConductivity(insulator)).toBeLessThan(base);\n+    });\n+  });\n+});\ndiff --git a/src/game/PhysicsEngine.ts b/src/game/PhysicsEngine.ts\nnew file mode 100644\nindex 0000000..ef4c504\n--- /dev/null\n+++ b/src/game/PhysicsEngine.ts\n@@ -0,0 +1,483 @@\n+/**\n+ * PhysicsEngine - Handles heat generation, transfer, dissipation, and power generation\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ * This class is responsible for all physics simulation logic.\n+ */\n+\n+import {\n+  CORE_SETTINGS,\n+  StructureType,\n+  Tier,\n+  STRUCTURE_BASE_STATS,\n+  FUEL_ADJACENCY,\n+  ECONOMY,\n+  UpgradeType,\n+  UPGRADE_DEFINITIONS,\n+  EXOTIC_FUEL,\n+  getFuelHeatGeneration,\n+} from './BalanceConfig.js';\n+import { Cell, GridManager } from './GridManager.js';\n+\n+export interface PhysicsEvent {\n+  type: 'fuel_depleted' | 'power_sold' | 'structure_melted' | 'meltdown';\n+  x?: number;\n+  y?: number;\n+  tier?: Tier;\n+  structure?: StructureType;\n+  amount?: number;\n+}\n+\n+export type PhysicsEventListener = (event: PhysicsEvent) => void;\n+\n+export interface UpgradeLevels {\n+  [key: string]: number;\n+}\n+\n+export interface PhysicsStats {\n+  totalPowerGenerated: number;\n+  totalMoneyEarned: number;\n+  fuelRodsDepleted: number;\n+  ticksAtHighHeat: number;\n+}\n+\n+/**\n+ * PhysicsEngine handles all physics simulation for the heat game.\n+ * It operates on a GridManager and uses upgrade levels for calculations.\n+ */\n+export class PhysicsEngine {\n+  private eventListeners: PhysicsEventListener[] = [];\n+  private stats: PhysicsStats = {\n+    totalPowerGenerated: 0,\n+    totalMoneyEarned: 0,\n+    fuelRodsDepleted: 0,\n+    ticksAtHighHeat: 0,\n+  };\n+\n+  constructor(\n+    private gridManager: GridManager,\n+    private getUpgradeLevel: (type: UpgradeType) => number\n+  ) {}\n+\n+  /**\n+   * Add an event listener for physics events\n+   */\n+  addEventListener(listener: PhysicsEventListener): void {\n+    this.eventListeners.push(listener);\n+  }\n+\n+  /**\n+   * Remove an event listener\n+   */\n+  removeEventListener(listener: PhysicsEventListener): void {\n+    const index = this.eventListeners.indexOf(listener);\n+    if (index !== -1) {\n+      this.eventListeners.splice(index, 1);\n+    }\n+  }\n+\n+  private emitEvent(event: PhysicsEvent): void {\n+    for (const listener of this.eventListeners) {\n+      listener(event);\n+    }\n+  }\n+\n+  /**\n+   * Get the current physics stats\n+   */\n+  getStats(): PhysicsStats {\n+    return { ...this.stats };\n+  }\n+\n+  /**\n+   * Reset stats (used after deserialization)\n+   */\n+  setStats(stats: PhysicsStats): void {\n+    this.stats = { ...stats };\n+  }\n+\n+  /**\n+   * Get effective melt temperature for a structure type (with upgrades)\n+   */\n+  getEffectiveMeltTemp(structure: StructureType): number {\n+    const baseTemp = STRUCTURE_BASE_STATS[structure].meltTemp;\n+\n+    let upgradeType: UpgradeType | null = null;\n+    switch (structure) {\n+      case StructureType.FuelRod: upgradeType = UpgradeType.MeltTempFuelRod; break;\n+      case StructureType.Ventilator: upgradeType = UpgradeType.MeltTempVentilator; break;\n+      case StructureType.HeatExchanger: upgradeType = UpgradeType.MeltTempHeatExchanger; break;\n+      case StructureType.Insulator: upgradeType = UpgradeType.MeltTempInsulator; break;\n+      case StructureType.Turbine: upgradeType = UpgradeType.MeltTempTurbine; break;\n+      case StructureType.Substation: upgradeType = UpgradeType.MeltTempSubstation; break;\n+    }\n+\n+    if (upgradeType) {\n+      const level = this.getUpgradeLevel(upgradeType);\n+      const definition = UPGRADE_DEFINITIONS[upgradeType];\n+      return baseTemp + (level * definition.improvementPerLevel);\n+    }\n+\n+    return baseTemp;\n+  }\n+\n+  /**\n+   * Get effective conductivity for a cell (with upgrades)\n+   */\n+  getEffectiveConductivity(cell: Cell): number {\n+    const baseConductivity = STRUCTURE_BASE_STATS[cell.structure].conductivity;\n+\n+    if (cell.structure === StructureType.Turbine) {\n+      const level = this.getUpgradeLevel(UpgradeType.TurbineConductivity);\n+      const definition = UPGRADE_DEFINITIONS[UpgradeType.TurbineConductivity];\n+      return baseConductivity + (level * definition.improvementPerLevel);\n+    }\n+\n+    if (cell.structure === StructureType.Insulator) {\n+      const level = this.getUpgradeLevel(UpgradeType.InsulatorConductivity);\n+      if (level > 0) {\n+        return baseConductivity * Math.pow(0.5, level);\n+      }\n+    }\n+\n+    return baseConductivity;\n+  }\n+\n+  /**\n+   * Get effective heat dissipation for a cell (with upgrades)\n+   */\n+  getEffectiveHeatDissipation(cell: Cell): number {\n+    if (cell.structure !== StructureType.Ventilator && cell.structure !== StructureType.VoidCell) {\n+      return 0;\n+    }\n+\n+    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n+    let dissipation = baseStats.heatDissipation;\n+\n+    if (cell.structure === StructureType.Ventilator) {\n+      dissipation *= Math.pow(10, cell.tier - 1);\n+\n+      const level = this.getUpgradeLevel(UpgradeType.VentilatorDissipation);\n+      const definition = UPGRADE_DEFINITIONS[UpgradeType.VentilatorDissipation];\n+      dissipation += level * definition.improvementPerLevel;\n+    }\n+\n+    return dissipation;\n+  }\n+\n+  /**\n+   * Get effective power sale rate for a cell (with upgrades)\n+   */\n+  getEffectivePowerSaleRate(cell: Cell): number {\n+    if (cell.structure !== StructureType.Substation) return 0;\n+\n+    const baseStats = STRUCTURE_BASE_STATS[cell.structure];\n+    let saleRate = baseStats.powerSaleRate;\n+\n+    saleRate *= Math.pow(10, cell.tier - 1);\n+\n+    const level = this.getUpgradeLevel(UpgradeType.SubstationSaleRate);\n+    const definition = UPGRADE_DEFINITIONS[UpgradeType.SubstationSaleRate];\n+    saleRate += level * definition.improvementPerLevel;\n+\n+    return saleRate;\n+  }\n+\n+  /**\n+   * Process heat generation from fuel rods\n+   */\n+  processHeatGeneration(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+        if (cell.lifetime <= 0) continue;\n+\n+        const upgradeLevel = this.getUpgradeLevel(UpgradeType.FuelHeatOutput);\n+        let heatGeneration = getFuelHeatGeneration(cell.tier, upgradeLevel);\n+\n+        // Adjacency bonus\n+        const adjacentFuelRods = this.gridManager.countAdjacentFuelRods(x, y);\n+        const adjacencyMultiplier = 1 + (adjacentFuelRods * FUEL_ADJACENCY.BONUS_PER_ADJACENT);\n+        heatGeneration *= adjacencyMultiplier;\n+\n+        // Exotic fuel scaling\n+        if (cell.isExotic) {\n+          const tempMultiplier = Math.min(\n+            EXOTIC_FUEL.MAX_MULTIPLIER,\n+            EXOTIC_FUEL.BASE_MULTIPLIER + (cell.heat / 1000) * EXOTIC_FUEL.HEAT_SCALING\n+          );\n+          heatGeneration *= tempMultiplier;\n+        }\n+\n+        cell.heat += heatGeneration;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process fuel depletion\n+   */\n+  processFuelDepletion(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+        if (cell.lifetime <= 0) continue;\n+\n+        cell.lifetime--;\n+\n+        if (cell.lifetime <= 0) {\n+          this.stats.fuelRodsDepleted++;\n+          this.emitEvent({\n+            type: 'fuel_depleted',\n+            x,\n+            y,\n+            tier: cell.tier,\n+          });\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process heat transfer between cells\n+   */\n+  processHeatTransfer(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    const heatDeltas: number[][] = [];\n+    for (let y = 0; y < gridSize; y++) {\n+      heatDeltas.push(new Array(gridSize).fill(0));\n+    }\n+\n+    const transferRate = CORE_SETTINGS.BASE_HEAT_TRANSFER_RATE;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        const cellConductivity = this.getEffectiveConductivity(cell);\n+        const neighbors = this.gridManager.getNeighbors(x, y);\n+\n+        for (const neighbor of neighbors) {\n+          const neighborConductivity = this.getEffectiveConductivity(neighbor);\n+          const heatDiff = cell.heat - neighbor.heat;\n+\n+          if (heatDiff > 0) {\n+            const conductivity = Math.min(cellConductivity, neighborConductivity);\n+            const transfer = heatDiff * transferRate * conductivity;\n+            heatDeltas[y][x] -= transfer;\n+            heatDeltas[neighbor.y][neighbor.x] += transfer;\n+          }\n+        }\n+\n+        // Edge cells lose heat to environment\n+        const edgeCount = 4 - neighbors.length;\n+        if (edgeCount > 0 && cell.heat > CORE_SETTINGS.AMBIENT_TEMPERATURE) {\n+          const heatAboveAmbient = cell.heat - CORE_SETTINGS.AMBIENT_TEMPERATURE;\n+          const envTransfer = heatAboveAmbient * CORE_SETTINGS.ENVIRONMENT_HEAT_TRANSFER_RATE * edgeCount;\n+          heatDeltas[y][x] -= envTransfer;\n+        }\n+      }\n+    }\n+\n+    // Apply deltas\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        grid[y][x].heat = Math.max(0, grid[y][x].heat + heatDeltas[y][x]);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process heat dissipation (ventilators and void cells)\n+   */\n+  processHeatDissipation(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        const dissipation = this.getEffectiveHeatDissipation(cell);\n+        cell.heat = Math.max(0, cell.heat - dissipation);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process power generation (turbines)\n+   */\n+  processPowerGeneration(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure !== StructureType.Turbine) continue;\n+        if (cell.heat <= 0) continue;\n+\n+        const baseStats = STRUCTURE_BASE_STATS[StructureType.Turbine];\n+        const maxHeatConsumption = baseStats.maxHeatConsumption * Math.pow(10, cell.tier - 1);\n+        const powerGeneration = baseStats.powerGeneration;\n+\n+        const heatConsumed = Math.min(cell.heat, maxHeatConsumption);\n+        const powerGenerated = heatConsumed * powerGeneration;\n+\n+        cell.heat -= heatConsumed;\n+        cell.power += powerGenerated;\n+        this.stats.totalPowerGenerated += powerGenerated;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Process power sale (substations)\n+   * Returns the amount of money earned\n+   */\n+  processPowerSale(): number {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let totalEarnings = 0;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+\n+        // Turbines transfer power to nearby substations\n+        if (cell.structure === StructureType.Turbine && cell.power > 0) {\n+          const neighbors = this.gridManager.getNeighbors(x, y);\n+          for (const neighbor of neighbors) {\n+            if (neighbor.structure === StructureType.Substation) {\n+              grid[neighbor.y][neighbor.x].power += cell.power;\n+              cell.power = 0;\n+              break;\n+            }\n+          }\n+        }\n+\n+        // Substations sell power\n+        if (cell.structure === StructureType.Substation && cell.power > 0) {\n+          const saleRate = this.getEffectivePowerSaleRate(cell);\n+          const powerToSell = Math.min(cell.power, saleRate);\n+          const earnings = powerToSell * ECONOMY.MONEY_PER_POWER;\n+\n+          totalEarnings += earnings;\n+          this.stats.totalMoneyEarned += earnings;\n+          cell.power -= powerToSell;\n+\n+          if (earnings > 0) {\n+            this.emitEvent({\n+              type: 'power_sold',\n+              x,\n+              y,\n+              amount: earnings,\n+            });\n+          }\n+        }\n+      }\n+    }\n+\n+    return totalEarnings;\n+  }\n+\n+  /**\n+   * Process overheating and meltdowns\n+   * Returns true if a meltdown occurred\n+   */\n+  processOverheating(): boolean {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let meltdown = false;\n+    const meltedCells: { x: number; y: number; structure: StructureType; tier: Tier }[] = [];\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure === StructureType.Empty) continue;\n+\n+        const meltTemp = this.getEffectiveMeltTemp(cell.structure);\n+        if (cell.heat > meltTemp) {\n+          if (cell.structure === StructureType.FuelRod) {\n+            meltdown = true;\n+          } else {\n+            meltedCells.push({ x, y, structure: cell.structure, tier: cell.tier });\n+          }\n+        }\n+      }\n+    }\n+\n+    // Melt non-fuel structures\n+    for (const { x, y, structure, tier } of meltedCells) {\n+      this.gridManager.resetCell(x, y);\n+      this.emitEvent({\n+        type: 'structure_melted',\n+        x,\n+        y,\n+        structure,\n+        tier,\n+      });\n+    }\n+\n+    if (meltdown) {\n+      this.gridManager.clearAll();\n+      this.emitEvent({ type: 'meltdown' });\n+    }\n+\n+    return meltdown;\n+  }\n+\n+  /**\n+   * Track high heat survival (for secret unlock)\n+   */\n+  trackHighHeatSurvival(): void {\n+    const grid = this.gridManager.getGridRef();\n+    const gridSize = this.gridManager.getSize();\n+    let hasHighHeatFuelRod = false;\n+\n+    for (let y = 0; y < gridSize; y++) {\n+      for (let x = 0; x < gridSize; x++) {\n+        const cell = grid[y][x];\n+        if (cell.structure !== StructureType.FuelRod) continue;\n+\n+        const meltTemp = this.getEffectiveMeltTemp(StructureType.FuelRod);\n+        if (cell.heat >= meltTemp * 0.9) {\n+          hasHighHeatFuelRod = true;\n+          break;\n+        }\n+      }\n+      if (hasHighHeatFuelRod) break;\n+    }\n+\n+    if (hasHighHeatFuelRod) {\n+      this.stats.ticksAtHighHeat++;\n+    }\n+  }\n+\n+  /**\n+   * Run a complete physics tick\n+   * Returns the money earned from power sales\n+   */\n+  tick(): { moneyEarned: number; meltdown: boolean } {\n+    this.processHeatGeneration();\n+    this.processFuelDepletion();\n+    this.processHeatTransfer();\n+    this.processHeatDissipation();\n+    this.processPowerGeneration();\n+    const moneyEarned = this.processPowerSale();\n+    const meltdown = this.processOverheating();\n+    this.trackHighHeatSurvival();\n+\n+    return { moneyEarned, meltdown };\n+  }\n+}\ndiff --git a/src/game/UpgradeManager.test.ts b/src/game/UpgradeManager.test.ts\nnew file mode 100644\nindex 0000000..2b215ce\n--- /dev/null\n+++ b/src/game/UpgradeManager.test.ts\n@@ -0,0 +1,115 @@\n+/**\n+ * UpgradeManager Unit Tests\n+ *\n+ * Focus: Serialization (data loss risk), max level enforcement, unlock conditions\n+ */\n+\n+import { describe, it, expect, beforeEach } from 'vitest';\n+import { UpgradeManager } from './UpgradeManager.js';\n+import { UpgradeType, SecretUpgradeType, UPGRADE_DEFINITIONS } from './BalanceConfig.js';\n+\n+describe('UpgradeManager', () => {\n+  let upgrades: UpgradeManager;\n+\n+  beforeEach(() => {\n+    upgrades = new UpgradeManager();\n+  });\n+\n+  describe('upgrade purchasing', () => {\n+    it('increases level and cost after purchase', () => {\n+      const type = UpgradeType.FuelHeatOutput;\n+      const initialCost = upgrades.getUpgradeCost(type);\n+\n+      upgrades.purchaseUpgrade(type, initialCost);\n+\n+      expect(upgrades.getUpgradeLevel(type)).toBe(1);\n+      expect(upgrades.getUpgradeCost(type)).toBeGreaterThan(initialCost);\n+    });\n+\n+    it('respects max level', () => {\n+      const type = UpgradeType.TurbineConductivity;\n+      const maxLevel = UPGRADE_DEFINITIONS[type].maxLevel;\n+\n+      // Purchase to max\n+      for (let i = 0; i < maxLevel; i++) {\n+        upgrades.purchaseUpgrade(type, 1e9);\n+      }\n+\n+      expect(upgrades.getUpgradeLevel(type)).toBe(maxLevel);\n+      expect(upgrades.canPurchaseUpgrade(type, 1e9)).toBe(false);\n+    });\n+\n+    it('fails without enough money', () => {\n+      const cost = upgrades.purchaseUpgrade(UpgradeType.FuelHeatOutput, 0);\n+      expect(cost).toBe(0);\n+      expect(upgrades.getUpgradeLevel(UpgradeType.FuelHeatOutput)).toBe(0);\n+    });\n+  });\n+\n+  describe('secret unlocks', () => {\n+    it('unlocks secrets when conditions are met', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 10000, demolishCount: 100, ticksAtHighHeat: 0 };\n+\n+      const unlocked = upgrades.checkSecretUnlocks(stats);\n+\n+      expect(unlocked).toContain(SecretUpgradeType.ExoticFuel);   // 1 meltdown\n+      expect(unlocked).toContain(SecretUpgradeType.Salvage);       // 100 demolishes\n+      expect(unlocked).toContain(SecretUpgradeType.Overclock);     // 10000 money\n+    });\n+\n+    it('does not re-unlock already unlocked secrets', () => {\n+      const stats = { meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 };\n+\n+      const first = upgrades.checkSecretUnlocks(stats);\n+      const second = upgrades.checkSecretUnlocks(stats);\n+\n+      expect(first).toContain(SecretUpgradeType.ExoticFuel);\n+      expect(second).not.toContain(SecretUpgradeType.ExoticFuel);\n+    });\n+\n+    it('toggleable secrets auto-enable on purchase', () => {\n+      upgrades.checkSecretUnlocks({ meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 });\n+      upgrades.purchaseSecret(SecretUpgradeType.ExoticFuel, 1e6);\n+\n+      expect(upgrades.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(true);\n+\n+      upgrades.toggleSecret(SecretUpgradeType.ExoticFuel, false);\n+      expect(upgrades.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(false);\n+    });\n+  });\n+\n+  describe('serialization', () => {\n+    it('upgrade state survives round-trip', () => {\n+      upgrades.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1e6);\n+      upgrades.purchaseUpgrade(UpgradeType.FuelHeatOutput, 1e6);\n+\n+      const state = upgrades.getUpgradeState();\n+      const restored = new UpgradeManager();\n+      restored.restoreUpgradeState(state);\n+\n+      expect(restored.getUpgradeLevel(UpgradeType.FuelHeatOutput)).toBe(2);\n+    });\n+\n+    it('secret state survives round-trip', () => {\n+      upgrades.checkSecretUnlocks({ meltdownCount: 1, filledCells: 0, totalMoneyEarned: 0, demolishCount: 0, ticksAtHighHeat: 0 });\n+      upgrades.purchaseSecret(SecretUpgradeType.ExoticFuel, 1e6);\n+      upgrades.toggleSecret(SecretUpgradeType.ExoticFuel, false);\n+\n+      const state = upgrades.getSecretState();\n+      const restored = new UpgradeManager();\n+      restored.restoreSecretState(state);\n+\n+      expect(restored.isSecretUnlocked(SecretUpgradeType.ExoticFuel)).toBe(true);\n+      expect(restored.isSecretPurchased(SecretUpgradeType.ExoticFuel)).toBe(true);\n+      expect(restored.isSecretEnabled(SecretUpgradeType.ExoticFuel)).toBe(false);\n+    });\n+  });\n+\n+  describe('reactor expansion', () => {\n+    it('returns correct expansion sizes', () => {\n+      expect(upgrades.getExpansionSize(SecretUpgradeType.ReactorExpansion1)).toBe(17);\n+      expect(upgrades.getExpansionSize(SecretUpgradeType.ReactorExpansion4)).toBe(20);\n+      expect(upgrades.getExpansionSize(SecretUpgradeType.Salvage)).toBeNull();\n+    });\n+  });\n+});\ndiff --git a/src/game/UpgradeManager.ts b/src/game/UpgradeManager.ts\nnew file mode 100644\nindex 0000000..34d4ec4\n--- /dev/null\n+++ b/src/game/UpgradeManager.ts\n@@ -0,0 +1,299 @@\n+/**\n+ * UpgradeManager - Handles regular upgrades and secret upgrades\n+ *\n+ * Extracted from HeatGame to reduce cognitive load and enable isolated testing.\n+ * This class manages upgrade purchasing, secret unlock conditions, and toggle states.\n+ */\n+\n+import {\n+  UpgradeType,\n+  UPGRADE_DEFINITIONS,\n+  SecretUpgradeType,\n+  SECRET_UPGRADE_DEFINITIONS,\n+  getUpgradeCost,\n+  getSecretUnlockProgress,\n+} from './BalanceConfig.js';\n+\n+export interface UpgradeState {\n+  levels: Record<UpgradeType, number>;\n+}\n+\n+export interface SecretState {\n+  unlocked: Record<SecretUpgradeType, boolean>;\n+  purchased: Record<SecretUpgradeType, boolean>;\n+  enabled: Record<SecretUpgradeType, boolean>;\n+}\n+\n+export interface UpgradeEvent {\n+  type: 'upgrade_purchased' | 'secret_unlocked' | 'secret_purchased';\n+  upgradeType?: UpgradeType;\n+  secretType?: SecretUpgradeType;\n+}\n+\n+export type UpgradeEventListener = (event: UpgradeEvent) => void;\n+\n+export interface UnlockStats {\n+  meltdownCount: number;\n+  filledCells: number;\n+  totalMoneyEarned: number;\n+  demolishCount: number;\n+  ticksAtHighHeat: number;\n+}\n+\n+/**\n+ * UpgradeManager handles all upgrade-related logic including:\n+ * - Regular upgrade purchasing and level tracking\n+ * - Secret upgrade unlocking, purchasing, and toggling\n+ */\n+export class UpgradeManager {\n+  private upgrades: UpgradeState;\n+  private secrets: SecretState;\n+  private eventListeners: UpgradeEventListener[] = [];\n+\n+  constructor() {\n+    this.upgrades = this.createInitialUpgradeState();\n+    this.secrets = this.createInitialSecretState();\n+  }\n+\n+  private createInitialUpgradeState(): UpgradeState {\n+    const levels: Record<UpgradeType, number> = {} as Record<UpgradeType, number>;\n+    for (const type of Object.values(UpgradeType)) {\n+      levels[type] = 0;\n+    }\n+    return { levels };\n+  }\n+\n+  private createInitialSecretState(): SecretState {\n+    const unlocked: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+    const purchased: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+    const enabled: Record<SecretUpgradeType, boolean> = {} as Record<SecretUpgradeType, boolean>;\n+\n+    for (const type of Object.values(SecretUpgradeType)) {\n+      unlocked[type] = false;\n+      purchased[type] = false;\n+      enabled[type] = false;\n+    }\n+    return { unlocked, purchased, enabled };\n+  }\n+\n+  /**\n+   * Add an event listener for upgrade events\n+   */\n+  addEventListener(listener: UpgradeEventListener): void {\n+    this.eventListeners.push(listener);\n+  }\n+\n+  /**\n+   * Remove an event listener\n+   */\n+  removeEventListener(listener: UpgradeEventListener): void {\n+    const index = this.eventListeners.indexOf(listener);\n+    if (index !== -1) {\n+      this.eventListeners.splice(index, 1);\n+    }\n+  }\n+\n+  private emitEvent(event: UpgradeEvent): void {\n+    for (const listener of this.eventListeners) {\n+      listener(event);\n+    }\n+  }\n+\n+  // ==========================================================================\n+  // REGULAR UPGRADES\n+  // ==========================================================================\n+\n+  /**\n+   * Get the current level of an upgrade\n+   */\n+  getUpgradeLevel(type: UpgradeType): number {\n+    return this.upgrades.levels[type];\n+  }\n+\n+  /**\n+   * Get the cost for the next level of an upgrade\n+   */\n+  getUpgradeCost(type: UpgradeType): number {\n+    const currentLevel = this.upgrades.levels[type];\n+    return getUpgradeCost(type, currentLevel);\n+  }\n+\n+  /**\n+   * Check if an upgrade can be purchased\n+   */\n+  canPurchaseUpgrade(type: UpgradeType, currentMoney: number): boolean {\n+    const definition = UPGRADE_DEFINITIONS[type];\n+    const currentLevel = this.upgrades.levels[type];\n+\n+    if (definition.maxLevel > 0 && currentLevel >= definition.maxLevel) {\n+      return false;\n+    }\n+\n+    const cost = getUpgradeCost(type, currentLevel);\n+    return currentMoney >= cost;\n+  }\n+\n+  /**\n+   * Purchase an upgrade\n+   * Returns the cost if successful, 0 if failed\n+   */\n+  purchaseUpgrade(type: UpgradeType, currentMoney: number): number {\n+    if (!this.canPurchaseUpgrade(type, currentMoney)) return 0;\n+\n+    const cost = getUpgradeCost(type, this.upgrades.levels[type]);\n+    this.upgrades.levels[type]++;\n+\n+    this.emitEvent({ type: 'upgrade_purchased', upgradeType: type });\n+    return cost;\n+  }\n+\n+  // ==========================================================================\n+  // SECRET UPGRADES\n+  // ==========================================================================\n+\n+  /**\n+   * Check if a secret upgrade is unlocked\n+   */\n+  isSecretUnlocked(type: SecretUpgradeType): boolean {\n+    return this.secrets.unlocked[type];\n+  }\n+\n+  /**\n+   * Check if a secret upgrade has been purchased\n+   */\n+  isSecretPurchased(type: SecretUpgradeType): boolean {\n+    return this.secrets.purchased[type];\n+  }\n+\n+  /**\n+   * Check if a toggleable secret is enabled\n+   */\n+  isSecretEnabled(type: SecretUpgradeType): boolean {\n+    return this.secrets.enabled[type];\n+  }\n+\n+  /**\n+   * Get the cost of a secret upgrade\n+   */\n+  getSecretCost(type: SecretUpgradeType): number {\n+    return SECRET_UPGRADE_DEFINITIONS[type].cost;\n+  }\n+\n+  /**\n+   * Check if a secret can be purchased\n+   */\n+  canPurchaseSecret(type: SecretUpgradeType, currentMoney: number): boolean {\n+    if (!this.secrets.unlocked[type]) return false;\n+    if (this.secrets.purchased[type]) return false;\n+\n+    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n+    return currentMoney >= cost;\n+  }\n+\n+  /**\n+   * Purchase a secret upgrade\n+   * Returns the cost if successful, 0 if failed\n+   */\n+  purchaseSecret(type: SecretUpgradeType, currentMoney: number): number {\n+    if (!this.canPurchaseSecret(type, currentMoney)) return 0;\n+\n+    const cost = SECRET_UPGRADE_DEFINITIONS[type].cost;\n+    this.secrets.purchased[type] = true;\n+\n+    // Auto-enable toggleable secrets\n+    if (SECRET_UPGRADE_DEFINITIONS[type].isToggle) {\n+      this.secrets.enabled[type] = true;\n+    }\n+\n+    this.emitEvent({ type: 'secret_purchased', secretType: type });\n+    return cost;\n+  }\n+\n+  /**\n+   * Toggle a secret upgrade on/off\n+   */\n+  toggleSecret(type: SecretUpgradeType, enabled: boolean): void {\n+    if (!this.secrets.purchased[type]) return;\n+    if (!SECRET_UPGRADE_DEFINITIONS[type].isToggle) return;\n+\n+    this.secrets.enabled[type] = enabled;\n+  }\n+\n+  /**\n+   * Check and unlock secrets based on current game stats\n+   * Returns array of newly unlocked secrets\n+   */\n+  checkSecretUnlocks(stats: UnlockStats): SecretUpgradeType[] {\n+    const newlyUnlocked: SecretUpgradeType[] = [];\n+\n+    for (const type of Object.values(SecretUpgradeType)) {\n+      if (this.secrets.unlocked[type]) continue;\n+\n+      const progress = getSecretUnlockProgress(type, stats);\n+      if (progress.unlocked) {\n+        this.secrets.unlocked[type] = true;\n+        newlyUnlocked.push(type);\n+        this.emitEvent({ type: 'secret_unlocked', secretType: type });\n+      }\n+    }\n+\n+    return newlyUnlocked;\n+  }\n+\n+  /**\n+   * Get the grid size expansion for a reactor expansion secret\n+   */\n+  getExpansionSize(type: SecretUpgradeType): number | null {\n+    switch (type) {\n+      case SecretUpgradeType.ReactorExpansion1: return 17;\n+      case SecretUpgradeType.ReactorExpansion2: return 18;\n+      case SecretUpgradeType.ReactorExpansion3: return 19;\n+      case SecretUpgradeType.ReactorExpansion4: return 20;\n+      default: return null;\n+    }\n+  }\n+\n+  // ==========================================================================\n+  // SERIALIZATION\n+  // ==========================================================================\n+\n+  /**\n+   * Get the current upgrade state for serialization\n+   */\n+  getUpgradeState(): UpgradeState {\n+    return {\n+      levels: { ...this.upgrades.levels },\n+    };\n+  }\n+\n+  /**\n+   * Get the current secret state for serialization\n+   */\n+  getSecretState(): SecretState {\n+    return {\n+      unlocked: { ...this.secrets.unlocked },\n+      purchased: { ...this.secrets.purchased },\n+      enabled: { ...this.secrets.enabled },\n+    };\n+  }\n+\n+  /**\n+   * Restore upgrade state from serialized data\n+   */\n+  restoreUpgradeState(state: UpgradeState): void {\n+    this.upgrades = {\n+      levels: { ...state.levels },\n+    };\n+  }\n+\n+  /**\n+   * Restore secret state from serialized data\n+   */\n+  restoreSecretState(state: SecretState): void {\n+    this.secrets = {\n+      unlocked: { ...state.unlocked },\n+      purchased: { ...state.purchased },\n+      enabled: { ...state.enabled },\n+    };\n+  }\n+}",
          "actualWorkers": 1
        },
        "id": "chromium",
        "name": "chromium",
        "testDir": "/home/runner/work/claudetest123/claudetest123/e2e",
        "testIgnore": [],
        "testMatch": [
          "**/*.@(spec|test).?(c|m)[jt]s?(x)"
        ],
        "timeout": 30000
      }
    ],
    "quiet": false,
    "reporter": [
      [
        "html",
        {
          "outputFolder": "playwright-report"
        }
      ],
      [
        "list",
        null
      ],
      [
        "json",
        {
          "outputFile": "test-results/results.json"
        }
      ]
    ],
    "reportSlowTests": {
      "max": 5,
      "threshold": 300000
    },
    "runAgents": "none",
    "shard": null,
    "tags": [],
    "updateSnapshots": "missing",
    "updateSourceMethod": "patch",
    "version": "1.58.0",
    "workers": 1,
    "webServer": {
      "command": "npm run serve",
      "url": "http://localhost:3000",
      "reuseExistingServer": false,
      "timeout": 120000
    }
  },
  "suites": [
    {
      "title": "heat-game.spec.ts",
      "file": "heat-game.spec.ts",
      "column": 0,
      "line": 0,
      "specs": [],
      "suites": [
        {
          "title": "Heat Game E2E Tests",
          "file": "heat-game.spec.ts",
          "line": 40,
          "column": 6,
          "specs": [
            {
              "title": "should load the game and display initial state",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 452,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:42:45.023Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-2428b-e-and-display-initial-state-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-2428b-e-and-display-initial-state-chromium/attachments/browser-logs-252e98eebb6d2a6fd5612fd184955e74f7d8fa0e.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-1f7f90ca45f76c134f4d",
              "file": "heat-game.spec.ts",
              "line": 86,
              "column": 3
            },
            {
              "title": "should place a Fuel Rod on the grid",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 605,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:42:45.710Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-05fff-lace-a-Fuel-Rod-on-the-grid-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-05fff-lace-a-Fuel-Rod-on-the-grid-chromium/attachments/browser-logs-daa597c1e58cdd3735064670bc098a56f535a7d5.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-a31bde006f3c29450fad",
              "file": "heat-game.spec.ts",
              "line": 116,
              "column": 3
            },
            {
              "title": "should place multiple structures and observe heat dynamics",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1186,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:42:46.333Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-edba4-s-and-observe-heat-dynamics-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-edba4-s-and-observe-heat-dynamics-chromium/attachments/browser-logs-a9526112523c68aa24fe78334be3ec2af4a1ba62.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-2ed04ebe32d9c471053a",
              "file": "heat-game.spec.ts",
              "line": 148,
              "column": 3
            },
            {
              "title": "should demolish a structure with right-click",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 570,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:42:47.534Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-53724--structure-with-right-click-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-53724--structure-with-right-click-chromium/attachments/browser-logs-d97b4f4e87a5cc31e1b5dee61d33b7cf6ee7bb2f.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-ff211d87a2ad19067056",
              "file": "heat-game.spec.ts",
              "line": 185,
              "column": 3
            },
            {
              "title": "should build a power generation setup",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1735,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:42:48.117Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-206ae-ld-a-power-generation-setup-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-206ae-ld-a-power-generation-setup-chromium/attachments/browser-logs-6db27ca250b3a1a4083663dd5a90aeedb0e1a354.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-abe0096aa1a1c45a3b34",
              "file": "heat-game.spec.ts",
              "line": 216,
              "column": 3
            },
            {
              "title": "should show heat buildup with clustered fuel rods",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1621,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:42:49.865Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-1ce31-up-with-clustered-fuel-rods-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-1ce31-up-with-clustered-fuel-rods-chromium/attachments/browser-logs-4108f70a5376472a80710ba1c287f526e1cfc9b4.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-ac87d21624a439db98b8",
              "file": "heat-game.spec.ts",
              "line": 253,
              "column": 3
            },
            {
              "title": "should not allow building without sufficient money",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1417,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:42:51.500Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-ee0f6-ng-without-sufficient-money-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-ee0f6-ng-without-sufficient-money-chromium/attachments/browser-logs-67852c21b9cbe344288f7cfb81aa3e88ded21441.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-b096005e15a85f67c2a8",
              "file": "heat-game.spec.ts",
              "line": 291,
              "column": 3
            },
            {
              "title": "should handle rapid clicking on the grid",
              "ok": true,
              "tags": [],
              "tests": [
                {
                  "timeout": 30000,
                  "annotations": [],
                  "expectedStatus": "passed",
                  "projectId": "chromium",
                  "projectName": "chromium",
                  "results": [
                    {
                      "workerIndex": 0,
                      "parallelIndex": 0,
                      "status": "passed",
                      "duration": 1205,
                      "errors": [],
                      "stdout": [],
                      "stderr": [],
                      "retry": 0,
                      "startTime": "2026-01-31T12:42:52.932Z",
                      "annotations": [],
                      "attachments": [
                        {
                          "name": "screenshot",
                          "contentType": "image/png",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-c664c--rapid-clicking-on-the-grid-chromium/test-finished-1.png"
                        },
                        {
                          "name": "browser-logs",
                          "contentType": "text/plain",
                          "path": "/home/runner/work/claudetest123/claudetest123/test-results/heat-game-Heat-Game-E2E-Te-c664c--rapid-clicking-on-the-grid-chromium/attachments/browser-logs-8830c25d0c901f07d14f24299509ec6ff3fc0a0b.log"
                        }
                      ]
                    }
                  ],
                  "status": "expected"
                }
              ],
              "id": "6ea310f0033cac01bab6-1b3f7a34798ed668be9c",
              "file": "heat-game.spec.ts",
              "line": 333,
              "column": 3
            }
          ]
        }
      ]
    }
  ],
  "errors": [],
  "stats": {
    "startTime": "2026-01-31T12:42:39.026Z",
    "duration": 15185.764,
    "expected": 8,
    "skipped": 0,
    "unexpected": 0,
    "flaky": 0
  }
}